#!/usr/bin/env node
;(function() {
  'use strict';

  /** Load Node.js modules */
  var vm = require('vm');

  /** Load other modules */
  var _ = require('lodash/lodash.js'),
      minify = require('../lib/minify.js'),
      util = require('../lib/util.js');

  /** Module shortcuts */
  var fs = util.fs,
      path = util.path;

  /** The current working directory */
  var cwd = process.cwd();

  /** Used for array and object method references */
  var arrayRef = Array.prototype,
      objectRef = Object.prototype;

  /** Native method shortcuts */
  var create = Object.create,
      hasOwnProperty = objectRef.hasOwnProperty,
      push = arrayRef.push,
      slice = arrayRef.slice;

  /** Memoize regexp creation */
  var RegExp = (function() {
    var cache = createMap();
    return function(pattern, flags) {
      if (flags && /g/.test(flags)) {
        return global.RegExp(pattern, flags);
      }
      var key = '/' + pattern + '/' + (flags || '');
      return cache[key] || (cache[key] = global.RegExp(pattern, flags));
    };
  }());

  /** Used to create regexes that may detect multi-line comment blocks */
  var multilineComment = '(?:\\n */\\*[^*]*\\*+(?:[^/][^*]*\\*+)*/)?\\n';

  /** Used to detect the Node.js executable in command-line arguments */
  var reNode = RegExp('(?:^|' + path.sepEscaped + ')node(?:\\.exe)?$', 'i');

  /** Used to match string literals */
  var reStrings = /(["'])(?:(?!\1)[^\n\\]|\\.)*\1/g;

  /** Shortcut to the `stdout` object */
  var stdout = process.stdout;

  /** Used to associate aliases with their real names */
  var aliasToRealMap = createMap({
    'all': 'every',
    'any': 'some',
    'collect': 'map',
    'detect': 'find',
    'drop': 'rest',
    'each': 'forEach',
    'eachRight': 'forEachRight',
    'extend': 'assign',
    'findWhere': 'find',
    'foldl': 'reduce',
    'foldr': 'reduceRight',
    'head': 'first',
    'include': 'contains',
    'inject': 'reduce',
    'methods': 'functions',
    'object': 'zipObject',
    'select': 'filter',
    'tail': 'rest',
    'take': 'first',
    'unique': 'uniq',
    'unzip': 'zip',
    'value': 'wrapperValueOf'
  });

  /** Used to associate real names with their aliases */
  var realToAliasMap = createMap({
    'assign': ['extend'],
    'contains': ['include'],
    'every': ['all'],
    'filter': ['select'],
    'find': ['detect', 'findWhere'],
    'first': ['head', 'take'],
    'forEach': ['each'],
    'forEachRight': ['eachRight'],
    'functions': ['methods'],
    'map': ['collect'],
    'reduce': ['foldl', 'inject'],
    'reduceRight': ['foldr'],
    'rest': ['drop', 'tail'],
    'some': ['any'],
    'uniq': ['unique'],
    'wrapperValueOf': ['value'],
    'zip': ['unzip'],
    'zipObject': ['object']
  });

  /** Used to track function dependencies */
  var funcDependencyMap = createMap({
    // properties
    'support': ['isNative'],
    'templateSettings': ['escape'],

    // public functions
    'after': ['isFunction'],
    'assign': ['baseCreateCallback', 'isObject', 'keys'],
    'at': ['baseFlatten', 'isString'],
    'bind': ['createWrapper', 'slice'],
    'bindAll': ['baseFlatten', 'createWrapper', 'functions'],
    'bindKey': ['createWrapper', 'slice'],
    'chain': ['lodashWrapper'],
    'clone': ['baseClone', 'baseCreateCallback'],
    'cloneDeep': ['baseClone', 'baseCreateCallback'],
    'compact': [],
    'compose': ['isFunction'],
    'constant': [],
    'contains': ['baseEach', 'getIndexOf', 'isArray', 'isNative', 'isString'],
    'countBy': ['createAggregator'],
    'create': ['assign', 'baseCreate'],
    'createCallback': ['baseCreateCallback', 'match', 'property'],
    'curry': ['createWrapper'],
    'debounce': ['isFunction', 'isObject', 'now'],
    'defaults': ['isObject', 'keys'],
    'defer': ['isFunction', 'slice'],
    'delay': ['isFunction', 'slice'],
    'difference': ['baseDifference', 'baseFlatten'],
    'escape': ['escapeHtmlChar'],
    'every': ['baseEach', 'createCallback', 'isArray'],
    'filter': ['baseEach', 'createCallback', 'isArray'],
    'find': ['baseEach', 'createCallback', 'isArray'],
    'findIndex': ['createCallback'],
    'findLastIndex': ['createCallback'],
    'findKey': ['createCallback', 'forOwn'],
    'findLast': ['createCallback', 'forEachRight'],
    'findLastKey': ['createCallback', 'forOwnRight'],
    'first': ['createCallback', 'slice'],
    'flatten': ['baseFlatten', 'map'],
    'forEach': ['baseCreateCallback', 'baseEach', 'isArray'],
    'forEachRight': ['baseCreateCallback', 'baseEach', 'isArray', 'isString', 'keys'],
    'forIn': ['createIterator'],
    'forInRight': ['baseCreateCallback', 'forIn'],
    'forOwn': ['baseCreateCallback', 'keys'],
    'forOwnRight': ['baseCreateCallback', 'keys'],
    'functions': ['forIn', 'isFunction'],
    'groupBy': ['createAggregator'],
    'has': [],
    'identity': [],
    'indexBy': ['createAggregator'],
    'indexOf': ['baseIndexOf', 'sortedIndex'],
    'initial': ['createCallback', 'slice'],
    'intersection': ['cacheIndexOf', 'createCache', 'getArray', 'getIndexOf', 'isArguments', 'isArray', 'releaseArray', 'releaseObject'],
    'invert': ['keys'],
    'invoke': ['forEach', 'slice'],
    'isArguments': [],
    'isArray': ['isNative'],
    'isBoolean': [],
    'isDate': [],
    'isElement': ['isNode', 'isPlainObject'],
    'isEmpty': ['forOwn', 'isArguments', 'isFunction'],
    'isEqual': ['baseCreateCallback', 'baseIsEqual'],
    'isFinite': [],
    'isFunction': [],
    'isNaN': ['isNumber'],
    'isNull': [],
    'isNumber': [],
    'isObject': [],
    'isPlainObject': ['isArguments', 'isNative', 'shimIsPlainObject'],
    'isRegExp': [],
    'isString': [],
    'isUndefined': [],
    'keys': ['isArguments', 'isNative', 'isObject', 'shimKeys'],
    'last': ['createCallback', 'slice'],
    'lastIndexOf': [],
    'lodash': ['isArray', 'lodashWrapper'],
    'map': ['baseEach', 'createCallback', 'isArray'],
    'mapValues': ['createCallback', 'forOwn'],
    'match': ['baseIsEqual', 'isObject', 'keys'],
    'max': ['baseEach', 'charAtCallback', 'createCallback', 'isArray', 'isString'],
    'memoize': ['isFunction'],
    'merge': ['baseCreateCallback', 'baseMerge', 'getArray', 'isObject', 'releaseArray', 'slice'],
    'min': ['baseEach', 'charAtCallback', 'createCallback', 'isArray', 'isString'],
    'mixin': ['forEach', 'functions', 'isFunction', 'isObject', 'lodash'],
    'noConflict': [],
    'noop': [],
    'now': ['isNative'],
    'omit': ['baseDifference', 'baseFlatten', 'createCallback', 'forIn'],
    'once': ['isFunction'],
    'pairs': ['keys'],
    'parseInt': ['isString'],
    'partial': ['createWrapper', 'slice'],
    'partialRight': ['createWrapper', 'slice'],
    'pick': ['baseFlatten', 'createCallback', 'forIn', 'isObject'],
    'pluck': ['map'],
    'property': [],
    'pull': [],
    'random': ['baseRandom'],
    'range': [],
    'reduce': ['baseEach', 'createCallback', 'isArray'],
    'reduceRight': ['createCallback', 'forEachRight'],
    'reject': ['createCallback', 'filter'],
    'remove': ['createCallback'],
    'rest': ['createCallback', 'slice'],
    'result': ['isFunction'],
    'runInContext': ['defaults', 'pick'],
    'sample': ['baseRandom', 'isString', 'shuffle', 'values'],
    'shuffle': ['baseRandom', 'forEach'],
    'size': ['keys'],
    'some': ['baseEach', 'createCallback', 'isArray'],
    'sortBy': ['compareAscending', 'createCallback', 'forEach', 'getArray', 'getObject', 'isArray', 'map', 'releaseArray', 'releaseObject'],
    'sortedIndex': ['createCallback', 'identity'],
    'tap': [],
    'template': ['defaults', 'escape', 'escapeStringChar', 'keys', 'values'],
    'throttle': ['debounce', 'isFunction', 'isObject'],
    'times': ['baseCreateCallback'],
    'toArray': ['isString', 'slice', 'values'],
    'transform': ['baseCreate', 'baseEach', 'createCallback', 'forOwn', 'isArray'],
    'unescape': ['unescapeHtmlChar'],
    'union': ['baseFlatten', 'baseUniq'],
    'uniq': ['baseUniq', 'createCallback'],
    'uniqueId': [],
    'values': ['keys'],
    'where': ['filter'],
    'without': ['baseDifference', 'slice'],
    'wrap': ['createWrapper'],
    'wrapperChain': [],
    'wrapperToString': [],
    'wrapperValueOf': [],
    'xor': ['baseDifference', 'baseUniq', 'isArguments', 'isArray'],
    'zip': ['max', 'pluck'],
    'zipObject': ['isArray'],

    // private functions
    'baseBind': ['baseCreate', 'isObject', 'setBindData', 'slice'],
    'baseClone': ['assign', 'baseEach', 'forOwn', 'getArray', 'isArray', 'isObject', 'isNode', 'releaseArray', 'slice'],
    'baseCreate': ['isNative', 'isObject', 'noop'],
    'baseCreateCallback': ['bind', 'identity', 'setBindData'],
    'baseCreateWrapper': ['baseCreate', 'isObject', 'slice', 'setBindData'],
    'baseDifference': ['cacheIndexOf', 'createCache', 'getIndexOf', 'releaseObject'],
    'baseEach': ['baseCreateCallback', 'forOwn', 'isString'],
    'baseFlatten': ['isArguments', 'isArray'],
    'baseIndexOf': [],
    'baseIsEqual': ['forIn', 'getArray', 'isArguments', 'isFunction', 'isNode', 'releaseArray'],
    'baseMerge': ['forEach', 'forOwn', 'isArray', 'isPlainObject'],
    'baseRandom': [],
    'baseUniq': ['cacheIndexOf', 'createCache', 'getArray', 'getIndexOf', 'releaseArray', 'releaseObject'],
    'cacheIndexOf': ['baseIndexOf'],
    'cachePush': [],
    'charAtCallback': [],
    'compareAscending': [],
    'createAggregator': ['baseEach', 'createCallback', 'isArray'],
    'createWrapper': ['baseBind', 'baseCreateWrapper', 'isFunction', 'slice'],
    'createCache': ['cachePush', 'getObject', 'releaseObject'],
    'createIterator': ['baseCreateCallback', 'isArguments', 'iteratorTemplate'],
    'escapeHtmlChar': [],
    'escapeStringChar': [],
    'getArray': [],
    'getIndexOf': ['baseIndexOf', 'indexOf'],
    'getObject': [],
    'isNative': [],
    'isNode': [],
    'iteratorTemplate': [],
    'lodashWrapper': [],
    'releaseArray': [],
    'releaseObject': [],
    'setBindData': ['isNative', 'noop'],
    'shimIsPlainObject': ['forIn', 'isArguments', 'isFunction', 'isNode'],
    'shimKeys': ['createIterator'],
    'slice': [],
    'unescapeHtmlChar': [],

    // used by the `backbone` and `underscore` builds
    'findWhere': ['where']
  });

  /** Used to track Lo-Dash object dependencies of identifiers */
  var objDependencyMap = createMap({
    'at': ['support'],
    'baseClone': ['support'],
    'baseCreateCallback': ['support'],
    'baseEach': ['support'],
    'baseIsEqual': ['support'],
    'bind': ['support'],
    'forEachRight': ['support'],
    'isArguments': ['support'],
    'isElement': ['support'],
    'isEmpty': ['support'],
    'isPlainObject': ['support'],
    'iteratorTemplate': ['support'],
    'keys': ['support'],
    'sample': ['support'],
    'shimIsPlainObject': ['support'],
    'template': ['templateSettings'],
    'toArray': ['support'],
    'wrapperValueOf': ['support']
  });

  /** Used to track variable dependencies of identifiers */
  var varDependencyMap = createMap({
    'baseClone': ['hasOwnProperty', 'toString'],
    'baseCreate': ['root'],
    'baseDifference': ['largeArraySize'],
    'baseIsEqual': ['hasOwnProperty', 'objectTypes', 'toString'],
    'baseUniq': ['largeArraySize'],
    'cacheIndexOf': ['keyPrefix'],
    'cachePush': ['keyPrefix'],
    'countBy': ['hasOwnProperty'],
    'createIterator': ['hasOwnProperty', 'indicatorObject', 'objectTypes', 'toString'],
    'escape': ['reUnescapedHtml'],
    'escapeHtmlChar': ['htmlEscapes'],
    'getArray': ['arrayPool'],
    'getObject': ['objectPool'],
    'groupBy': ['hasOwnProperty'],
    'has':['hasOwnProperty'],
    'intersection': ['largeArraySize'],
    'invert': ['hasOwnProperty'],
    'isArguments': ['hasOwnProperty', 'toString'],
    'isArray': ['toString'],
    'isBoolean': ['toString'],
    'isDate': ['toString'],
    'isElement': ['toString'],
    'isEmpty': ['toString'],
    'isFinite': ['root'],
    'isFunction': ['toString'],
    'isObject': ['objectTypes'],
    'isNative': ['reNative'],
    'isNumber': ['toString'],
    'isPlainObject': ['toString'],
    'isRegExp': ['objectTypes', 'toString'],
    'isString': ['toString'],
    'lodash': ['hasOwnProperty'],
    'memoize': ['hasOwnProperty', 'keyPrefix'],
    'parseInt': ['root'],
    'releaseArray': ['arrayPool', 'maxPoolSize'],
    'releaseObject': ['maxPoolSize', 'objectPool'],
    'reNative': ['toString'],
    'root': ['objectTypes'],
    'shimIsPlainObject': ['hasOwnProperty', 'toString'],
    'support': ['reNative', 'root', 'toString'],
    'template': ['reInterpolate'],
    'templateSettings': ['reEscape', 'reEvaluate', 'reInterpolate'],
    'unescape': ['reEscapedHtml'],
    'unescapeHtmlChar': ['htmlUnescapes']
  });

  /** Used to track the category of identifiers */
  var categoryMap = createMap({
    'Arrays': [
      'compact',
      'difference',
      'findIndex',
      'findLastIndex',
      'first',
      'flatten',
      'indexOf',
      'initial',
      'intersection',
      'last',
      'lastIndexOf',
      'pull',
      'range',
      'remove',
      'rest',
      'sortedIndex',
      'union',
      'uniq',
      'without',
      'xor',
      'zip',
      'zipObject'
    ],
    'Chaining': [
      'chain',
      'lodash',
      'tap',
      'wrapperChain',
      'wrapperToString',
      'wrapperValueOf'
    ],
    'Collections': [
      'at',
      'contains',
      'countBy',
      'every',
      'filter',
      'find',
      'findLast',
      'findWhere',
      'forEach',
      'forEachRight',
      'groupBy',
      'indexBy',
      'invoke',
      'map',
      'max',
      'min',
      'pluck',
      'reduce',
      'reduceRight',
      'reject',
      'sample',
      'shuffle',
      'size',
      'some',
      'sortBy',
      'toArray',
      'where'
    ],
    'Functions': [
      'after',
      'bind',
      'bindAll',
      'bindKey',
      'compose',
      'curry',
      'debounce',
      'defer',
      'delay',
      'memoize',
      'once',
      'partial',
      'partialRight',
      'throttle',
      'wrap',

      // deprecated
      'createCallback'
    ],
    'Objects': [
      'assign',
      'clone',
      'cloneDeep',
      'create',
      'defaults',
      'findKey',
      'findLastKey',
      'forIn',
      'forInRight',
      'forOwn',
      'forOwnRight',
      'functions',
      'has',
      'invert',
      'isArguments',
      'isArray',
      'isBoolean',
      'isDate',
      'isElement',
      'isEmpty',
      'isEqual',
      'isFinite',
      'isFunction',
      'isNaN',
      'isNull',
      'isNumber',
      'isObject',
      'isPlainObject',
      'isRegExp',
      'isString',
      'isUndefined',
      'keys',
      'mapValues',
      'merge',
      'omit',
      'pairs',
      'pick',
      'transform',
      'values'
    ],
    'Utilities': [
      'constant',
      'createCallback',
      'escape',
      'identity',
      'match',
      'mixin',
      'noConflict',
      'noop',
      'now',
      'parseInt',
      'property',
      'random',
      'result',
      'runInContext',
      'template',
      'templateSettings',
      'times',
      'unescape',
      'uniqueId'
    ]
  });

  /* Used to enforce dependencies at the top level */
  var topLevel = createMap({
    'lodash': true,
    'support': true
  });

  /** List of Backbone's Lo-Dash dependencies */
  var backboneDependencies = [
    'bind',
    'bindAll',
    'chain',
    'clone',
    'contains',
    'countBy',
    'defaults',
    'difference',
    'escape',
    'every',
    'extend',
    'filter',
    'find',
    'first',
    'forEach',
    'groupBy',
    'has',
    'indexOf',
    'initial',
    'invert',
    'invoke',
    'isArray',
    'isEmpty',
    'isEqual',
    'isFunction',
    'isObject',
    'isRegExp',
    'isString',
    'keys',
    'last',
    'lastIndexOf',
    'lodash',
    'map',
    'max',
    'min',
    'mixin',
    'omit',
    'once',
    'pairs',
    'pick',
    'reduce',
    'reduceRight',
    'reject',
    'rest',
    'result',
    'shuffle',
    'size',
    'some',
    'sortBy',
    'sortedIndex',
    'toArray',
    'uniqueId',
    'value',
    'values',
    'without',
    'wrapperChain',
    'wrapperValueOf'
  ];

  /** List of all function categories */
  var allCategories = _.keys(categoryMap);

  /** List of all the ways to export the `lodash` function */
  var allExports = [
    'amd',
    'commonjs',
    'es6',
    'global',
    'node',
    'npm'
  ];

  /** List of variables with complex assignments */
  var complexVars = [
    'cloneableClasses',
    'contextProps',
    'ctorByClass',
    'defineProperty',
    'freeGlobal',
    'nonEnumProps',
    'shadowedProps',
    'support',
    'whitespace'
  ];

  /** Used to inline `iteratorTemplate` */
  var iteratorOptions = [
    'args',
    'init',
    'loop',
    'shadowedProps',
    'support',
    'top',
    'useHas'
  ];

  /** List of Lo-Dash only functions */
  var lodashOnlyFuncs = [
    'at',
    'bindKey',
    'cloneDeep',
    'constant',
    'create',
    'createCallback',
    'curry',
    'findIndex',
    'findKey',
    'findLast',
    'findLastIndex',
    'findLastKey',
    'forEachRight',
    'forIn',
    'forInRight',
    'forOwn',
    'forOwnRight',
    'isPlainObject',
    'mapValues',
    'match',
    'merge',
    'noop',
    'now',
    'parseInt',
    'partialRight',
    'property',
    'pull',
    'remove',
    'runInContext',
    'transform',
    'wrapperToString',
    'xor'
  ];

  /** List of private functions */
  var privateFuncs = [
    'baseBind',
    'baseClone',
    'baseCreate',
    'baseCreateCallback',
    'baseCreateWrapper',
    'baseDifference',
    'baseEach',
    'baseFlatten',
    'baseIndexOf',
    'baseIsEqual',
    'baseMerge',
    'baseRandom',
    'baseUniq',
    'cacheIndexOf',
    'cachePush',
    'charAtCallback',
    'compareAscending',
    'createAggregator',
    'createWrapper',
    'createCache',
    'createIterator',
    'escapeHtmlChar',
    'escapeStringChar',
    'getArray',
    'getIndexOf',
    'getObject',
    'isNative',
    'isNode',
    'iteratorTemplate',
    'lodashWrapper',
    'releaseArray',
    'releaseObject',
    'setBindData',
    'shimIsPlainObject',
    'shimKeys',
    'slice',
    'unescapeHtmlChar'
  ];

  /** List of all property dependencies */
  var objDependencies = _.uniq(_.transform(objDependencyMap, function(result, objNames) {
    push.apply(result, objNames);
  }, []));

  /** List of all variable dependencies */
  var varDependencies = _.uniq(_.transform(varDependencyMap, function(result, varNames) {
    push.apply(result, varNames);
  }, []));

  /** List of all functions */
  var allFuncs = _.difference(_.keys(funcDependencyMap), objDependencies, varDependencies).filter(function(key) {
    var type = typeof _[key];
    return type == 'function' || type == 'undefined';
  });

  /** List of Lo-Dash functions */
  var lodashFuncs = _.difference(allFuncs, privateFuncs, ['findWhere']);

  /** List of Underscore functions */
  var underscoreFuncs = _.difference(allFuncs, lodashOnlyFuncs, privateFuncs);

  /*--------------------------------------------------------------------------*/

  /**
   * Adds build `commands` to the copyright/license header of `source`.
   *
   * @private
   * @param {string} source The source to process.
   * @param {Array} [commands=[]] An array of commands.
   * @returns {string} Returns the modified source.
   */
  function addCommandsToHeader(source, commands) {
    return source.replace(/(\/\**\n)( \*)( *@license[\s*]+)?( *Lo-Dash [.$\w\-]+)(.*)/, function() {
      // remove `node path/to/build.js` from `commands`
      if (reNode.test(commands[0])) {
        commands.splice(0, 2);
      }
      // add quotes to commands with spaces or equals signs
      commands = _.map(commands, function(command) {
        var separator = command.match(/[= ]/);
        if (separator) {
          separator = separator[0];
          var pair = command.split(separator);
          command = pair[0] + separator + '"' + pair[1] + '"';
        }
        // escape newlines, carriage returns, multi-line comment end tokens
        command = command
          .replace(/\n/g, '\\n')
          .replace(/\r/g, '\\r')
          .replace(/\*\//g, '*\\/');

        return command;
      });
      // add build commands to copyright/license header
      var parts = slice.call(arguments, 1);
      return (
        parts[0] +
        parts[1] +
        (parts[2] || '') +
        parts[3] + ' (Custom Build)' + parts[4] + '\n' +
        parts[1] + ' Build: `lodash ' + commands.join(' ') + '`'
      );
    });
  }

  /**
   * Adds support for Underscore style chaining to `source`.
   *
   * @private
   * @param {string} source The source to process.
   * @param {boolean} [isModularize=false] A flag to specify a modularize build
   * @returns {string} Returns the modified source.
   */
  function addUnderscoreChaining(source, isModularize) {
    // replace `_.mixin`
    source = replaceFunction(source, 'mixin', (isModularize
      ? [
          'function mixin(object, source) {',
          '  if (!source) {',
          '    ctor = lodashWrapper;',
          '    source = object;',
          '    object = lodash;',
          '  }',
          '  var ctor = object,',
          '      isFunc = isFunction(ctor);',
          '',
          '  forEach(functions(source), function(methodName) {',
          '    var func = object[methodName] = source[methodName];',
          '    if (isFunc) {',
          '      ctor.prototype[methodName] = function() {',
          '        var args = [this.__wrapped__];',
          '        push.apply(args, arguments);',
          '',
          '        var result = func.apply(object, args);',
          '        if (this.__chain__) {',
          '          result = new ctor(result);',
          '          result.__chain__ = true;',
          '        }',
          '        return result;',
          '      };',
          '    }',
          '  });',
          '}'
        ]
      : [
          'function mixin(object) {',
          '  forEach(functions(object), function(methodName) {',
          '    var func = lodash[methodName] = object[methodName];',
          '',
          '    lodash.prototype[methodName] = function() {',
          '      var args = [this.__wrapped__];',
          '      push.apply(args, arguments);',
          '',
          '      var result = func.apply(lodash, args);',
          '      return this.__chain__',
          '        ? new lodashWrapper(result, true)',
          '        : result;',
          '    };',
          '  });',
          '}'
        ]
    ).join('\n'));

    // move `mixin(...)`
    source = source.replace(getMethodAssignments(source), function(match) {
      match = removeMixinCalls(match);

      // insert `mixin(...)` before `_.VERSION`
      return match.replace(/(?:\n *\/\*[^*]*\*+(?:[^\/][^*]*\*+)*\/)?\n( *)lodash\.VERSION/, function(match, indent) {
        return [
          '',
          '// add functions to `lodash.prototype`',
          'mixin(assign({}, lodash));',
          match
        ].join('\n' + indent);
      });
    });

    // replace wrapper `Array` method assignments
    source = source.replace(/^(?:(?: *\/\/.*\n)*(?: *if *\(.+\n)?( *)(baseEach|forEach)\(\['[\s\S]+?\n\1}\);(?:\n *})?\n+)+/m, function(match, indent, funcName) {
      return indent + [
        '// add `Array` mutator functions to the wrapper',
        funcName + "(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(methodName) {",
        '  var func = arrayRef[methodName];',
        '  lodash.prototype[methodName] = function() {',
        '    var value = this.__wrapped__;',
        '    func.apply(value, arguments);',
        '',
        '    // avoid array-like object bugs with `Array#shift` and `Array#splice`',
        '    // in Firefox < 10 and IE < 9',
        '    if (!support.spliceObjects && value.length === 0) {',
        '      delete value[0];',
        '    }',
        '    return this;',
        '  };',
        '});',
        '',
        '// add `Array` accessor functions to the wrapper',
        funcName + "(['concat', 'join', 'slice'], function(methodName) {",
        '  var func = arrayRef[methodName];',
        '  lodash.prototype[methodName] = function() {',
        '    var value = this.__wrapped__,',
        '        result = func.apply(value, arguments);',
        '',
        '    if (this.__chain__) {',
        '      result = new lodashWrapper(result);',
        '      result.__chain__ = true;',
        '    }',
        '    return result;',
        '  };',
        '});',
        ''
      ].join('\n' + indent);
    });

    // remove `lodash.prototype.toString` and `lodash.prototype.valueOf` assignments
    source = source.replace(/^ *lodash\.prototype\.(?:toString|valueOf) *=.+\n/gm, '');

    // remove `lodash.prototype` batch method assignments
    source = source.replace(/(?:\s*\/\/.*)*\n( *)forOwn\(lodash,[\s\S]+?\n\1}.+/g, '');

    return source;
  }

  /**
   * Creates modules based on the provided build state.
   *
   * @private
   * @param {Object} state The build state object.
   * @param {Function} [callback] The function called when all module builds are completed.
   */
  function buildModule(state, callback) {
    var buildFuncs = state.buildFuncs,
        funcDepMap = state.funcDepMap,
        includeObjs = state.includeObjs,
        includeVars = state.includeVars,
        isAMD = state.isAMD,
        isCommonJS = state.isCommonJS,
        isES6 = state.isES6,
        isNode = state.isNode,
        isNpm = state.isNpm,
        isUnderscore = state.isUnderscore,
        objDepMap = state.objDepMap,
        outputPath = state.outputPath,
        varDepMap = state.varDepMap;

    var templatePath = fs.realpathSync(path.join(__dirname, '..', 'template')),
        licenseTemplate = fs.readFileSync(path.join(templatePath, 'license.jst'), 'utf-8'),
        packageTemplate = fs.readFileSync(path.join(templatePath, 'package.jst'), 'utf-8'),
        readmeTemplate = fs.readFileSync(path.join(templatePath, 'readme.jst'), 'utf-8');

    var empty = [],
        identifiers = _.pull(buildFuncs.concat(includeObjs, includeVars), 'lodash'),
        version = state.lodash.VERSION;

    var categories = _.uniq(_.compact(identifiers.map(function(identifier) {
      return getCategory(identifier, funcDepMap);
    }))).sort();

    var internals = _.reject(identifiers, function(identifier) {
      return topLevel[identifier] || getCategory(identifier, funcDepMap);
    });

    var buildCallback = function(data) {
      var source = data.source;
      source = addCommandsToHeader(source, state.options);
      data.source = cleanupSource(source);
      defaultBuildCallback(data);
    };

    // prepare state
    state.isAMD = state.isCommonJS = state.isNode = state.isNpm = false;
    state.plusFuncs = state.minusFuncs = empty;

    if (isNpm) {
      // exclude `_.noConflict` and "Chaining" methods
      identifiers = _.difference(identifiers, categoryMap.Chaining.concat('noConflict'));
    }
    // create modules for each identifier
    identifiers.forEach(function(identifier) {
      var isInternal = _.contains(internals, identifier),
          moduleName = isNpm ? 'lodash.' + (isInternal ? '_' : '') + identifier.toLowerCase() : identifier,
          modulePath = isNpm ? moduleName : getPath(identifier, funcDepMap),
          iife = [];

      var deps = getDependencies(identifier, funcDepMap, true)
        .concat(objDepMap[identifier] || empty)
        .concat(varDepMap[identifier] || empty)
        .sort();

      var depPaths = isNpm
        ? deps.map(function(dep) { return 'lodash.' + (_.contains(internals, dep) ? '_' : '') + dep.toLowerCase(); })
        : getDepPaths(deps, modulePath, funcDepMap);

      if (isAMD) {
        iife.push(
          'define([' + (depPaths.length ? "'" + depPaths.join("', '") + "'" : '') + '], function(' + deps.join(', ') + ') {',
          '%output%',
          '  return ' + identifier + ';',
          '});'
        );
      }
      else if (isES6) {
        iife.push(
          _.reduce(depPaths, function(result, depPath, index) {
            var depName = deps[index];
            return result + (result ? ';\n' : '') +
              '  import ' + depName + " from '" + depPath + "'";
          }, '') + ';',
          '%output%',
          'export default ' + identifier + ';'
        );
      }
      else {
        iife.push(
          _.reduce(depPaths, function(result, depPath, index) {
            var depName = deps[index];
            return result + (result ? ',\n      ' : '  var ') +
              depName + " = require('" + depPath + "')" +
              (isCommonJS ? '.' + depName : '');
          }, '') + ';',
          '%output%',
          (isCommonJS ? 'exports.' + identifier : 'module.exports') + ' = ' + identifier + ';'
        );
      }

      state.buildFuncs = state.includeFuncs = state.includeObjs = state.includeVars = empty;
      state.iife = iife.join('\n');
      state.outputPath = path.join(outputPath, modulePath, (isNpm ? 'index' : identifier) + '.js');

      var include = [identifier];
      if (_.contains(includeObjs, identifier)) {
        state.includeObjs = include;
      } else if (_.contains(includeVars, identifier)) {
        state.includeVars = include;
      } else {
        state.buildFuncs = state.includeFuncs = include;
      }
      build(state, function(data) {
        var source = data.source;
        if (!isAMD) {
          source = trimIndent(source);
        }
        data.source = removeLicenseTag(source);
        buildCallback(data);

        if (isNpm) {
          var keywords = isInternal
            ? []
            : ['functional', 'lodash', 'lodash-modularized', 'server', 'util'];

          var type = _.contains(objDependencies, identifier)
            ? 'object'
            : (_.contains(varDependencies, identifier) ? 'variable' : 'function');

          var moduleDesc = 'The ' +
            (isInternal ? 'internal ' : '') +
            'Lo-Dash ' + type + ' `' + (isInternal ? '' : '_.') +
            identifier + '` as a Node.js module generated by lodash-cli.';

          var markdownDesc = moduleDesc
            .replace('Lo-Dash', '[Lo-Dash](http://lodash.com/)')
            .replace('Node.js', '[Node.js](http://nodejs.org/)')
            .replace('lodash-cli', '[lodash-cli](https://npmjs.org/package/lodash-cli)')
            .replace(/`_\.([$\w]+)`/, '[$&](http://lodash.com/docs#$1)');

          var templateData = {
            'name': moduleName,
            'version': version,
            'description': moduleDesc,
            'keywords': keywords,
            'dependencies': _.transform(depPaths, function(result, depPath) {
              result[depPath] = '~' + version;
            }, {})
          };

          fs.writeFileSync(path.join(outputPath, modulePath, 'package.json'), _.template(packageTemplate, templateData), 'utf-8');
          fs.writeFileSync(path.join(outputPath, modulePath, 'LICENSE.txt'), _.template(licenseTemplate, templateData), 'utf-8');
          fs.writeFileSync(path.join(outputPath, modulePath, 'README.md'), _.template(readmeTemplate, _.defaults({ 'description': markdownDesc }, templateData)), 'utf-8');
        }
      });
    });

    // create lodash module
    (function() {
      if (isNpm || !_.contains(buildFuncs, 'lodash')) {
        return;
      }
      var categoryDeps = _.invoke(categories, 'toLowerCase'),
          categoryDepPaths = categoryDeps.map(function(dep) { return './' + dep; }),
          identifier = 'lodash',
          basename = identifier,
          modulePath = getPath(identifier, funcDepMap);

      var deps = getDependencies(identifier, funcDepMap, true)
        .concat(objDepMap[identifier] || empty)
        .concat(varDepMap[identifier] || empty)
        .sort();

      var depNames = categoryDeps.concat(deps),
          depArgs = depNames.join(', '),
          depPaths = categoryDepPaths.concat(getDepPaths(deps, modulePath, funcDepMap)),
          iife = [];

      if (isAMD) {
        basename = 'main';

        iife.push(
          'define([' + (depPaths.length ? "'" + depPaths.join("', '") + "'" : '') + '], function(' + depArgs + ') {',
          '%output%',
          '  return lodash;',
          '});'
        );
      }
      else {
        if (isES6) {
          iife.push(
            _.reduce(depPaths, function(result, depPath, index) {
              var depName = depNames[index];
              return result + (result ? ';\n' : '') +
                '  import ' + depName + " from '" + depPath + "'";
            }, '') + ';',
            '%output%',
            'export default ' + identifier + ';'
          );
        }
        else {
          basename = 'index';

          iife.push(
            _.reduce(depPaths, function(result, depPath, index) {
              var depName = depNames[index];
              return result + (result ? ',\n      ' : '  var ') +
                depName + " = require('" + depPath + "')" +
                (isCommonJS && !_.contains(categoryDepPaths, depPath) ? '.' + depName : '');
            }, '') + ';',
            '%output%',
            (isCommonJS ? 'exports._' : 'module.exports') + ' = ' + identifier + ';'
          );
        }
      }

      state.iife = iife.join('\n');
      state.buildFuncs = state.includeFuncs = [identifier];
      state.includeObjs = state.includeVars = empty;
      state.outputPath = path.join(outputPath, modulePath, basename + '.js');

      build(state, function(data) {
        var source = data.source;

        // remove unneeded method and alias assignments
        _.each(_.difference(allFuncs, buildFuncs), function(funcName) {
          source = source.replace(RegExp('^(?: *//.*\\s*)* *lodash(?:\\.prototype)?\\.[$\\w]+ *= *' + funcName + ';\\n', 'gm'), '');
        });

        // add category namespaces to each lodash function assignment
        source = source.replace(/(lodash(?:\.prototype)?\.[$\w]+\s*=\s*)([$\w]+)/g, function(match, prelude, identifier) {
          return _.contains(deps, identifier)
            ? match
            : prelude + getCategory(identifier, funcDepMap).toLowerCase() + '.' + identifier;
        });

        // wrap `_.mixin`
        source = source.replace(/^ *lodashWrapper\.prototype\s*=[^;]+;\n/m, function(match) {
          var code = [
            '',
            '  // wrap `_.mixin` so it works when provided only one argument',
            '  mixin = (function(fn) {'
          ];

          if (isUnderscore) {
            code.push(
              '    return function(object, source) {',
              '      if (!source) {',
              '        source = object;',
              '        object = lodash;',
              '      }',
              '      return fn(object, source);'
            );
          } else {
            code.push(
              '    var functions = objects.functions;',
              '    return function(object, source, options) {',
              '      if (!source || (!options && !functions(source).length)) {',
              '        if (options == null) {',
              '          options = source;',
              '        }',
              '        source = object;',
              '        object = lodash;',
              '      }',
              '      return fn(object, source, options);'
            );
          }
          code.push(
            '    };',
            '  }(mixin));',
            ''
          );
          return match + code.join('\n');
        });

        // add `_.support` and `_.templateSettings`
        source = source.replace(/^ *(return +|.*?exports.*?=\s*)lodash;$/m, function(match) {
          var prelude = '';
          if (_.contains(deps, 'support')) {
            prelude += '  lodash.support = support;\n';
          }
          if (_.contains(deps, 'templateSettings')) {
            prelude += '  (lodash.templateSettings = utilities.templateSettings).imports._ = lodash;\n';
          }
          return prelude + match;
        });

        if (!isAMD) {
          source = trimIndent(source);
        }
        data.source = source;
        buildCallback(data);
      });
    }());

    // create category modules
    if (!isNpm) {
      categories.forEach(function(category) {
        var deps = _.intersection(categoryMap[category], identifiers).sort(),
            depPaths = getDepPaths(deps, null, funcDepMap),
            iife = [];

        if (isAMD) {
          iife.push(
            "define(['" + depPaths.join("', '") + "'], function(" + deps.join(', ') + ') {',
            '%output%',
            '  return {',
            _.transform(deps, function(result, depName) {
              _.each(getAliases(depName, funcDepMap).concat(depName), function(otherName) {
                result.push( "    '" + otherName + "': " + depName);
              });
            })
            .sort()
            .join(',\n'),
            '  };',
            '});'
          );
        }
        else {
          iife.push('%output%');

          if (isES6) {
            push.apply(iife, _.transform(depPaths, function(result, depPath, index) {
              var depName = deps[index];
              _.each(getAliases(depName, funcDepMap).concat(depName), function(otherName) {
                result.push('export ' + otherName + " from '" + depName + "';");
              });
            })
            .sort());
          }
          else if (isCommonJS) {
            push.apply(iife, _.transform(depPaths, function(result, depPath, index) {
              var depName = deps[index];
              _.each(getAliases(depName, funcDepMap).concat(depName), function(otherName) {
                result.push('exports.' + otherName + " = require('" + depPath + "')." + depName + ';');
              });
            })
            .sort());
          }
          else {
            iife.push(
              'module.exports = {',
              _.transform(depPaths, function(result, depPath, index) {
                var depName = deps[index];
                _.each(getAliases(depName, funcDepMap).concat(depName), function(otherName) {
                  result.push("  '" + otherName + "': require('" + depPath + "')");
                });
              })
              .sort()
              .join(',\n'),
              '};'
            );
          }
        }
        state.iife = iife.join('\n');
        state.buildFuncs = state.includeFuncs = state.includeObjs = state.includeVars = empty;
        state.outputPath = path.join(outputPath, category.toLowerCase() + '.js');
        build(state, function(data) {
          data.source = removeLicenseTag(data.source);
          buildCallback(data);
        });
      });
    }
    if (callback) {
      callback({ 'outputPath': fs.realpathSync(outputPath) });
    }
  }

  /**
   * Compiles template files based on the provided build state extending
   * `_.templates` with precompiled templates named after each file's basename.
   *
   * @private
   * @param {Object} state The build state object.
   * @returns {string} Returns the compiled source.
   */
  function buildTemplate(state) {
    var glob = require('glob'),
        moduleId = state.moduleId || 'lodash',
        pattern = state.templatePattern,
        settings = state.templateSettings;

    pattern || (pattern = path.join(cwd, '*.jst'));

    var source = [
      ';(function() {',
      '  var undefined;',
      '',
      '  var objectTypes = {',
      "    'function': true,",
      "    'object': true",
      '  };',
      '',
      '  var root = (objectTypes[typeof window] && window) || this;',
      '',
      '  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;',
      '',
      '  var freeGlobal = objectTypes[typeof global] && global;',
      '  if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {',
      '    root = freeGlobal;',
      '  }',
      '',
      '  var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;',
      '',
      '  var moduleExports = freeModule && freeModule.exports === freeExports && freeExports;',
      '',
      '  var _ = root._ || {};',
      ''
    ];

    glob(pattern, { 'sync': true }, function(exception, filePaths) {
      if (exception) {
        throw exception;
      }
      var basePath = (path.dirname(pattern) + path.sep).replace(RegExp('(^|' + path.sepEscaped + ')\\*\\*.*$'),  '$1'),
          insertAt = source.length,
          templates = createMap();

      filePaths.forEach(function(filePath) {
        var text = fs.readFileSync(filePath, 'utf8'),
            precompiled = cleanupCompiled(getFunctionSource(_.template(text, null, settings), 2));

        var index = -1,
            object = templates;

        // glob uses *nix path separators even on Windows
        // https://github.com/isaacs/node-glob#windows
        var props = filePath.slice(basePath.length).replace(/\..*$/, '').split('/'),
            length = props.length - 1;

        while (++index < length) {
          var key = props[index];
          if (!object[key]) {
            object[key] = createMap();
          }
          object = object[key];
        }
        // add template assignment to `source`
        source.push('  templates' + props.map(function(prop) {
          return "['" + prop.replace(/['\n\r\t]/g, '\\$&') + "']";
        }).join('') + ' = ' + precompiled + ';', '');
      });

      // add the initial `_.templates` object to `source`
      source.splice(insertAt, 0, '  var templates = ' +
        JSON.stringify(templates, null, 4)
          .replace(/^ *}$/m, '  $&')
          .replace(/'/g, "\\'")
          .replace(/([^\\])"/g, "$1'") +
        ';', ''
      );
    });

    source.push(
      "  if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {",
      "    define(['" + moduleId + "'], function(lodash) {",
      '      _ = lodash;',
      '      lodash.templates = lodash.extend(lodash.templates || {}, templates);',
      '    });',
      '  } else if (freeExports && freeModule) {',
      '    try {',
      "      _ = require('" + moduleId + "');",
      '    } catch(e) { }',
      '',
      '    if (moduleExports) {',
      '      (freeModule.exports = templates).templates = templates;',
      '    } else {',
      '      freeExports.templates = templates;',
      '    }',
      '  } else if (_) {',
      '    _.templates = _.extend(_.templates || {}, templates);',
      '  }',
      '}.call(this));'
    );

    return source.join('\n');
  }

  /**
   * Capitalizes a given string.
   *
   * @private
   * @param {string} string The string to capitalize.
   * @returns {string} Returns the capitalized string.
   */
  function capitalize(string) {
    return string[0].toUpperCase() + string.slice(1);
  }

  /**
   * Removes unnecessary semicolons and whitespace from compiled code.
   *
   * @private
   * @param {string} source The source to process.
   * @returns {string} Returns the modified source.
   */
  function cleanupCompiled(source) {
    return stringFree(source, function(source) {
      return source
        .replace(/\b(function) *(\()/g, '$1$2')
        .replace(/([{}]) *;/g, '$1');
    });
  }

  /**
   * Removes unnecessary comments, and whitespace.
   *
   * @private
   * @param {string} source The source to process.
   * @returns {string} Returns the modified source.
   */
  function cleanupSource(source) {
    return stringFree(source, function(source) {
      return source
        // consolidate consecutive horizontal rule comment separators
        .replace(/(?:\s*\/\*-+\*\/\s*){2,}/g, function(separators) {
          return separators.match(/^\s*/)[0] + separators.slice(separators.lastIndexOf('/*'));
        })
        // remove unneeded single line comments
        .replace(/(\{\s*)?(\n *\/\/.*)(\s*\})/g, function(match, prelude, comment, postlude) {
          return (!prelude && postlude) ? postlude : match;
        })
        // remove unneeded horizontal rule comment separators
        .replace(/(\{\n)\s*\/\*-+\*\/\n|^ *\/\*-+\*\/\n(\s*\})/gm, '$1$2')
        // remove lines with just spaces and semicolons
        .replace(/^ *;\n/gm, '')
        // remove trailing spaces from lines
        .replace(/ *$/gm, '')
        // consolidate multiple newlines
        .replace(/\n{3,}/g, '\n\n')
        // remove leading empty lines
        .replace(/^ *\n+/, '')
        // add trailing newline
        .trimRight() + '\n';
    });
  }

  /**
   * Creates a map object. If a `properties` object is provided its own
   * enumerable properties are assigned to the created object.
   *
   * @private
   * @param {Object} [properties] The properties to assign to the object.
   * @returns {Object} Returns the new object.
   */
  function createMap(properties) {
    return _.assign(create(null), properties);
  }

  /**
   * The default callback used for `build` invocations.
   *
   * @private
   * @param {Object} data The data for the given build.
   *  gzip - The gzipped output of the built source
   *  outputPath - The path where the built source is to be written
   *  source - The built source output
   *  sourceMap - The source map output
   */
  function defaultBuildCallback(data) {
    var outputPath = data.outputPath,
        sourceMap = data.sourceMap;

    if (outputPath) {
      fs.writeFileSync(outputPath, data.source, 'utf8');
      if (sourceMap) {
        fs.writeFileSync(path.join(path.dirname(outputPath), path.basename(outputPath, '.js') + '.map'), sourceMap, 'utf8');
      }
    }
  }

  /**
   * Writes the help message to standard output.
   *
   * @private
   */
  function displayHelp() {
    console.log([
      'Usage:',
      '  lodash [commands] [options]',
      '',
      'Commands:',
      '',
      '  backbone     Build with only functions required by Backbone',
      '  compat       Build with support for old & new environments (default)',
      '  legacy       Build tailored for older environments without ES5 support',
      '  mobile       Build without function compilation & bug fixes for old browsers',
      '  modern       Build tailored for newer environments with ES5 support',
      '  strict       Build with ES5 strict mode enabled',
      '  underscore   Build tailored for projects already using Underscore',
      '  modularize   Splits Lo-Dash into modules',
      '',
      '  include=..   Comma separated function/category names to include in the build',
      '',
      '  minus=..     Comma separated function/category names to remove from the build',
      '',
      '  plus=..      Comma separated function/category names to add to the build',
      '',
      '  category=..  Comma separated categories of functions to include in the build',
      '               (i.e. “arrays”, “chaining”, “collections”, “functions”,',
      '               “objects”, & “utilities”)',
      '',
      '  exports=..   Comma separated names of ways to export the `lodash` function.',
      '               (i.e. “amd”, “commonjs”, “es6”, “global”, “node”, “npm”, & “none”)',
      '',
      '  iife=..      Code to replace the IIFE that wraps Lo-Dash',
      '               (e.g. `lodash iife="!function(){%output%}()"`)',
      '',
      '  template=..  File path pattern used to match template files to precompile',
      '               (e.g. `lodash template=./*.jst`)',
      '',
      '  settings=..  Template settings used when precompiling templates',
      '               (e.g. `lodash settings="{interpolate:/{{([\\s\\S]+?)}}/g}"`)',
      '',
      '  moduleId=..  The AMD module ID for Lo-Dash',
      '',
      '  All commands except `backbone`, `legacy`, `mobile`, `modern`, & `underscore`',
      '  may be combined.',
      '',
      '  The `exports` values “es6” & “npm” may only be used in conjunction with',
      '  the `modularize` command. The “es6” `exports` option is experimental & may',
      '  be subject to change.',
      '',
      '  Unless specified by `-o` or `--output` all files created are saved to the',
      '  current working directory.',
      '',
      'Options:',
      '',
      '  -c, --stdout      Write output to standard output',
      '  -d, --debug       Write only the non-minified development output',
      '  -h, --help        Display help information',
      '  -m, --minify      Write only the minified production output',
      '  -o, --output      Write output to a given path/filename',
      '  -p, --source-map  Generate a source map using an optional source map URL',
      '  -s, --silent      Skip status updates normally logged to the console',
      '  -V, --version     Output current version of Lo-Dash',
      ''
    ].join('\n'));
  }

  /**
   * Gets the aliases associated with a given function name.
   *
   * @private
   * @param {string} funcName The name of the function to get aliases for.
   * @param {Object} [depMap] The dependency map used to validate aliases.
   * @returns {Array} Returns an array of aliases.
   */
  function getAliases(funcName, depMap) {
    var aliases = hasOwnProperty.call(realToAliasMap, funcName) && realToAliasMap[funcName];
    depMap || (depMap = funcDependencyMap);
    return _.reject(aliases, function(funcName) {
      return hasOwnProperty.call(depMap, funcName);
    });
  }

  /**
   * Gets the category of the given identifier.
   *
   * @private
   * @param {string} identifier The identifier to query.
   * @param {Object} [depMap] The dependency map used to resolve the identifier.
   * @returns {string} Returns the identifier's category.
   */
  function getCategory(identifier, depMap) {
    identifier = getRealName(identifier, depMap);
    return _.findKey(categoryMap, function(identifiers) {
      return _.contains(identifiers, identifier);
    }) || '';
  }

  /**
   * Gets the `baseCreate` fork from `source`.
   *
   * @private
   * @param {string} source The source to inspect.
   * @returns {string} Returns the fork.
   */
  function getBaseCreateFork(source) {
    return _.result(source.match(/(?:\s*\/\/.*)*\n( *)if *\((?:!nativeCreate)[\s\S]+?\n *}\(\)\);\n\1}/), 0) || '';
  }


  function getDepPath(dep, fromPath, depMap) {
    var sep = '/',
        toPath = getPath(dep, depMap),
        relative = path.relative(fromPath || '', toPath).replace(RegExp(path.sepEscaped, 'g'), sep);

    if (relative.charAt(0) != '.') {
      relative = '.' + (relative ? sep + relative : '');
    }
    return relative + sep + dep;
  }

  function getDepPaths(dependencies, fromPath, depMap) {
    return dependencies.map(function(dep) {
      return getDepPath(dep, fromPath, depMap);
    });
  }

  /**
   * Gets an array of depenants for the given function name(s).
   *
   * @private
   * @param {string} funcName A function name or array of function names.
   * @param {Object} [depMap] The dependency map used to look up dependants.
   * @param- {Array} [stackA=[]] Internally used track queried function names.
   * @returns {Array} Returns an array of function dependants.
   */
  function getDependants(funcName, depMap, stack) {
    var funcNames = _.isArray(funcName) ? funcName : [funcName];
    depMap || (depMap = funcDependencyMap);
    stack || (stack = []);

    // iterate over the dependency map, adding names of functions that have `funcName` as a dependency
    return _.uniq(_.transform(depMap, function(result, deps, otherName) {
      if (!_.contains(stack, otherName) && _.some(funcNames, function(funcName) {
            return _.contains(deps, funcName);
          })) {
        stack.push(otherName);
        result.push(otherName);
        push.apply(result, getDependants(otherName, depMap, stack));
      }
    }, []));
  }

  /**
   * Gets an array of dependencies for a given function name. If an array of
   * dependencies is provided, it will return an array containing the given
   * dependencies plus any additional detected sub-dependencies.
   *
   * @private
   * @param {string|string[]} funcName A function name or array of dependencies to query.
   * @param {Object} [depMap] The dependency map used to look up dependants.
   * @param {boolean} [isShallow=false] A flag to indicate getting only the immediate dependencies.
   * @param- {Array} [stackA=[]] Internally used track queried function names.
   * @returns {Array} Returns an array of function dependencies.
   */
  function getDependencies(funcName, depMap, isShallow, stack) {
    // juggle arguments
    if (typeof depMap != 'object' && typeof isShallow != 'boolean') {
      isShallow = depMap;
      depMap = null;
    }
    // allow working with ES5 Array methods
    if (typeof isShallow != 'boolean' && isShallow != null) {
      isShallow = false;
      stack = null;
    }
    depMap || (depMap = funcDependencyMap);

    var deps = _.isArray(funcName)
      ? funcName
      : (hasOwnProperty.call(depMap, funcName) && depMap[funcName]);

    if (!_.size(deps)) {
      return [];
    }
    if (isShallow) {
      return deps.slice();
    }
    stack || (stack = []);

    // recursively accumulate the dependencies of the `funcName` function, and
    // the dependencies of its dependencies, and so on
    return _.uniq(_.transform(deps, function(result, otherName) {
      if (!_.contains(stack, otherName)) {
        stack.push(otherName);
        push.apply(result, getDependencies(otherName, depMap, isShallow, stack).concat(otherName));
      }
    }));
  }

  /**
   * Gets the formatted source of the given function.
   *
   * @private
   * @param {Function} func The function to process.
   * @param {number|string} [indent=0] The level to indent.
   * @returns {string} Returns the formatted source.
   */
  function getFunctionSource(func, indent) {
    indent || (indent = '');
    if (typeof indent == 'number') {
      indent = Array(indent + 1).join(' ');
    }
    // format leading whitespace
    var source = func.source || (func + '');
    return source.replace(/\n(?:.*)/g, function(match, index) {
      match = match.slice(1);
      return (
        '\n' + indent +
        (match == '}' && !_.contains(source, '}', index + 2) ? '' : '  ')
      ) + match;
    });
  }

  /**
   * Gets the indent of the given function.
   *
   * @private
   * @param {Function} func The function to process.
   * @returns {string} Returns the indent.
   */
  function getIndent(func) {
    return /^ *(?=\S)/m.exec(func.source || func)[0];
  }

  /**
   * Gets the `_.isArguments` fork from `source`.
   *
   * @private
   * @param {string} source The source to inspect.
   * @returns {string} Returns the fork.
   */
  function getIsArgumentsFork(source) {
    return _.result(source.match(/(?:\s*\/\/.*)*\n( *)if *\((?:!support\.argsClass|!isArguments)[\s\S]+?\n *};\n\1}/), 0) || '';
  }

  /**
   * Gets the `_.isArray` fork from `source`.
   *
   * @private
   * @param {string} source The source to inspect.
   * @returns {string} Returns the fork.
   */
  function getIsArrayFork(source) {
    return matchFunction(source, 'isArray')
      .replace(/^[\s\S]+?(?=\|\|)/, '')
      .replace(/[;\s]+$/, '');
  }

  /**
   * Gets the `_.isElement` fork from `source`.
   *
   * @private
   * @param {string} source The source to inspect.
   * @returns {string} Returns the fork.
   */
  function getIsElementFork(source) {
    return _.result(source.match(/(?:\s*\/\/.*)*\n( *)if *\(!support\.dom[\s\S]+?\n *};\n\1}/), 0) || '';
  }

  /**
   * Gets the `_.isFunction` fork from `source`.
   *
   * @private
   * @param {string} source The source to inspect.
   * @returns {string} Returns the fork.
   */
  function getIsFunctionFork(source) {
    return _.result(source.match(/(?:\s*\/\/.*)*\n( *)if *\(isFunction\(\/x\/[\s\S]+?\n *};\n\1}/), 0) || '';
  }

  /**
   * Gets the Lo-Dash method assignments snippet from `source`.
   *
   * @private
   * @param {string} source The source to inspect.
   * @returns {string} Returns the method assignments snippet.
   */
  function getMethodAssignments(source) {
    return _.result(source.match(/\n\n(?:\s*\/\/.*)*\s*lodash\.[$\w]+\s*=[\s\S]+lodash\.[$\w]+\s=.+/), 0) || '';
  }

  /**
   * Gets the names of identifiers in `source` that belong to the given category.
   *
   * @private
   * @param {string} category The category to filter by.
   * @returns {Array} Returns a new array of names.
   */
  function getNamesByCategory(category) {
    return categoryMap[category] || [];
  }

  /**
   * Gets the `_.isArray` fork from `source`.
   *
   * @private
   * @param {string} source The source to inspect.
   * @returns {string} Returns the fork.
   */
  function getNowFork(source) {
    return matchFunction(source, 'now')
      .replace(/^[\s\S]+?(?=\|\|)/, '')
      .replace(/[;\s]+$/, '');
  }

  function getPath(identifier, depMap) {
    return topLevel[identifier]
      ? ''
      : (getCategory(identifier, depMap) || 'internals').toLowerCase();
  }

  /**
   * Gets the real name, not alias, of a given function name.
   *
   * @private
   * @param {string} funcName The name of the function to resolve.
   * @param {Object} [depMap] The dependency map used to validate the real name.
   * @returns {string} Returns the real function name.
   */
  function getRealName(funcName, depMap) {
    return (
      !hasOwnProperty.call(depMap || funcDependencyMap, funcName) &&
      hasOwnProperty.call(aliasToRealMap, funcName) &&
      aliasToRealMap[funcName]
    ) || funcName;
  }

  /**
   * Gets the `setBindData` fork from `source`.
   *
   * @private
   * @param {string} source The source to inspect.
   * @returns {string} Returns the fork.
   */
  function getSetBindDataFork(source) {
    return _.result(matchFunction(source, 'setBindData').match(/!defineProperty[^:]+:\s*/), 0) || '';
  }

  /**
   * Creates a sorted array of all variables defined outside of Lo-Dash functions.
   *
   * @private
   * @param {string} source The source to process.
   * @param {boolean} [isShallow=false] A flag to indicate looking for varaibles one closure deep.
   * @returns {Array} Returns a new array of variable names.
   */
  function getVars(source, isShallow) {
    var indentA = isShallow ? ' {2}' : ' {2,4}',
        indentB = isShallow ? ' {6}' : ' {6,8}';

    var result = _.reduce([
      // match a varaible at the start of a declaration list
      indentA + 'var ([$\\w]+) *=.+?,\\n(?= *[$\\w]+ *=)',
      // match a variable declaration in a declaration list
      indentB + '([$\\w]+) *=.+?[,;]\\n',
      // match a variable that is not part of a declaration list
      '(' + indentA + ')var ([$\\w]+) *(?:|= *(?:.+?(?:&&\\n[\\s\\S]+?)?|(?:[($\\w]+\\(|[{[(]\\n)[\\s\\S]+?\\n\\1[^\\n ]+?));\\n'
    ], function(result, reSource) {
      source = source.replace(RegExp('^' + reSource, 'gm'), function(match, indent, varName) {
        if (typeof varName == 'number') {
          varName = indent;
        }
        result.push(varName);
        return '';
      });
      return result;
    }, []);

    // remove duplicates and function names
    return _.difference(_.uniq(result), allFuncs).sort();
  }

  /**
   * Determines if a variable, of the given variable name, is used in `source`.
   *
   * @private
   * @param {string} source The source to process.
   * @param {string} varName The name of the variable.
   * @param {boolean} [isShallow=false] A flag to indicate looking for varaibles one closure deep.
   * @returns {boolean} Returns `true` if the variable is used, else `false`.
   */
  function isVarUsed(source, varName, isShallow) {
    var match = matchVar(source, varName, isShallow);
    if (!match) {
      return false;
    }
    // remove the variable assignment from the source
    source = source.replace(match, '');
    return RegExp('[^.$"\'\\w]' + varName + '\\b(?!\\s*=)').test(source);
  }

  /**
   * Searches `source` for a `funcName` function declaration, expression, or
   * assignment and returns the matched snippet.
   *
   * @private
   * @param {string} source The source to inspect.
   * @param {string} funcName The name of the function to match.
   * @param {boolean} [leadingComments] A flag to indicate including leading comments.
   * @returns {string} Returns the matched function snippet.
   */
  function matchFunction(source, funcName, leadingComments) {
    var result = _.reduce([
      // match variable declarations using `createAggregator`, `createIterator` and `template`
      '( *)var ' + funcName + ' *=.*?(?:create[A-Z][a-z]+|template)\\((?:.+|[\\s\\S]+?\\n\\3}?)\\);\\n',
      // match a function declaration
      '( *)function ' + funcName + '\\b[\\s\\S]+?\\n\\3}\\n',
      // match a variable declaration with function expression
      '( *)var ' + funcName + ' *=.*?function\\(.+?\{\\n[\\s\\S]+?\\n\\3}(?:\\(\\)\\))?;\\n',
      // match a simple variable declaration
      ' *var ' + funcName + ' *=.+?;\\n'
    ], function(result, reSource) {
      return result || (result = source.match(RegExp(
        '(' + multilineComment + ')' +
        '(' + reSource + ')'
      ))) && result.slice(1, 3);
    }, null);

    return result && (
           /@type +Function\b/i.test(result[0]) ||
           /(?:function(?:\s+[$\w]+)?\b|create[A-Z][a-z]+|template)\(/.test(result[1]))
      ? (leadingComments ? result[0] : '') + result[1]
      : '';
  }

  /**
   * Searches `source` for a Lo-Dash property, of the given property name, and
   * returns the matched snippet.
   *
   * @private
   * @param {string} source The source to inspect.
   * @param {string} propName The name of the property to match.
   * @param {boolean} [leadingComments] A flag to indicate including leading comments.
   * @returns {string} Returns the matched property snippet.
   */
  function matchProp(source, propName, leadingComments) {
    return _.result(source.match(RegExp(
      (leadingComments ? multilineComment : '\\n') +
      '(?: {2,4}var ' + propName + '\\b.+|(?: *|.*?=\\s*)lodash\\._?' + propName + '\\s*)=[\\s\\S]+?' +
      '(?:\\(function[\\s\\S]+?\\([^)]*\\)\\);\\n(?=\\n)|' +
      '[;}]\\n(?=\\n(?!\\s*\\(func)))'
    )), 0) || '';
  }

  /**
   * Searches `source` for a `varName` variable assignment and returns
   * the matched snippet.
   *
   * @private
   * @param {string} source The source to inspect.
   * @param {string} varName The name of the variable to match.
   * @param {boolean} [isShallow=false] A flag to indicate looking for varaibles one closure deep.
   * @returns {string} Returns the matched variable snippet.
   */
  function matchVar(source, varName, isShallow) {
    var indentA = isShallow ? ' {2}' : ' {2,4}',
        indentB = isShallow ? ' {6}' : ' {6,8}';

    var reSources = [
      // match a varaible at the start of a declaration list
      indentA + 'var ' + varName + ' *=.+?,\\n(?= *[$\\w]+ *=)',
      // match a variable declaration in a declaration list
      indentB + varName + ' *=.+?[,;]\\n',
      // match a variable that is not part of a declaration list
      '(' + indentA + ')var ' + varName + ' *(?:|= *(?:.+?(?:&&\\n[\\s\\S]+?)?|(?:[($\\w]+\\(|[{[(]\\n)[\\s\\S]+?\\n\\1[^\\n ]+?));\\n'
    ];

    // match complex variable assignments
    if (varName != 'freeGlobal' && _.contains(complexVars, varName)) {
      reSources = [
        indentA + 'var '  + varName + ' *=[\\s\\S]+?' +
        '(?:\\(function[\\s\\S]+?\\([^)]*\\)\\);\\n(?=\\n)|' +
        '[;}]\\n(?=\\n(?!\\s*\\(func)))'
      ];
    }
    return _.reduce(reSources, function(result, reSource) {
      return result || (result = source.match(RegExp(
        '^' + reSource
      , 'm'))) && result[0];
    }, null) || '';
  }

  /**
   * Converts a comma separated option value into an array.
   *
   * @private
   * @param {string} name The name of the option to inspect.
   * @param {string} string The options string.
   * @returns {Array} Returns the new converted array.
   */
  function optionToArray(name, string) {
    return _.compact(_.isArray(string)
      ? string
      : _.invoke((optionToValue(name, string) || '').split(/, */), 'trim')
    );
  }

  /**
   * Converts a comma separated option value into an array of function names.
   *
   * @private
   * @param {string} name The name of the option to inspect.
   * @param {string} string The options string.
   * @param {Object} [depMap] The dependency map used to resolve real names.
   * @returns {Array} Returns the new converted array.
   */
  function optionToFuncsArray(name, string, depMap) {
    depMap || (depMap = funcDependencyMap);
    return optionToArray(name, string).map(function(identifier) {
      // convert aliases to real function names
      return getRealName(identifier, depMap);
    });
  }

  /**
   * Extracts the option value from an option string.
   *
   * @private
   * @param {string} name The name of the option to inspect.
   * @param {string} string The options string.
   * @returns {string|undefined} Returns the option value, else `undefined`.
   */
  function optionToValue(name, string) {
    var result = (result = string.match(RegExp('^' + name + '=([\\s\\S]+)$'))) && result[1].trim();
    return result || undefined;
  }

  /**
   * Removes all Lo-Dash assignments from `source`.
   *
   * @private
   * @param {string} source The source to inspect.
   * @returns {string} Returns the modified source.
   */
  function removeAssignments(source) {
    // remove method and intermediate assignments
    source = removeMethodAssignments(source);
    source = source.replace(/(=\s*)lodash\.[$\w]+\s*=\s*/g, '$1');
    return source;
  }

  /**
   * Removes the `baseCreate` fork from `source`.
   *
   * @private
   * @param {string} source The source to process.
   * @returns {string} Returns the modified source.
   */
  function removeBaseCreateFork(source) {
    return source.replace(getBaseCreateFork(source), '');
  }

  /**
   * Removes support for Lo-Dash wrapper chaining in `source`.
   *
   * @private
   * @param {string} source The source to process.
   * @returns {string} Returns the modified source.
   */
  function removeChaining(source) {
    source = removeMixinCalls(source);
    source = removeSpliceObjectsFix(source);

    // remove all `lodash.prototype` additions
    source = source
      .replace(/(?:\s*\/\/.*)*\n( *)forOwn\(lodash,[\s\S]+?\n\1}.+/g, '')
      .replace(/(?:\s*\/\/.*)*\n( *)(?:baseEach|forEach)\(\['[\s\S]+?\n\1}.+/g, '')
      .replace(/(?:\s*\/\/.*)*\n *lodash\.prototype\.[\s\S]+?;/g, '');

    // replace `lodash` with a simpler version
    source = replaceFunction(source, 'lodash', [
      'function lodash() {',
      '  // no operation performed',
      '}'
    ].join('\n'));

    // replace `lodashWrapper` with `lodash` in `_.mixin`
    source = source.replace(matchFunction(source, 'mixin'), function(match) {
      return match.replace(/\blodashWrapper\b/, 'lodash');
    });

    return source;
  }

  /**
   * Removes all comments from `source`.
   *
   * @private
   * @param {string} source The source to process.
   * @returns {string} Returns the modified source.
   */
  function removeComments(source) {
    return source.replace(/^ *(?:\/\*[^*]*\*+(?:[^\/][^*]*\*+)*\/|\/\/.+)\n/gm, '');
  }

  /**
   * Removes ES5 specific optimizations from `source`.
   *
   * @private
   * @param {string} source The source to process.
   * @returns {string} Returns the modified source.
   */
  function removeEsOptimization(source) {
    source = removeSupportProp(source, 'funcDecomp');
    source = removeSupportProp(source, 'funcNames');

    // remove `__bindData__` logic and `setBindData` function calls
    _.each(['baseBind', 'baseCreateCallback', 'baseCreateWrapper', 'createWrapper'], function(funcName) {
      source = source.replace(matchFunction(source, funcName), function(match) {
        return match
          .replace(/(?:\s*\/\/.*)*\n( *)var bindData *=[\s\S]+?\n\1}/, '')
          .replace(/(?:\s*\/\/.*)*\n( *)if *\(bindData[\s\S]+?\n\1}/, '')
          .replace(/(?:\s*\/\/.*)*\n.+?setBindData.+/, '')
      });
    });

    return source;
  }

  /**
   * Removes all references to `identifier` from `createIterator` in `source`.
   *
   * @private
   * @param {string} source The source to process.
   * @param {string} identifier The name of the variable or property to remove.
   * @returns {string} Returns the modified source.
   */
  function removeFromCreateIterator(source, identifier) {
    var snippet = matchFunction(source, 'createIterator');
    if (!snippet) {
      return source;
    }
    // remove data object property assignment
    var modified = snippet.replace(RegExp("^(?: *\\/\\/.*\\n)* *([$\\w]+)\\." + identifier + " *= *(.+\\n+)", 'm'), function(match, object, postlude) {
      return RegExp('\\b' + object + '\\.').test(postlude) ? postlude : '\n';
    });

    source = source.replace(snippet, function() {
      return modified;
    });

    // clip to the `factory` assignment
    snippet = modified.match(/Function\([\s\S]+$/)[0];

    // remove `factory` arguments
    source = source.replace(snippet, function(match) {
      return match
        .replace(RegExp("[^\\n(,']*?\\b" + identifier + "\\b[^\\n),']*(?:, *)?", 'g'), ' ')
        .replace(/, *(?=',)/, '')
        .replace(/,(?=\s*\))/, '');
    });

    return source;
  }

  /**
   * Removes all references to `identifier` from `getObject` in `source`.
   *
   * @private
   * @param {string} source The source to process.
   * @param {string} identifier The name of the property to remove.
   * @returns {string} Returns the modified source.
   */
  function removeFromGetObject(source, identifier) {
    return source.replace(matchFunction(source, 'getObject'), function(match) {
      // remove object property assignments
      return match
        .replace(RegExp("^(?: *\\/\\/.*\\n)* *'" + identifier + "':.+\\n+", 'm'), '')
        .replace(/,(?=\s*})/, '');
    });
  }

  /**
   * Removes all references to `identifier` from `releaseObject` in `source`.
   *
   * @private
   * @param {string} source The source to process.
   * @param {string} identifier The name of the property to remove.
   * @returns {string} Returns the modified source.
   */
  function removeFromReleaseObject(source, identifier) {
    return source.replace(matchFunction(source, 'releaseObject'), function(match) {
      // remove object property assignments
      return match.replace(RegExp("(?:(^ *)| *)([$\\w]+)\\." + identifier + " *= *(.+\\n+)", 'm'), function(match, indent, object, postlude) {
        return (indent || '') + RegExp('\\b' + object + '\\.').test(postlude) ? postlude : '';
      });
    });
  }

  /**
   * Removes the `funcName` function declaration, expression, or assignment and
   * associated code from `source`.
   *
   * @private
   * @param {string} source The source to process.
   * @param {string} funcName The name of the function to remove.
   * @returns {string} Returns the modified source.
   */
  function removeFunction(source, funcName) {
    var snippet;

    // defer to specialized removal functions
    if (funcName == 'runInContext') {
      return removeRunInContext(source, funcName);
    }
    // remove function
    if ((snippet = matchFunction(source, funcName, true))) {
      source = source.replace(snippet, '');
    }
    return source;
  }

  /**
   * Removes all references to `getIndexOf` from `source`.
   *
   * @private
   * @param {string} source The source to process.
   * @returns {string} Returns the modified source.
   */
  function removeGetIndexOf(source) {
    source = removeFunction(source, 'getIndexOf');

    // replace all `getIndexOf` calls with `baseIndexOf`
    _.each(['baseDifference', 'baseUniq', 'contains', 'intersection'], function(funcName) {
      source = source.replace(matchFunction(source, funcName), function(match) {
        return match.replace(/\bgetIndexOf\(\)/g, 'baseIndexOf');
      });
    });

    // simplify `isLarge` assignments
    _.each(['baseDifference', 'baseUniq'], function(funcName) {
      source = source.replace(matchFunction(source, funcName), function(match) {
        return match.replace(/\b(largeArraySize).+?baseIndexOf\b/g, '$1');
      });
    });

    return source;
  }

  /**
   * Removes the `_.isArguments` fork from `source`.
   *
   * @private
   * @param {string} source The source to process.
   * @returns {string} Returns the modified source.
   */
  function removeIsArgumentsFork(source) {
    return source.replace(getIsArgumentsFork(source), '');
  }

  /**
   * Removes the `_.isArray` fork from `source`.
   *
   * @private
   * @param {string} source The source to process.
   * @returns {string} Returns the modified source.
   */
  function removeIsArrayFork(source) {
    return source.replace(getIsArrayFork(source), '');
  }

  /**
   * Removes the `_.isElement` fork from `source`.
   *
   * @private
   * @param {string} source The source to process.
   * @returns {string} Returns the modified source.
   */
  function removeIsElementFork(source) {
    return source.replace(getIsElementFork(source), '');
  }

  /**
   * Removes the `_.isFunction` fork from `source`.
   *
   * @private
   * @param {string} source The source to process.
   * @returns {string} Returns the modified source.
   */
  function removeIsFunctionFork(source) {
    return source.replace(getIsFunctionFork(source), '');
  }

  /**
   * Removes the `@license` tag from the copyright header so minifiers and
   * build optimizers may strip them.
   *
   * @private
   * @param {string} source The source to inspect.
   * @returns {string} Returns the modified source.
   */
  function removeLicenseTag(source) {
    return source.replace(/^ \* @license\n/m, '');
  }

  /**
   * Removes the Lo-Dash method assignments snippet from `source`.
   *
   * @private
   * @param {string} source The source to inspect.
   * @returns {string} Returns the modified source.
   */
  function removeMethodAssignments(source) {
    return source.replace(getMethodAssignments(source), '');
  }

  /**
   * Removes all `_.mixin` calls from `source`.
   *
   * @private
   * @param {string} source The source to inspect.
   * @returns {string} Returns the modified source.
   */
  function removeMixinCalls(source) {
    return source.replace(/(?:\s*\/\/.*)*\n( *)mixin\((?:.+?|[\s\S]+?\1(?:}.+?)?)\);/g, '');
  }

  /**
   * Removes the `_.now` fork from `source`.
   *
   * @private
   * @param {string} source The source to process.
   * @returns {string} Returns the modified source.
   */
  function removeNowFork(source) {
    return source.replace(getNowFork(source), '');
  }

  /**
   * Removes a Lo-Dash property, of the given property name, from `source`.
   *
   * @private
   * @param {string} source The source to process.
   * @param {string} propName The name of the property to remove.
   * @returns {string} Returns the modified source.
   */
  function removeProp(source, propName) {
    return source.replace(matchProp(source, propName, true), '');
  }

  /**
   * Removes all pseudo private Lo-Dash properties from `source`.
   *
   * @private
   * @param {string} source The source to process.
   * @returns {string} Returns the modified source.
   */
  function removePseudoPrivates(source) {
    return source.replace(/^(?: *\/\/.*\s*)* *lodash\._[$\w]+ *=[\s\S]+?;\n/gm, '');
  }

  /**
   * Removes all `runInContext` references from `source`.
   *
   * @private
   * @param {string} source The source to process.
   * @returns {string} Returns the modified source.
   */
  function removeRunInContext(source) {
    // remove local timer variables
    source = removeVar(source, 'clearTimeout');
    source = removeVar(source, 'setTimeout');

    // replace reference in `reThis` assignment
    source = source.replace(/\btest\(runInContext\)/, 'test(function() { return this; })');

    // remove assignment
    source = source.replace(/^(?: *\/\/.*\s*)* *lodash\.runInContext *=[\s\S]+?;\n/m, '');

    // remove function scaffolding, leaving most of its content
    source = source.replace(matchFunction(source, 'runInContext', true), function(match) {
      match = replaceIndent(match, 2, 1);
      return match.replace(/^[\s\S]+?function runInContext[\s\S]+?context *= *context.+| *return lodash[\s\S]+$/g, '');
    });

    // cleanup adjusted source
    return source
      .replace(/\bcontext\b/g, 'root')
      .replace(/(?:\n +\/\*[^*]*\*+(?:[^\/][^*]*\*+)*\/)?\n *var Array *=[\s\S]+?;\n/, '')
      .replace(/(return *|= *)_([;)])/g, '$1lodash$2')
      .replace(/^(?: *\/\/.*\s*)* *var _ *= *runInContext\b.+\n+/m, '');
  }

  /**
   * Removes the `support.spliceObjects` fix from the `Array` function mixins
   * snippet of `source`.
   *
   * @private
   * @param {string} source The source to inspect.
   * @returns {string} Returns the modified source.
   */
  function removeSpliceObjectsFix(source) {
    return source.replace(/(?:\s*\/\/.*)*\n( *)if *\(!support\.spliceObjects[\s\S]+?(?:\{\s*}|\n\1})/, '');
  }

  /**
   * Removes all strings from `source`.
   *
   * @private
   * @param {string} source The source to process.
   * @returns {string} Returns the modified source.
   */
  function removeStrings(source) {
    return source.replace(reStrings, '');
  }

  /**
   * Removes all `support.argsClass` references from `source`.
   *
   * @private
   * @param {string} source The source to process.
   * @returns {string} Returns the modified source.
   */
  function removeSupportArgsClass(source) {
    source = removeSupportProp(source, 'argsClass');

    // replace `support.argsClass` in the `_.isArguments` fork
    source = source.replace(getIsArgumentsFork(source), function(match) {
      return match.replace(/!support\.argsClass/g, '!isArguments(arguments)');
    });

    // remove `support.argsClass` from `_.isEmpty`
    source = source.replace(matchFunction(source, 'isEmpty'), function(match) {
      return match.replace(/\s*\(support\.argsClass\s*\?([^:]+):.+?\)\)/g, '$1');
    });

    // remove `support.argsClass` from `_.isPlainObject`
    _.each(['shimIsPlainObject', 'isPlainObject'], function(funcName) {
      source = source.replace(matchFunction(source, funcName), function(match) {
        return match.replace(/\s*\|\|\s*\(!support\.argsClass[\s\S]+?\)\)/, '');
      });
    });

    return source;
  }

  /**
   * Removes all `support.argsObject` references from `source`.
   *
   * @private
   * @param {string} source The source to process.
   * @returns {string} Returns the modified source.
   */
  function removeSupportArgsObject(source) {
    source = removeSupportProp(source, 'argsObject');

    // remove `argsAreObjects` from `baseIsEqual`
    source = source.replace(matchFunction(source, 'baseIsEqual'), function(match) {
      return match.replace(/!support.\argsObject[^:]+:\s*/g, '');
    });

    return source;
  }

  /**
   * Removes all `support.dom` references from `source`.
   *
   * @private
   * @param {string} source The source to process.
   * @returns {string} Returns the modified source.
   */
  function removeSupportDom(source) {
    source = removeSupportProp(source, 'dom');
    source = removeIsElementFork(source);
    return source;
  }

  /**
   * Removes all `support.enumErrorProps` references from `source`.
   *
   * @private
   * @param {string} source The source to process.
   * @returns {string} Returns the modified source.
   */
  function removeSupportEnumErrorProps(source) {
    source = removeSupportProp(source, 'enumErrorProps');

    // remove `support.enumErrorProps` from `iteratorTemplate`
    source = source.replace(matchFunction(source, 'iteratorTemplate'), function(match) {
      return match.replace(/^(?: *\/\/.*\n)* *["'] *(?:<% *)?if *\(support\.enumErrorProps *(?:&&|\))(.+?\}(?:\\n)?["']|[\s\S]+?<% *} *(?:%>|["'])).+/gm, '');
    });

    return source;
  }

  /**
   * Removes all `support.enumPrototypes` references from `source`.
   *
   * @private
   * @param {string} source The source to process.
   * @returns {string} Returns the modified source.
   */
  function removeSupportEnumPrototypes(source) {
    source = removeSupportProp(source, 'enumPrototypes');

    // remove `support.enumPrototypes` from `_.keys`
    source = source.replace(matchFunction(source, 'keys'), function(match) {
      return match
        .replace(/\(support\.enumPrototypes[^)]+\)(?:\s*\|\|\s*)?/, '')
        .replace(/\s*if *\(\s*\)[^}]+}/, '');
    });

    // remove `support.enumPrototypes` from `iteratorTemplate`
    source = source.replace(matchFunction(source, 'iteratorTemplate'), function(match) {
      return match.replace(/^(?: *\/\/.*\n)* *["'] *(?:<% *)?if *\(support\.enumPrototypes *(?:&&|\))(.+?\}(?:\\n)?["']|[\s\S]+?<% *} *(?:%>|["'])).+/gm, '');
    });

    return source;
  }

  /**
   * Removes all `support.nodeClass` references from `source`.
   *
   * @private
   * @param {string} source The source to process.
   * @returns {string} Returns the modified source.
   */
  function removeSupportNodeClass(source) {
    source = removeSupportProp(source, 'nodeClass');

    // remove `support.nodeClass` from `baseClone` and `shimIsPlainObject`
    _.each(['baseClone', 'shimIsPlainObject'], function(funcName) {
      source = source.replace(matchFunction(source, funcName), function(match) {
        return match.replace(/\s*\|\|\s*\(!support\.nodeClass[\s\S]+?\)\)/, '');
      });
    });

    // remove `support.nodeClass` from `baseIsEqual`
    source = source.replace(matchFunction(source, 'baseIsEqual'), function(match) {
      return match.replace(/\s*\|\|\s*\(!support\.nodeClass[\s\S]+?\)\)\)/, '');
    });

    // remove `support.nodeClass` from `_.isElement`
    source = source.replace(matchFunction(source, 'isElement'), function(match) {
      return match.replace(/\(support\.nodeClass\s*\?\s*([^:]+?)\s*:[\s\S]+?\)\)/, '$1');
    });

    return source;
  }

  /**
   * Removes all `support.nonEnumArgs` references from `source`.
   *
   * @private
   * @param {string} source The source to process.
   * @returns {string} Returns the modified source.
   */
  function removeSupportNonEnumArgs(source) {
    source = removeSupportProp(source, 'nonEnumArgs');

    // remove `support.nonEnumArgs` from `_.keys`
    source = source.replace(matchFunction(source, 'keys'), function(match) {
      return match
        .replace(/(?:\s*\|\|\s*)?\(support\.nonEnumArgs[\s\S]+?\)\)/, '')
        .replace(/\s*if *\(\s*\)[^}]+}/, '');
    });

    // remove `support.nonEnumArgs` from `iteratorTemplate`
    source = source.replace(matchFunction(source, 'iteratorTemplate'), function(match) {
      return match.replace(/^(?: *\/\/.*\n)*( *["'] *)<% *if *\(support\.nonEnumArgs[\s\S]+?\1<% *} *%>.+/m, '');
    });

    return source;
  }

  /**
   * Removes all `support.nonEnumShadows` references from `source`.
   *
   * @private
   * @param {string} source The source to process.
   * @returns {string} Returns the modified source.
   */
  function removeSupportNonEnumShadows(source) {
    source = removeFromCreateIterator(source, 'nonEnumProps');
    source = removeFromCreateIterator(source, 'shadowedProps');
    source = removeSupportProp(source, 'nonEnumShadows');

    // remove `support.nonEnumShadows` from `iteratorTemplate`
    source = source.replace(matchFunction(source, 'iteratorTemplate'), function(match) {
      return match.replace(/^(?: *\/\/.*\n)* *["']( *)<% *if *\(support\.nonEnumShadows[\s\S]+?["']\1<% *} *%>.+/m, '');
    });

    return source;
  }

  /**
   * Removes all `support.ownLast` references from `source`.
   *
   * @private
   * @param {string} source The source to process.
   * @returns {string} Returns the modified source.
   */
  function removeSupportOwnLast(source) {
    source = removeSupportProp(source, 'ownLast');

    // remove `support.ownLast` from `shimIsPlainObject`
    source = source.replace(matchFunction(source, 'shimIsPlainObject'), function(match) {
      return match.replace(/(?:\s*\/\/.*)*\n( *)if *\(support\.ownLast[\s\S]+?\n\1}/, '');
    });

    return source;
  }

  /**
   * Removes all `support.spliceObjects` references from `source`.
   *
   * @private
   * @param {string} source The source to process.
   * @returns {string} Returns the modified source.
   */
  function removeSupportSpliceObjects(source) {
    source = removeSupportProp(source, 'spliceObjects');
    source = removeSpliceObjectsFix(source);
    return source;
  }

  /**
   * Removes all `support.unindexedChars` references from `source`.
   *
   * @private
   * @param {string} source The source to process.
   * @returns {string} Returns the modified source.
   */
  function removeSupportUnindexedChars(source) {
    source = removeSupportProp(source, 'unindexedChars');

    // remove `support.unindexedChars` from `_.at` and `baseEach`
    _.each(['at', 'baseEach'], function(funcName) {
      source = source.replace(matchFunction(source, funcName), function(match) {
        return match.replace(/^( *)if *\(support\.unindexedChars[\s\S]+?\n\1}\n/m, '');
      });
    });

    // remove `support.unindexedChars` from `_.forEachRight` and `_.sample`
    _.each(['forEachRight', 'sample'], function(funcName) {
      source = source.replace(matchFunction(source, funcName), function(match) {
        return match.replace(/\s*else if *\(support\.unindexedChars[^}]+}/, '');
      });
    });

    // remove `support.unindexedChars` from `_.toArray`
    source = source.replace(matchFunction(source, 'toArray'), function(match) {
      return match.replace(/(return\b).+?support\.unindexedChars[^:]+:\s*/, '$1 ');
    });

    return source;
  }

  /**
   * Removes a given property from the `support` object in `source`.
   *
   * @private
   * @param {string} source The source to process.
   * @param {string} varName The name of the `support` property to remove.
   * @returns {string} Returns the modified source.
   */
  function removeSupportProp(source, propName) {
    return source.replace(matchProp(source, 'support'), function(match) {
      return match.replace(RegExp(
        multilineComment +
        // match a `try` block
        '(?: *try\\b.+\\n)?' +
        // match the `support` property assignment
        ' *support\\.' + propName + ' *=[\\s\\S]+?;\\n' +
        // match `catch` block
        '(?:( *).+?catch\\b[\\s\\S]+?\\n\\1}\\n)?'
      ), '');
    });
  }

  /**
   * Removes a variable, of the given variable name, from `source`.
   *
   * @private
   * @param {string} source The source to process.
   * @param {string} varName The name of the variable to remove.
   * @returns {string} Returns the modified source.
   */
  function removeVar(source, varName) {
    // simplify complex variable assignments
    if (_.contains(complexVars, varName)) {
      source = source.replace(RegExp(
        '^( *var ' + varName + ') *=[\\s\\S]+?' +
        '(?:\\(function[\\s\\S]+?\\([^)]*\\)\\);(?=\\n\\n)|' +
        '[;}](?=\\n\\n(?!\\s*\\(func)))'
      , 'm'), '$1 = null;')
    }

    _.some([
      function() {
        return removeFunction(source, varName);
      },
      function() {
        // remove a varaible at the start of a declaration list
        return source.replace(RegExp('(var +)' + varName + ' *=.+?,\\n *'), '$1');
      },
      function() {
        // remove a variable declaration in a declaration list
        return source.replace(RegExp(
          '( *(?:var +)?[$\\w]+ *=.+?),\\n *' + varName + ' *=.+?([,;])(?=\\n)'
        ), '$1$2');
      },
      function() {
        // remove a variable that is not part of a declaration list
        return source.replace(RegExp(
          multilineComment +
          '( *)var ' + varName + ' *(?:|= *(?:.+?(?:&&\\n[\\s\\S]+?)?|(?:[($\\w]+\\(|[{[(]\\n)[\\s\\S]+?\\n\\1[^\\n ]+?));\\n'
        ), '');
      }
    ], function(func) {
      var result = func();
      if (result !== source) {
        source = result;
        return true;
      }
    });

    return source;
  }

  /**
   * Repeats a the given string `n` number of times.
   *
   * @private
   * @param {string} string The string to repeat.
   * @param {string} [n=0] The number of times to repeat the string.
   * @returns {string} Returns the repeated string.
   */
  function repeat(string, n) {
    n || (n = 0);

    // uses the exponentiation by squaring algorithm
    if (n < 1) return '';
    if (n % 2) return repeat(string, n - 1) + string;
    var half = repeat(string, n / 2);
    return half + half;
  }

  /**
   * Replaces the `funcName` function body in `source` with `funcValue`.
   *
   * @private
   * @param {string} source The source to process.
   * @param {string} varName The name of the function to replace.
   * @returns {string} Returns the modified source.
   */
  function replaceFunction(source, funcName, funcValue) {
    var snippet = matchFunction(source, funcName);
    if (!snippet) {
      return source;
    }
    return source.replace(snippet, function() {
      return funcValue
        .replace(RegExp('^' + getIndent(funcValue), 'gm'), getIndent(snippet))
        .trimRight() + '\n';
    });
  }

  /**
   * Replaces the indent at level `from` of the given source with the level `to`.
   *
   * @private
   * @param {string} source The source to process.
   * @param {number} from The indent level to be replaced.
   * @param {number} to The indent level to replace with.
   * @returns {string} Returns the modified source.
   */
  function replaceIndent(source, from, to) {
    return source.replace(RegExp('^(?:  ){' + (from || 1) + '}', 'gm'), repeat('  ', to));
  }

  /**
   * Replaces the `support` object `propName` property value in `source` with `propValue`.
   *
   * @private
   * @param {string} source The source to process.
   * @param {string} varName The name of the `support` property to replace.
   * @returns {string} Returns the modified source.
   */
  function replaceSupportProp(source, propName, propValue) {
    return source.replace(RegExp(
      // match a `try` block
      '(?: *try\\b.+\\n)?' +
      // match the `support` property assignment
      '( *support\\.' + propName + ' *=).+\\n' +
      // match `catch` block
      '(?:( *).+?catch\\b[\\s\\S]+?\\n\\2}\\n)?'
    ), function(match, left) {
      return left + ' ' + propValue + ';\n';
    });
  }

  /**
   * Replaces the `varName` variable declaration value in `source` with `varValue`.
   *
   * @private
   * @param {string} source The source to inspect.
   * @param {string} varName The name of the variable to replace.
   * @returns {string} Returns the modified source.
   */
  function replaceVar(source, varName, varValue) {
    // replace a variable that's not part of a declaration list
    var result = source.replace(RegExp(
      '(( *)var ' + varName + ' *=)' +
      '(?:.+?;|(?:Function\\(.+?|.*?[^,])\\n[\\s\\S]+?\\n\\2.+?;)\\n'
    ), function(match, left) {
      return left + ' ' + varValue + ';\n';
    });

    if (source == result) {
      // replace a varaible at the start or middle of a declaration list
      result = source.replace(RegExp('((?:var|\\n) +' + varName + ' *=).+?,'), function(match, left) {
        return left + ' ' + varValue + ',';
      });
    }
    if (source == result) {
      // replace a variable at the end of a variable declaration list
      result = source.replace(RegExp('(,\\s*' + varName + ' *=).+?;'), function(match, left) {
        return left + ' ' + varValue + ';';
      });
    }
    return result;
  }

  /**
   * Add or remove the "use strict" directive from `source`.
   *
   * @private
   * @param {string} source The source to process.
   * @param {boolean} value The value to set.
   * @returns {string} Returns the modified source.
   */
  function setUseStrictOption(source, value) {
    return source.replace(/^([\s\S]*?function[^{]+\{)(?:\s*'use strict';)?/, '$1' + (value ? "\n  'use strict';" : ''));
  }

  /**
   * This function allows `callback` to modify `source` with string literals
   * removed and returns the modified source with string literals restored.
   *
   * @private
   * @param {string} source The source to modify.
   * @param {Function} [callback] The function to modify the string free source.
   * @returns {string} Returns the modified source.
   */
  function stringFree(source, callback) {
    var strings = [];

    source = callback(source.replace(reStrings, function(match) {
      strings.push(match);
      return '__lodash_string_token__';
    })) || '';

    source = source.replace(/__lodash_string_token__/g, function() {
      return strings.shift();
    });

    return source;
  }

  /**
   * Trims the indent of the specified level from `source`.
   *
   * @private
   * @param {string} source The source to process.
   * @param {number} level The level of indent to trim.
   * @returns {string} Returns the modified source.
   */
  function trimIndent(source, level) {
    return replaceIndent(source, level || 1);
  }

  /*--------------------------------------------------------------------------*/

  /**
   * Creates a debug and/or minified build, executing the callback for each.
   * The callback is invoked with one argument; (data).
   *
   * Note: For a list of commands see `displayHelp()` or run `lodash --help`.
   *
   * @param {Array|Object} [options=[]] An array of build commands or the state object.
   * @param {Function} [callback=defaultBuildCallback] The function called per build.
   */
  function build(options, callback) {
    options || (options = []);

    // the debug version of `source`
    var debugSource;

    // used to specify the output path for builds
    var outputPath;

    // used to specify the source map URL
    var sourceMapURL;

    // use to pre-populate the build state
    var state = _.isObject(options) && !_.isArray(options) && options;

    // used to capture warnings for invalid command-line arguments
    var warnings = [];

    var isExcluded = function() {
      return _.every(arguments, function(funcName) {
        return !_.contains(buildFuncs, funcName);
      });
    };

    var isLodash = function(funcName) {
      funcName = getRealName(funcName);
      if (_.contains(lodashOnlyFuncs, funcName) || /^(?:assign|zipObject)$/.test(funcName)) {
        var funcNames = _.difference(_.union(includeFuncs, plusFuncs), minusFuncs);
        return _.contains(funcNames, funcName);
      }
      funcNames = _.difference(plusFuncs, minusFuncs);
      return _.contains(funcNames, funcName);
    };

    if (state) {
      var buildFuncs = state.buildFuncs,
          filePath = state.filePath,
          funcDepMap = state.funcDepMap,
          iife = state.iife,
          includeFuncs = state.includeFuncs,
          includeObjs = state.includeObjs,
          includeVars = state.includeVars,
          isAMD = state.isAMD,
          isBackbone = state.isBackbone,
          isCommonJS = state.isCommonJS,
          isCSP = state.isCSP,
          isDebug = true,
          isGlobal = state.isGlobal,
          isIIFE = state.isIIFE,
          isLegacy = state.isLegacy,
          isMapped = state.isMapped,
          isMobile = state.isMobile,
          isModern = state.isModern,
          isModularize = true,
          isNode = state.isNode,
          isStdOut = state.isStdOut,
          isSilent = true,
          isStrict = state.isStrict,
          isUnderscore = state.isUnderscore,
          minusFuncs = state.minusFuncs,
          objDepMap = state.objDepMap,
          options = state.options,
          outputPath = state.outputPath,
          plusFuncs = state.plusFuncs,
          source = state.source,
          varDepMap = state.varDepMap;
    }
    else {
      // display help message
      if (_.find(options, function(arg) {
            return /^(?:-h|--help)$/.test(arg);
          })) {
        displayHelp();
        return;
      }

      // display `lodash.VERSION`
      if (_.find(options, function(arg) {
            return /^(?:-V|--version)$/.test(arg);
          })) {
        console.log(_.VERSION);
        return;
      }

      /*----------------------------------------------------------------------*/

      // clone dependencies to modify
      var funcDepMap = createMap(_.cloneDeep(funcDependencyMap)),
          objDepMap = createMap(_.cloneDeep(objDependencyMap)),
          varDepMap = createMap(_.cloneDeep(varDependencyMap));

      // the path to the source file
      var filePath = require.resolve('lodash/lodash.js');

      // used to specify a custom IIFE to wrap Lo-Dash
      var iife = options.reduce(function(result, value) {
        value = optionToValue('iife', value);
        return value == null ? result : value;
      }, null);

      // flag to specify a Backbone build
      var isBackbone = _.contains(options, 'backbone');

      // flag to specify a Content Security Policy build
      var isCSP = _.contains(options, 'csp') || _.contains(options, 'CSP');

      // flag to specify only creating the debug build
      var isDebug = _.contains(options, '-d') || _.contains(options, '--debug');

      // flag to indicate that a custom IIFE was specified
      var isIIFE = typeof iife == 'string';

      // flag to specify creating a source map for the minified source
      var isMapped = _.contains(options, '-p') || _.contains(options, '--source-map');

      // flag to specify only creating the minified build
      var isMinify = _.contains(options, '-m') || _.contains(options, '--minify');

      // flag to specify a mobile build
      var isMobile = _.contains(options, 'mobile');

      // flag to specify a modern build
      var isModern = isCSP || isMobile || _.contains(options, 'modern');

      // flag to specify a modularize build
      var isModularize = _.contains(options, 'modularize');

      // flag to specify writing output to standard output
      var isStdOut = _.contains(options, '-c') || _.contains(options, '--stdout');

      // flag to specify skipping status updates normally logged to the console
      var isSilent = isStdOut || _.contains(options, '-s') || _.contains(options, '--silent');

      // flag to specify `_.assign`, `_.bindAll`, and `_.defaults` are
      // constructed using the "use strict" directive
      var isStrict = _.contains(options, 'strict');

      // flag to specify an Underscore build
      var isUnderscore = isBackbone || _.contains(options, 'underscore');

      // flag to specify a legacy build
      var isLegacy = !(isModern || isUnderscore) && _.contains(options, 'legacy');

      // used to specify the ways to export the `lodash` function
      var exportsOptions = (function() {
        var result = options.reduce(function(result, value) {
          value = optionToArray('exports', value).sort();
          return value.length ? value : result;
        }, isModularize
          ? ['amd']
          : (isUnderscore ? ['commonjs', 'global', 'node'] : _.without(allExports, 'es6', 'npm'))
        );
        return isModularize ? _.first(result, 1) : result;
      }());

      // used to specify the AMD module ID of Lo-Dash used by precompiled templates
      var moduleId = options.reduce(function(result, value) {
        return optionToValue('moduleId', value) || result;
      }, null);

      // used as the output path for the build
      var outputPath = options.reduce(function(result, value, index) {
        if (/^(?:-o|--output)$/.test(value)) {
          result = options[index + 1];
        }
        return result;
      }, isModularize ?  '.' + path.sep + 'modularize' :'');

      // used to match external template files to precompile
      var templatePattern = options.reduce(function(result, value) {
        return optionToValue('template', value) || result;
      }, '');

      // used as the template settings for precompiled templates
      var templateSettings = options.reduce(function(result, value) {
        value = optionToValue('settings', value);
        return value
          ? _.assign(result, Function('return {' + value.replace(/^\{|}$/g, '') + '}')())
          : result;
      }, _.clone(_.templateSettings));

      // flags to specify export options
      var isAMD = _.contains(exportsOptions, 'amd'),
          isCommonJS = _.contains(exportsOptions, 'commonjs'),
          isES6 = _.contains(exportsOptions, 'es6'),
          isGlobal = _.contains(exportsOptions, 'global'),
          isNpm =  _.contains(exportsOptions, 'npm'),
          isNode = isNpm || _.contains(exportsOptions, 'node');

      // flag to specify a template build
      var isTemplate = !!templatePattern;

      // the lodash.js source
      var source = fs.readFileSync(filePath, 'utf8');

      /*----------------------------------------------------------------------*/

      // delete the `_.findWhere` dependency map to enable its alias mapping
      if (!isUnderscore || isLodash('findWhere')) {
        delete funcDepMap.findWhere;
      }

      // categories of functions to include in the build
      var categoryOptions = options.reduce(function(result, value) {
        value = optionToArray('category', value);
        if (value.length) {
          result = _.union(value.map(function(category) {
            return capitalize(category.toLowerCase());
          }));
        }
        return result;
      }, []);

      // functions to include in the build
      var includeFuncs = options.reduce(function(result, value) {
        value = optionToFuncsArray('include', value, funcDepMap);
        return value.length
          ? _.union(result, value)
          : result;
      }, categoryOptions.slice());

      // properties to include in the build
      var includeObjs = _.intersection(includeFuncs, objDependencies);

      // variables to include in the build
      var includeVars = _.intersection(includeFuncs, varDependencies);

      // functions to remove from the build
      var minusFuncs = options.reduce(function(result, value) {
        value = optionToFuncsArray('(?:exclude|minus)', value, funcDepMap);
        return value.length
          ? _.union(result, value)
          : result;
      }, []);

      // functions to add to the build
      var plusFuncs = options.reduce(function(result, value) {
        value = optionToFuncsArray('plus', value, funcDepMap);
        return value.length
          ? _.union(result, value)
          : result;
      }, []);

      // expand categories to function names
      _.each([includeFuncs, minusFuncs, plusFuncs], function(funcNames) {
        var categories = _.intersection(funcNames, allCategories);

        categories.forEach(function(category) {
          var otherFuncs = getNamesByCategory(category).filter(function(key) {
            var type = typeof _[key];
            return type == 'function' || type == 'undefined';
          });

          // limit function names to those available for specific builds
          if (isBackbone) {
            otherFuncs = _.intersection(otherFuncs, backboneDependencies);
          } else if (isUnderscore) {
            otherFuncs = _.intersection(otherFuncs, underscoreFuncs);
          }
          push.apply(funcNames, otherFuncs);
        });
      });

      // remove categories from function names
      includeFuncs = _.difference(includeFuncs, allCategories, includeObjs, includeVars);
      minusFuncs = _.difference(minusFuncs, allCategories);
      plusFuncs = _.difference(plusFuncs, allCategories);

      /*----------------------------------------------------------------------*/

      // used to detect invalid command-line arguments
      var invalidArgs = _.reject(options.slice(reNode.test(options[0]) ? 2 : 0), function(value, index, options) {
        if (/^(?:-o|--output)$/.test(options[index - 1]) ||
            /^(?:category|exclude|exports|iife|include|moduleId|minus|plus|settings|template)=[\s\S]*$/.test(value)) {
          return true;
        }
        var result = _.contains([
          'backbone',
          'compat',
          'csp',
          'legacy',
          'mobile',
          'modern',
          'modularize',
          'strict',
          'underscore',
          '-c', '--stdout',
          '-d', '--debug',
          '-h', '--help',
          '-m', '--minify',
          '-o', '--output',
          '-p', '--source-map',
          '-s', '--silent',
          '-V', '--version'
        ], value);

        if (!result && /^(?:-p|--source-map)$/.test(options[index - 1])) {
          result = true;
          sourceMapURL = value;
        }
        return result;
      });

      // report invalid command and option arguments
      if (invalidArgs.length) {
        warnings.push('Invalid argument' + (invalidArgs.length > 1 ? 's' : '') + ' passed: ' + invalidArgs.join(', '));
      }
      // report invalid command combinations
      invalidArgs = _.intersection(options, ['backbone', 'compat', 'csp', 'legacy', 'mobile', 'modern', 'underscore']);

      if (isTemplate) {
        invalidArgs.push('template');
      }
      if (invalidArgs.length > 1) {
        warnings.push('The `' + invalidArgs.slice(0, -1).join('`, `') + '`' + (invalidArgs.length > 2 ? ',' : '') + ' and `' + invalidArgs.slice(-1) + '` commands may not be combined.');
      }
      // report invalid command entries
      _.forOwn({
        'category': {
          'entries': categoryOptions,
          'validEntries': allCategories
        },
        'exports': {
          'entries': exportsOptions,
          'validEntries': isModularize ? ['amd', 'commonjs', 'es6', 'node', 'npm'] : _.without(allExports, 'es6', 'npm')
        },
        'include': {
          'entries': includeFuncs,
          'validEntries': allFuncs
        },
        'minus': {
          'entries': minusFuncs,
          'validEntries': allFuncs
        },
        'plus': {
          'entries': plusFuncs,
          'validEntries': allFuncs
        }
      }, function(data, commandName) {
        invalidArgs = _.difference(data.entries, data.validEntries, ['none']);
        if (invalidArgs.length) {
          warnings.push('Invalid `' + commandName + '` entr' + (invalidArgs.length > 1 ? 'ies' : 'y') + ' passed: ' + invalidArgs.join(', '));
        }
      });

      if (warnings.length) {
        console.log([''].concat(
          warnings,
          'For more information type: lodash --help'
        ).join('\n'));
        return;
      }

      /*----------------------------------------------------------------------*/

      // names of functions to include in the build
      var buildFuncs = !isTemplate && (function() {
        var result;

        source = setUseStrictOption(source, isStrict);

        if (isLegacy) {
          source = replaceSupportProp(source, 'argsClass', 'false');

          // replace `now()` with `+new Date` in `_.debounce`
          _.pull(funcDepMap.debounce, 'now');

          source = source.replace(matchFunction(source, 'debounce'), function(match) {
            return match.replace(/\bnow\(\)/g, '+new Date');
          });

          // replace `_.isPlainObject` with `shimIsPlainObject`
          funcDepMap.isPlainObject = funcDepMap.shimIsPlainObject.slice();
          objDepMap.isPlainObject = objDepMap.shimIsPlainObject.slice();
          varDepMap.isPlainObject = varDepMap.shimIsPlainObject.slice();

          source = source.replace(
            matchFunction(source, 'isPlainObject').replace(/^ *var isPlainObject *= */m, ''),
            matchFunction(source, 'shimIsPlainObject').replace(/^ *function shimIsPlainObject/m, 'function').replace(/\s*$/, ';\n')
          );

          // replace `_.keys` with `shimKeys`
          funcDepMap.keys = funcDepMap.shimKeys.slice();

          source = source.replace(
            matchFunction(source, 'keys').replace(/^ *var keys.*= */m, ''),
            matchFunction(source, 'shimKeys').replace(/^ *var shimKeys *= */m, '')
          );

          // remove native branches from methods
          _.forOwn(funcDepMap, function(deps, funcName) {
            _.pull(deps, 'isNative');
          });

          source = source.replace(matchFunction(source, 'contains'), function(match) {
            return match.replace(/nativeContains[^:]+:\s*/, '');
          });

          _.each(['isArray', 'now'], function(funcName) {
            source = source.replace(matchFunction(source, funcName), function(match) {
              return match.replace(/(=\s*)[\s\S]+?\|\|\s*/, '$1');
            });
          });

          // replace `baseCreate` and `_.isArguments` with their forks
          _.forOwn({
            'baseCreate': [getBaseCreateFork, removeBaseCreateFork],
            'isArguments': [getIsArgumentsFork, removeIsArgumentsFork]
          },
          function(funcs, funcName) {
            var getFork = funcs[0],
                removeFork =  funcs[1];

            source = source.replace(matchFunction(source, funcName).replace(RegExp('[\\s\\S]+?(function ' + funcName + ')'), '$1'), function() {
              var snippet = getFork(source),
                  indent = getIndent(snippet);

              snippet = snippet.match(RegExp('^( *)(' + funcName + ' *= [\\s\\S]+?\\n\\1}.*)', 'm'))[2];
              return 'var ' + snippet.replace(RegExp('^' + indent, 'gm'), indent.slice(0, -2)) + '\n';
            });

            source = removeFork(source);
          });
        }
        if (isModularize) {
          if (!isCommonJS) {
            _.forOwn(varDepMap, function(deps) {
              _.pull(deps, 'root');
            });
            delete varDepMap.root;
          }
          objDepMap.lodash = ['support', 'templateSettings'];
          funcDepMap.lodash.push('assign', 'baseEach', 'forOwn', 'mixin');
          _.pull(funcDepMap.mixin, 'lodash');
        }
        else {
          funcDepMap.chain.push('wrapperChain');
          funcDepMap.wrapperValueOf.push('assign', 'baseEach', 'chain', 'forOwn', 'mixin', 'wrapperChain', 'wrapperToString');

          _.each(['lodashWrapper', 'tap', 'wrapperChain', 'wrapperToString'], function(funcName) {
            funcDepMap[funcName].push('wrapperValueOf');
          });
        }
        if (isModern || (isUnderscore && _.isEmpty(plusFuncs))) {
          source = removeSupportArgsClass(source);
          source = removeSupportArgsObject(source);
          source = removeSupportNonEnumShadows(source);
          source = removeSupportOwnLast(source);
          source = removeSupportUnindexedChars(source);
          source = removeSupportNodeClass(source);

          if (isMobile) {
            source = replaceSupportProp(source, 'enumPrototypes', 'true');
            source = replaceSupportProp(source, 'nonEnumArgs', 'true');
          }
          else {
            source = removeSupportEnumErrorProps(source);
            source = removeSupportEnumPrototypes(source);
            source = removeSupportNonEnumArgs(source);

            if (!isUnderscore) {
              source = removeIsFunctionFork(source);
            }
          }
          if (!isUnderscore) {
            source = removeIsArgumentsFork(source);
            source = removeSupportSpliceObjects(source);
          }
        }
        if (isLegacy || isMobile || isUnderscore) {
          source = removeEsOptimization(source);

          _.pull(objDepMap.baseCreateCallback, 'support');

          _.each(['baseBind', 'baseCreateCallback', 'baseCreateWrapper'], function(funcName) {
            _.pull(funcDepMap[funcName], 'setBindData');
          });
        }
        if (_.contains(plusFuncs, 'chain') == !isUnderscore) {
          source = addUnderscoreChaining(source, isModularize);

          if (!isModularize) {
            _.pull(funcDepMap.mixin, 'isFunction');
          }
          _.pull(funcDepMap.mixin, 'isObject');
        }
        if (isUnderscore) {
          if (!isLodash('chain')) {
            _.pull(funcDepMap.wrapperValueOf, 'wrapperToString');
          }
          _.each(['baseDifference', 'baseUniq', 'intersection'], function(funcName) {
            if (isLodash(funcName) ||
                (funcName == 'baseDifference' && isLodash('difference')) ||
                (funcName == 'baseUniq' && isLodash('uniq'))) {
              return;
            }
            _.pull(funcDepMap[funcName], 'cacheIndexOf', 'createCache');
          });

          _.each(['isEqual', 'omit', 'pick'], function(funcName) {
            if (isLodash(funcName) || (funcName == 'isEqual' && isLodash('baseIsEqual'))) {
              return;
            }
            _.pull(funcDepMap[funcName], 'baseCreateCallback', 'createCallback');
          });

          _.forOwn(funcDepMap, function(deps, funcName) {
            if (_.every(getDependants(funcName, funcDepMap).concat(funcName), function(otherName) {
                  return !isLodash(otherName);
                })) {
              deps = funcDepMap[funcName];
              if (_.contains(deps, 'charAtCallback')) {
                _.pull(deps, 'charAtCallback', 'isArray', 'isString');
              }
            }
          });

          _.forOwn(varDepMap, function(deps, funcName) {
            if (!isLodash(funcName)) {
              _.pull(deps, 'arrayPool', 'largeArraySize', 'maxPoolSize', 'objectPool');
            }
          });

          // replace `lodash`
          if (!isLodash('lodash')) {
            _.pull(funcDepMap.lodash, 'isArray');

            source = replaceFunction(source, 'lodash', [
              'function lodash(value) {',
              '  return (value instanceof lodash)',
              '    ? value',
              '    : new lodashWrapper(value);',
              '}'
            ].join('\n'));
          }
          // replace `_.assign`
          if (!isLodash('assign')) {
            source = replaceFunction(source, 'assign', [
              'function assign(object) {',
              '  if (!object) {',
              '    return object;',
              '  }',
              '  for (var argsIndex = 1, argsLength = arguments.length; argsIndex < argsLength; argsIndex++) {',
              '    var source = arguments[argsIndex];',
              '    if (source) {',
              '      for (var key in source) {',
              '        object[key] = source[key];',
              '      }',
              '    }',
              '  }',
              '  return object;',
              '}'
            ].join('\n'));
          }
          // replace `_.clone`
          if (!isLodash('baseClone') && !isLodash('clone') && !isLodash('cloneDeep')) {
            _.pull(funcDepMap.clone, 'baseClone').push('assign', 'isArray', 'isObject', 'slice');

            source = replaceFunction(source, 'clone', [
              'function clone(value) {',
              '  return isObject(value)',
              '    ? (isArray(value) ? slice(value) : assign({}, value))',
              '    : value;',
              '}'
            ].join('\n'));
          }
          // replace `_.contains`
          if (!isLodash('contains')) {
            _.pull(funcDepMap.contains, 'isArray', 'isNative', 'isString');

            source = replaceFunction(source, 'contains', [
              'function contains(collection, target) {',
              '  var indexOf = getIndexOf(),',
              '      length = collection ? collection.length : 0,',
              '      result = false;',
              "  if (length && typeof length == 'number') {",
              '    result = indexOf(collection, target) > -1;',
              '  } else {',
              '    baseEach(collection, function(value) {',
              '      return !(result = value === target);',
              '    });',
              '  }',
              '  return result;',
              '}'
            ].join('\n'));
          }
          // replace `_.defaults`
          if (!isLodash('defaults')) {
            source = replaceFunction(source, 'defaults', [
              'function defaults(object) {',
              '  if (!object) {',
              '    return object;',
              '  }',
              '  for (var argsIndex = 1, argsLength = arguments.length; argsIndex < argsLength; argsIndex++) {',
              '    var source = arguments[argsIndex];',
              '    if (source) {',
              '      for (var key in source) {',
              "        if (typeof object[key] == 'undefined') {",
              '          object[key] = source[key];',
              '        }',
              '      }',
              '    }',
              '  }',
              '  return object;',
              '}'
            ].join('\n'));
          }
          // replace `_.difference`
          if (!isLodash('baseDifference') && !isLodash('difference')) {
            source = replaceFunction(source, 'baseDifference', [
              'function baseDifference(array, values) {',
              '  var index = -1,',
              '      indexOf = getIndexOf(),',
              '      length = array ? array.length : 0,',
              '      result = [];',
              '',
              '  while (++index < length) {',
              '    var value = array[index];',
              '    if (indexOf(values, value) < 0) {',
              '      result.push(value);',
              '    }',
              '  }',
              '  return result;',
              '}'
            ].join('\n'));
          }
          // add Underscore's `_.findWhere` and `_.where`
          if (!isLodash('findWhere') && !isLodash('where')) {
            _.pull(funcDepMap.createCallback, 'baseIsEqual', 'isObject');
            funcDepMap.where.push('find', 'isEmpty');

            source = source.replace(matchFunction(source, 'find'), function(match) {
              var indent = getIndent(match);
              return match && (match + [
                '',
                '/**',
                ' * Examines each element in a `collection`, returning the first that',
                ' * has the given properties. When checking `properties`, this method',
                ' * performs a deep comparison between values to determine if they are',
                ' * equivalent to each other.',
                ' *',
                ' * @static',
                ' * @memberOf _',
                ' * @category Collections',
                ' * @param {Array|Object|string} collection The collection to iterate over.',
                ' * @param {Object} properties The object of property values to filter by.',
                ' * @returns {*} Returns the found element, else `undefined`.',
                ' * @example',
                ' *',
                ' * var food = [',
                " *   { 'name': 'apple',  'organic': false, 'type': 'fruit' },",
                " *   { 'name': 'banana', 'organic': true,  'type': 'fruit' },",
                " *   { 'name': 'beet',   'organic': false, 'type': 'vegetable' }",
                ' * ];',
                ' *',
                " * _.findWhere(food, { 'type': 'vegetable' });",
                " * // => { 'name': 'beet', 'organic': false, 'type': 'vegetable' }",
                ' */',
                'function findWhere(object, properties) {',
                '  return where(object, properties, true);',
                '}',
                ''
              ].join('\n' + indent));
            });

            // replace `_.where`
            source = replaceFunction(source, 'where', [
              'function where(collection, properties, first) {',
              '  return (first && isEmpty(properties))',
              '    ? undefined',
              '    : (first ? find : filter)(collection, properties);',
              '}'
            ].join('\n'));

            // simplify `_.match`
            source = source.replace(matchFunction(source, 'match'), function(match) {
              return match
                // remove unnecessary fast path
                .replace(/^(( *)var props *=.+?),[\s\S]+?\n\2}/m, '$1;')
                // remove `baseIsEqual` use
                .replace(/=.+?\bbaseIsEqual\((.+?), *(.+?),.+?\)/, '= $1 === $2');
            });

            // replace alias assignment
            source = source.replace(getMethodAssignments(source), function(match) {
              return match.replace(/^( *lodash.findWhere *= *).+/m, '$1findWhere;');
            });
          }
          // replace `_.flatten`
          if (!isLodash('flatten')) {
            _.pull(funcDepMap.flatten, 'map');

            source = replaceFunction(source, 'flatten', [
              'function flatten(array, isShallow) {',
              '  return baseFlatten(array, isShallow);',
              '}'
            ].join('\n'));
          }
          // replace `_.intersection`
          if (!isLodash('intersection')) {
            source = replaceFunction(source, 'intersection', [
              'function intersection() {',
              '  var args = [],',
              '      argsIndex = -1,',
              '      argsLength = arguments.length;',
              '',
              '  while (++argsIndex < argsLength) {',
              '    var value = arguments[argsIndex];',
              '     if (isArray(value) || isArguments(value)) {',
              '       args.push(value);',
              '     }',
              '  }',
              '  var array = args[0],',
              '      index = -1,',
              '      indexOf = getIndexOf(),',
              '      length = array ? array.length : 0,',
              '      result = [];',
              '',
              '  outer:',
              '  while (++index < length) {',
              '    value = array[index];',
              '    if (indexOf(result, value) < 0) {',
              '      var argsIndex = argsLength;',
              '      while (--argsIndex) {',
              '        if (indexOf(args[argsIndex], value) < 0) {',
              '          continue outer;',
              '        }',
              '      }',
              '      result.push(value);',
              '    }',
              '  }',
              '  return result;',
              '}'
            ].join('\n'));
          }
          // replace `_.isElement`
          if (!isLodash('isElement')) {
            funcDepMap.isElement = [];
            _.pull(objDepMap.isElement, 'support');

            source = removeSupportDom(source);

            source = replaceFunction(source, 'isElement', [
              'function isElement(value) {',
              '  return value && value.nodeType === 1 || false;',
              '}'
            ].join('\n'));
          }
          // replace `_.isEmpty`
          if (!isLodash('isEmpty')) {
            funcDepMap.isEmpty = ['isArray', 'isString'];
            varDepMap.isEmpty = ['hasOwnProperty'];

            source = replaceFunction(source, 'isEmpty', [
              'function isEmpty(value) {',
              '  if (!value) {',
              '    return true;',
              '  }',
              '  if (isArray(value) || isString(value)) {',
              '    return !value.length;',
              '  }',
              '  for (var key in value) {',
              '    if (hasOwnProperty.call(value, key)) {',
              '      return false;',
              '    }',
              '  }',
              '  return true;',
              '}'
            ].join('\n'));
          }
          // replace `_.isEqual`
          if (!isLodash('baseIsEqual') && !isLodash('isEqual')) {
            _.pull(funcDepMap.baseIsEqual, 'isArguments');

            source = replaceFunction(source, 'isEqual', [
              'function isEqual(a, b) {',
              '  return baseIsEqual(a, b);',
              '}'
            ].join('\n'));

            source = replaceFunction(source, 'baseIsEqual', [
              'function baseIsEqual(a, b, stackA, stackB) {',
              '  if (a === b) {',
              '    return a !== 0 || (1 / a == 1 / b);',
              '  }',
              '  var type = typeof a,',
              '      otherType = typeof b;',
              '',
              '  if (a === a &&',
              "      !(a && objectTypes[type]) &&",
              "      !(b && objectTypes[otherType])) {",
              '    return false;',
              '  }',
              '  if (a == null || b == null) {',
              '    return a === b;',
              '  }',
              '  var className = toString.call(a),',
              '      otherClass = toString.call(b);',
              '',
              '  if (className != otherClass) {',
              '    return false;',
              '  }',
              '  switch (className) {',
              '    case boolClass:',
              '    case dateClass:',
              '      return +a == +b;',
              '',
              '    case numberClass:',
              '      return a != +a',
              '        ? b != +b',
              '        : (a == 0 ? (1 / a == 1 / b) : a == +b);',
              '',
              '    case regexpClass:',
              '    case stringClass:',
              '      return a == String(b);',
              '  }',
              '  var isArr = className == arrayClass;',
              '  if (!isArr) {',
              "    var aWrapped = hasOwnProperty.call(a, '__wrapped__'),",
              "        bWrapped = hasOwnProperty.call(b, '__wrapped__');",
              '',
              '    if (aWrapped || bWrapped) {',
              '      return baseIsEqual(aWrapped ? a.__wrapped__ : a, bWrapped ? b.__wrapped__ : b, stackA, stackB);',
              '    }',
              '    if (className != objectClass) {',
              '      return false;',
              '    }',
              '    var ctorA = a.constructor,',
              '        ctorB = b.constructor;',
              '',
              '    if (ctorA != ctorB && ',
              '          !(isFunction(ctorA) && ctorA instanceof ctorA && isFunction(ctorB) && ctorB instanceof ctorB) &&',
              "          ('constructor' in a && 'constructor' in b)",
              '        ) {',
              '      return false;',
              '    }',
              '  }',
              '  stackA || (stackA = []);',
              '  stackB || (stackB = []);',
              '',
              '  var length = stackA.length;',
              '  while (length--) {',
              '    if (stackA[length] == a) {',
              '      return stackB[length] == b;',
              '    }',
              '  }',
              '  var result = true,',
              '      size = 0;',
              '',
              '  stackA.push(a);',
              '  stackB.push(b);',
              '',
              '  if (isArr) {',
              '    size = b.length;',
              '    result = size == a.length;',
              '',
              '    if (result) {',
              '      while (size--) {',
              '        if (!(result = baseIsEqual(a[size], b[size], stackA, stackB))) {',
              '          break;',
              '        }',
              '      }',
              '    }',
              '  }',
              '  else {',
              '    forIn(b, function(value, key, b) {',
              '      if (hasOwnProperty.call(b, key)) {',
              '        size++;',
              '        return (result = hasOwnProperty.call(a, key) && baseIsEqual(a[key], value, stackA, stackB));',
              '      }',
              '    });',
              '',
              '    if (result) {',
              '      forIn(a, function(value, key, a) {',
              '        if (hasOwnProperty.call(a, key)) {',
              '          return (result = --size > -1);',
              '        }',
              '      });',
              '    }',
              '  }',
              '  stackA.pop();',
              '  stackB.pop();',
              '  return result;',
              '}'
            ].join('\n'));

             // replace complex lodash wrapper checks with simpler ones
            if (!isModularize) {
              source = source.replace(matchFunction(source, 'baseIsEqual'), function(match) {
                return match.replace(/hasOwnProperty\.call\(([$\w]+), *'__wrapped__'\)/g, '$1 instanceof lodash')
              });
            }
          }
          // replace `_.memoize`
          if (!isLodash('memoize')) {
             source = replaceFunction(source, 'memoize', [
                'function memoize(func, resolver) {',
                '  var cache = {};',
                '  return function() {',
                '    var key = resolver ? resolver.apply(this, arguments) : keyPrefix + arguments[0];',
                '    return hasOwnProperty.call(cache, key)',
                '      ? cache[key]',
                '      : (cache[key] = func.apply(this, arguments));',
                '  };',
                '}'
            ].join('\n'));
          }
          // replace `_.omit`
          if (!isLodash('omit')) {
            source = replaceFunction(source, 'omit', [
              'function omit(object) {',
              '  var props = [];',
              '  forIn(object, function(value, key) {',
              '    props.push(key);',
              '  });',
              '  props = baseDifference(props, baseFlatten(arguments, true, false, 1));',
              '',
              '  var index = -1,',
              '      length = props.length,',
              '      result = {};',
              '',
              '  while (++index < length) {',
              '    var key = props[index];',
              '    result[key] = object[key];',
              '  }',
              '  return result;',
              '}'
            ].join('\n'));
          }
          // replace `_.pick`
          if (!isLodash('pick')) {
            _.pull(funcDepMap.pick, 'forIn', 'isObject');

            source = replaceFunction(source, 'pick', [
              'function pick(object) {',
              '  var index = -1,',
              '      props = baseFlatten(arguments, true, false, 1),',
              '      length = props.length,',
              '      result = {};',
              '',
              '  while (++index < length) {',
              '    var key = props[index];',
              '    if (key in object) {',
              '      result[key] = object[key];',
              '    }',
              '  }',
              '  return result;',
              '}'
            ].join('\n'));
          }
          // replace `_.random`
          if (!isLodash('random')) {
             source = replaceFunction(source, 'random', [
              'function random(min, max) {',
              '  if (min == null && max == null) {',
              '    max = 1;',
              '  }',
              '  min = +min || 0;',
              '  if (max == null) {',
              '    max = min;',
              '    min = 0;',
              '  } else {',
              '    max = +max || 0;',
              '  }',
              '  return min + floor(nativeRandom() * (max - min + 1));',
              '}'
            ].join('\n'));
          }
          // replace `_.sortBy`
          if (!isLodash('sortBy')) {
            source = replaceFunction(source, 'sortBy', [
              'function sortBy(collection, callback, thisArg) {',
              '  var index = -1,',
              '      length = collection ? collection.length : 0,',
              "      result = Array(typeof length == 'number' ? length : 0);",
              '',
              '  callback = lodash.createCallback(callback, thisArg, 3);',
              '  forEach(collection, function(value, key, collection) {',
              '    result[++index] = {',
              "      'criteria': [callback(value, key, collection)],",
              "      'index': index,",
              "      'value': value",
              '    };',
              '  });',
              '',
              '  length = result.length;',
              '  result.sort(compareAscending);',
              '  while (length--) {',
              '    result[length] = result[length].value;',
              '  }',
              '  return result;',
              '}'
            ].join('\n'));
          }
          // replace `_.tap`
          if (!isLodash('tap')) {
             source = replaceFunction(source, 'tap', [
              'function tap(value, interceptor) {',
              '  interceptor(value);',
              '  return value;',
              '}'
            ].join('\n'));
          }
          // replace `_.template`
          if (!isLodash('template')) {
            _.pull(funcDepMap.template, 'keys', 'values');

            source = replaceFunction(source, 'template', [
              'function template(text, data, options) {',
              '  var _ = lodash,',
              '      settings = _.templateSettings;',
              '',
              "  text = String(text || '');",
              '  options = iteratorTemplate ? defaults({}, options, settings) : settings;',
              '',
              '  var index = 0,',
              '      source = "__p += \'",',
              '      variable = options.variable;',
              '',
              '  var reDelimiters = RegExp(',
              "    (options.escape || reNoMatch).source + '|' +",
              "    (options.interpolate || reNoMatch).source + '|' +",
              "    (options.evaluate || reNoMatch).source + '|$'",
              "  , 'g');",
              '',
              '  text.replace(reDelimiters, function(match, escapeValue, interpolateValue, evaluateValue, offset) {',
              '    source += text.slice(index, offset).replace(reUnescapedString, escapeStringChar);',
              '    if (escapeValue) {',
              '      source += "\' +\\n_.escape(" + escapeValue + ") +\\n\'";',
              '    }',
              '    if (evaluateValue) {',
              '      source += "\';\\n" + evaluateValue + ";\\n__p += \'";',
              '    }',
              '    if (interpolateValue) {',
              '      source += "\' +\\n((__t = (" + interpolateValue + ")) == null ? \'\' : __t) +\\n\'";',
              '    }',
              '    index = offset + match.length;',
              '    return match;',
              '  });',
              '',
              '  source += "\';\\n";',
              '  if (!variable) {',
              "    variable = 'obj';",
              "    source = 'with (' + variable + ' || {}) {\\n' + source + '\\n}\\n';",
              '  }',
              "  source = 'function(' + variable + ') {\\n' +",
              '    "var __t, __p = \'\', __j = Array.prototype.join;\\n" +',
              '    "function print() { __p += __j.call(arguments, \'\') }\\n" +',
              '    source +',
              "    'return __p\\n}';",
              '',
              '  try {',
              "    var result = Function('_', 'return ' + source)(_);",
              '  } catch(e) {',
              '    e.source = source;',
              '    throw e;',
              '  }',
              '  if (data) {',
              '    return result(data);',
              '  }',
              '  result.source = source;',
              '  return result;',
              '}'
            ].join('\n'));
          }
          // replace `_.throttle`
          if (!isLodash('throttle')) {
            source = replaceFunction(source, 'throttle', [
              'function throttle(func, wait, options) {',
              '  var leading = true,',
              '      trailing = true;',
              '',
              '  if (!isFunction(func)) {',
              '    throw new TypeError;',
              '  }',
              '  if (options === false) {',
              '    leading = false;',
              '  } else if (isObject(options)) {',
              "    leading = 'leading' in options ? options.leading : leading;",
              "    trailing = 'trailing' in options ? options.trailing : trailing;",
              '  }',
              '  options = {};',
              '  options.leading = leading;',
              '  options.maxWait = wait;',
              '  options.trailing = trailing;',
              '',
              '  return debounce(func, wait, options);',
              '}'
            ].join('\n'));
          }
          // replace `_.toArray`
          if (!isLodash('toArray')) {
             _.pull(funcDepMap.toArray, 'isString').push('isArray', 'map');

            source = replaceFunction(source, 'toArray', [
              'function toArray(collection) {',
              '  if (isArray(collection)) {',
              '    return slice(collection);',
              '  }',
              "  if (collection && typeof collection.length == 'number') {",
              '    return map(collection);',
              '  }',
              '  return values(collection);',
              '}'
            ].join('\n'));
          }
          // replace `baseUniq`
          if (!isLodash('baseUniq') && !isLodash('uniq')) {
            source = replaceFunction(source, 'baseUniq', [
              'function baseUniq(array, isSorted, callback) {',
              '  var index = -1,',
              '      indexOf = getIndexOf(),',
              '      length = array ? array.length : 0,',
              '      result = [],',
              '      seen = callback ? [] : result;',
              '',
              '  while (++index < length) {',
              '    var value = array[index],',
              '        computed = callback ? callback(value, index, array) : value;',
              '',
              '    if (isSorted',
              '          ? !index || seen[seen.length - 1] !== computed',
              '          : indexOf(seen, computed) < 0',
              '        ) {',
              '      if (callback) {',
              '        seen.push(computed);',
              '      }',
              '      result.push(value);',
              '    }',
              '  }',
              '  return result;',
              '}'
            ].join('\n'));
          }
          // replace `_.uniqueId`
          if (!isLodash('uniqueId')) {
            source = replaceFunction(source, 'uniqueId', [
              'function uniqueId(prefix) {',
              "  var id = ++idCounter + '';",
              '  return prefix ? prefix + id : id;',
              '}'
            ].join('\n'));
          }
          // replace `_.zip`
          if(!isLodash('zip')) {
            source = replaceFunction(source, 'zip', [
              'function zip() {',
              '  var index = -1,',
              "      length = max(pluck(arguments, 'length')),",
              '      result = Array(length < 0 ? 0 : length);',
              '',
              '  while (++index < length) {',
              '    result[index] = pluck(arguments, index);',
              '  }',
              '  return result;',
              '}'
            ].join('\n'));
          }
        }
        if (isModern || isUnderscore) {
          _.each(['at', 'baseEach', 'forEachRight', 'sample', 'toArray'], function(funcName) {
            if (!(isUnderscore && isLodash(funcName))) {
              _.pull(funcDepMap[funcName], 'isString');
            }
          });

          _.each(['forIn', 'shimKeys'], function(funcName) {
            if (!(isUnderscore && isLodash(funcName))) {
              var deps = varDepMap[funcName] || (varDepMap[funcName] = []);
              deps.push('objectTypes');
              if (funcName == 'shimKeys') {
                deps.push('hasOwnProperty');
              }
              deps = _.pull(funcDepMap[funcName], 'createIterator');
              deps.push('isArguments');
              if (funcName != 'shimKeys') {
                deps.push('baseCreateCallback');
              }
            }
          });

          _.forOwn(funcDepMap, function(deps, funcName) {
            if (_.contains(deps, 'isNode') &&
                !(isUnderscore && isLodash(funcName))) {
              _.pull(deps, 'isNode');
            }
          });

          _.forOwn(objDepMap, function(deps, funcName) {
            if (!(isMobile && funcName == 'keys') &&
                !(isUnderscore && isLodash(funcName)) &&
                !_.contains(['baseCreateCallback', 'isElement', 'lodash', 'wrapperValueOf'], funcName)) {
              _.pull(deps, 'support');
            }
          });

          if (!isMobile) {
            _.each(['baseClone', 'lodash', 'transform', 'wrapperValueOf'], function(funcName) {
              if (!(isUnderscore && (isLodash(funcName) ||
                  (funcName == 'lodash' || funcName == 'wrapperValueOf') && !_.isEmpty(plusFuncs)))) {
                _.pull(funcDepMap[funcName], 'baseEach').push('forEach');
              }
            });

            _.each(['contains', 'createAggregator', 'every', 'filter', 'find', 'forEach', 'forEachRight', 'map', 'max', 'min', 'reduce', 'some'], function(funcName) {
              if (!(isUnderscore && isLodash(funcName))) {
                _.pull(funcDepMap[funcName], 'baseEach').push('forOwn');
              }
            });

            _.each(['max', 'min'], function(funcName) {
              if (!(isUnderscore && isLodash(funcName))) {
                funcDepMap[funcName].push('forEach');

                source = source.replace(matchFunction(source, funcName), function(match) {
                  return match.replace(/\bbaseEach\(/, 'forEach(');
                });
              }
            });

            _.each(['createAggregator', 'every', 'filter', 'find', 'forEach', 'forEachRight', 'map', 'reduce'], function(funcName) {
              if (!(isUnderscore && isLodash(funcName))) {
                _.pull(funcDepMap[funcName], 'isArray');
              }
            });

            _.forOwn(funcDepMap, function(deps, funcName) {
              if (_.contains(deps, 'isArguments') &&
                  !_.contains(['baseFlatten', 'intersection', 'xor'], funcName) &&
                  !(isUnderscore && isLodash(funcName))) {
                _.pull(deps, 'isArguments');
              }
            });

            // replace `_.forEach`
            if (!(isUnderscore && isLodash('forEach'))) {
              source = replaceFunction(source, 'forEach', [
                'function forEach(collection, callback, thisArg) {',
                '  var index = -1,',
                '      length = collection ? collection.length : 0;',
                '',
                "  callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);",
                "  if (typeof length == 'number') {",
                '    while (++index < length) {',
                '      if (callback(collection[index], index, collection) === false) {',
                '        break;',
                '      }',
                '    }',
                '  } else {',
                '    baseEach(collection, callback);',
                '  }',
                '  return collection;',
                '}',
              ].join('\n'));
            }
            // replace `_.forEachRight`
            if (!(isUnderscore && isLodash('forEachRight'))) {
              source = replaceFunction(source, 'forEachRight', [
                'function forEachRight(collection, callback, thisArg) {',
                '  var length = collection ? collection.length : 0;',
                "  callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);",
                "  if (typeof length == 'number') {",
                '    while (length--) {',
                '      if (callback(collection[length], length, collection) === false) {',
                '        break;',
                '      }',
                '    }',
                '  } else {',
                '    var props = keys(collection);',
                '    length = props.length;',
                '    baseEach(collection, function(value, key, collection) {',
                '      key = props ? props[--length] : --length;',
                '      return callback(collection[key], key, collection);',
                '    });',
                '  }',
                '  return collection;',
                '}',
              ].join('\n'));
            }
            // replace `_.isRegExp`
            if (!isUnderscore) {
              _.pull(varDepMap.isRegExp, 'objectTypes');

              source = replaceFunction(source, 'isRegExp', [
                'function isRegExp(value) {',
                "  return value && typeof value == 'object' && toString.call(value) == regexpClass || false;",
                '}'
              ].join('\n'));
            }
            // replace `_.map`
            if (!(isUnderscore && (isLodash('map') || isLodash('pluck')))) {
              source = replaceFunction(source, 'map', [
                'function map(collection, callback, thisArg) {',
                '  var index = -1,',
                '      length = collection ? collection.length : 0;',
                '',
                '  callback = lodash.createCallback(callback, thisArg, 3);',
                "  if (typeof length == 'number') {",
                '    var result = Array(length);',
                '    while (++index < length) {',
                '      result[index] = callback(collection[index], index, collection);',
                '    }',
                '  } else {',
                '    result = [];',
                '    baseEach(collection, function(value, key, collection) {',
                '      result[++index] = callback(value, key, collection);',
                '    });',
                '  }',
                '  return result;',
                '}'
              ].join('\n'));
            }

            _.each(['createAggregator', 'every', 'filter', 'find', 'max', 'min', 'reduce', 'some'], function(funcName) {
              if (!(isUnderscore && (isLodash(funcName) || (funcName == 'find' && isLodash('findWhere'))))) {
                source = source.replace(matchFunction(source, funcName), function(match) {
                  if (!isUnderscore && (funcName == 'min' || funcName == 'max')) {
                    return match;
                  }
                  // replace `_.isArray` checks with simpler type checks
                  return match.replace(/^(( *)if *\(.*?\bisArray\([^\)]+\).*?\) *\{\n)(( *)var index[^;]+.+\n+)/m, function(snippet, statement, indent, vars) {
                    vars = vars
                      .replace(/\b(length *=)[^;=]+/, '$1 collection ? collection.length : 0')
                      .replace(RegExp('^  ' + indent, 'gm'), indent);

                    return vars + statement.replace(/\bisArray\([^\)]+\)/, "typeof length == 'number'");
                  });
                });
              }
            });

            if (!isUnderscore || _.isEmpty(plusFuncs)) {
              // replace `baseEach` with `_.forOwn` in "Collections" functions
              source = source.replace(/^( *)baseEach(?=\((?:collection|iterable))/gm, '$1forOwn');

              // replace `baseEach` with `_.forEach` in the rest of the functions
              source = source.replace(/(\?\s*)baseEach(?=\s*:)/g, '$1forEach');

              // replace `baseEach` with `_.forEach` in the function assignment snippet
              source = source.replace(/^( *)baseEach(?=\(\[')/gm, '$1forEach');
            }
          }
        }
        if (isUnderscore) {
          _.forOwn(funcDepMap, function(deps, funcName) {
            if (_.every(getDependants(funcName, funcDepMap).concat(funcName), function(otherName) {
                  return !isLodash(otherName);
                })) {
              deps = funcDepMap[funcName];
              if (_.contains(deps, 'releaseArray')) {
                _.pull(deps, 'getArray', 'releaseArray');
              }
              if (_.contains(deps, 'releaseObject')) {
                _.pull(deps, 'getObject', 'releaseObject');
              }
            }
          });

          // replace `lodash.createCallback` references with `createCallback`
          if (!isLodash('createCallback')) {
            source = source.replace(/\blodash\.(createCallback\()\b/g, '$1');
          }
          // replace `htmlEscapes` entries with hex entities
          if (!isLodash('escape')) {
            _.each(['htmlEscapes', 'htmlUnescapes', 'reEscapedHtml'], function(varName) {
              source = source.replace(matchVar(source, varName), function(match) {
                return match.replace('#39', '#x27');
              });
            });
          }
          // remove support for a `step` of `0` in `_.range`
          if (!isLodash('range')) {
            source = source.replace(matchFunction(source, 'range'), function(match) {
              return match
                .replace(/typeof *step[^:]+:/, '')
                .replace(/\(step.*\|\|.+?\)/, 'step')
            });
          }
          // remove `_.templateSettings.imports assignment
          if (!isModularize) {
            source = source.replace(/,[^']*'imports':[^}]+}/, '');
          }
          // remove chainability
          _.each(['baseEach', 'forEach', 'forEachRight'], function(funcName) {
            if (!(isLodash(funcName) || (funcName == 'baseEach' && !_.isEmpty(plusFuncs)))) {
              source = source.replace(matchFunction(source, funcName), function(match) {
                return match.replace(/\n *return .+?([}\s]+)$/, '$1');
              });
            }
          });

          // remove conditional `charCodeCallback` use from `_.max` and `_.min`
          _.each(['max', 'min'], function(funcName) {
            if (!isLodash(funcName)) {
              source = source.replace(matchFunction(source, funcName), function(match) {
                return match.replace(/=.+?isString[^:]+:\s*/g, '= ');
              });
            }
          });

          // unexpose "exit early" feature from functions
          if (!isLodash('forEach') && !isLodash('forEachRight') &&
              !isLodash('forIn') && !isLodash('forInRight') &&
              !isLodash('forOwn') && !isLodash('forOwnRight')) {

            _.each(['baseEach', 'forEach', 'forIn', 'forInRight', 'forOwn', 'forOwnRight'], function(funcName) {
              (varDepMap[funcName] || (varDepMap[funcName] = [])).push('indicatorObject');

              source = source.replace(matchFunction(source, funcName), function(match) {
                return match.replace(/=== *false/g, '=== indicatorObject');
              });
            });

            // add `indicatorObject` to `createIterator`
            source = source.replace(matchFunction(source, 'createIterator'), function(match) {
              return match.replace(/isArguments,/g, 'indicatorObject, $&');
            });

            // modify functions that use `_.forEach` to use the private `indicatorObject`
            _.each(['findLast', 'forEachRight', 'transform'], function(funcName) {
              (varDepMap[funcName] || (varDepMap[funcName] = [])).push('indicatorObject');
            });

            // modify functions that use `_.forIn` to use the private `indicatorObject`
            _.each(['baseIsEqual', 'shimIsPlainObject'], function(funcName) {
              (varDepMap[funcName] || (varDepMap[funcName] = [])).push('indicatorObject');
            });

            // modify functions that use `_.forOwn` to use the private `indicatorObject`
            _.each(['contains', 'every', 'find', 'findKey', 'some'], function(funcName) {
              (varDepMap[funcName] || (varDepMap[funcName] = [])).push('indicatorObject');
            });

            // modify functions that use `_.forOwnRight` to use the private `indicatorObject`
            (varDepMap.findLastKey || (varDepMap.findLastKey = [])).push('indicatorObject');


            _.each(['forEachRight', 'transform'], function(funcName) {
              source = source.replace(matchFunction(source, funcName), function(match) {
                return match.replace(/return callback[^)]+\)/, '$& === false && indicatorObject');
              });
            });

            _.each(['baseIsEqual', 'every'], function(funcName) {
              source = source.replace(matchFunction(source, funcName), function(match) {
                return match.replace(/\(result *= *(.+?)\);/g, '!(result = $1) && indicatorObject;');
              });
            });

            _.each(['find', 'findKey', 'findLast', 'findLastKey', 'shimIsPlainObject'], function(funcName) {
              source = source.replace(matchFunction(source, funcName), function(match) {
                return match.replace(/return false/, 'return indicatorObject');
              });
            });

            _.each(['contains', 'some'], function(funcName) {
              source = source.replace(matchFunction(source, funcName), function(match) {
                return match.replace(/!\(result *= *(.+?)\);/, '(result = $1) && indicatorObject;');
              });
            });
          }
        }
        if (isModularize) {
          _.forOwn(funcDepMap, function(deps, funcName) {
            if (_.contains(deps, 'getIndexOf')) {
              _.pull(deps, 'getIndexOf').push('baseIndexOf');
            }
          });
        }
        // alias `baseCreateCallback` as `createCallback`
        if (_.contains(minusFuncs, 'pluck') && _.contains(minusFuncs, 'where')) {
          source = replaceFunction(source, 'createCallback', 'var createCallback = baseCreateCallback;');
        }
        // remove "_.pluck" style callback support from `_.createCallback`
        else if (_.contains(minusFuncs, 'pluck')) {
          _.pull(funcDepMap.createCallback, 'property');

          source = source.replace(matchFunction(source, 'createCallback'), function(match) {
            return match.replace(/(return\b).+?property[^:]+:\s*/m, '$1 ');
          });
        }
        // remove "_.where" style callback support from `_.createCallback`
        else if (_.contains(minusFuncs, 'where')) {
          _.pull(funcDepMap.createCallback, 'match');
          funcDepMap.createCallback.push('identity');

          source = source.replace(matchFunction(source, 'createCallback'), function(match) {
            return match.replace(/\bmatch\(.+?\)/m, 'identity');
          });
        }
        // add function names explicitly
        if (includeFuncs.length) {
          result = includeFuncs;
        }
        // add default function names
        if (!includeObjs.length && !includeVars.length) {
          if (isBackbone && !result) {
            result = backboneDependencies;
          }
          else if (isUnderscore && !result) {
            result = underscoreFuncs;
          }
          if (!result) {
            result = lodashFuncs.slice();
          }
        }
        // remove special "none" entry
        if (result == 'none') {
          result = [];
        } else {
          _.pull(result, 'none');
        }
        // add and subtract function names
        if (plusFuncs.length) {
          result = _.union(result, plusFuncs);
        }
        if (minusFuncs.length) {
          result = _.difference(result, minusFuncs.concat(getDependants(minusFuncs, funcDepMap)));
        }
        if (isModularize) {
          _.pull(result, 'runInContext');
        }
        return getDependencies(result, funcDepMap);
      }());

      // expand properties, variables, and their function dependencies to include in the build
      (function() {
        function expand(includes, allDeps, depMap, funcNames, stack) {
          stack || (stack = []);
          _.each(funcNames || buildFuncs, function(funcName) {
            if (_.contains(stack, funcName)) {
              return;
            }
            stack.push(funcName);
            _.each([varDepMap, objDepMap], function(otherDepMap) {
              var otherDeps = otherDepMap[funcName];
              if (otherDeps) {
                var validDeps = _.transform(otherDeps, function(result, depName) {
                  var deps = depMap[depName];
                  push.apply(result, deps || []);
                });

                push.apply(validDeps, _.filter(otherDeps, function(depName) {
                  return _.contains(allDeps, depName);
                }));

                var otherNames = _.transform(validDeps, function(result, depName) {
                  push.apply(result, getDependencies(funcDepMap[depName], funcDepMap));
                });

                push.apply(includes, validDeps);
                push.apply(buildFuncs, otherNames);
                expand(includes, allDeps, depMap, otherNames, stack);
              }
            });
          });
        }

        expand(includeObjs, objDependencies, objDepMap);
        expand(includeVars, varDependencies, varDepMap);

        buildFuncs = _.uniq(buildFuncs);
        includeObjs = _.union(includeObjs, _.intersection(objDependencies, includeVars));
        includeVars = _.union(includeVars, _.intersection(varDependencies, includeObjs));
      }());

      /*----------------------------------------------------------------------*/

      // load customized Lo-Dash module
      var lodash = !isTemplate && (function() {
        var context = vm.createContext({
          'clearTimeout': clearTimeout,
          'console': console,
          'setTimeout': setTimeout
        });

        vm.runInContext(source, context);
        return context._;
      }());

      /*----------------------------------------------------------------------*/

      if (isTemplate) {
        source = buildTemplate({
          'moduleId': moduleId,
          'source': source,
          'templatePattern': templatePattern,
          'templateSettings': templateSettings
        });
      }
      else {
        source = removeFromCreateIterator(source, 'support');
        source = removePseudoPrivates(source);

        // inline `iteratorTemplate` template
        source = replaceFunction(source, 'iteratorTemplate', (function() {
          var snippet = cleanupCompiled(getFunctionSource(lodash._iteratorTemplate));

          // prepend data object references to property names to avoid having to
          // use a with-statement
          iteratorOptions.forEach(function(prop) {
            if (prop !== 'support') {
              snippet = snippet.replace(RegExp('(["\'])(?:(?!\\1)[^\\n\\\\]|\\\\.)*\\1|([^.])\\b' + prop + '\\b', 'g'), function(match, quote, prelude) {
                return quote ? match : (prelude + 'obj.' + prop);
              });
            }
          });

          // remove unnecessary code
          snippet = snippet
            .replace(/var __t.+/, "var __p = '';")
            .replace(/function print[^}]+}/, '')
            .replace(/'(?:\\n|\s)+'/g, "''")
            .replace(/__p *\+= *' *';/g, '')
            .replace(/\s*\+\s*'';/g, ';')
            .replace(/(__p *\+= *)' *' *\+/g, '$1')
            .replace(/\(\(__t *= *\( *([\s\S]+?) *\)\) *== *null *\? *'' *: *__t\)/g, '($1)');

          // remove the with-statement
          snippet = snippet.replace(/^ *with *\(.+?\) *\{\n/m, '\n').replace(/}([^}]*}[^}]*$)/, '$1');

          // minor cleanup
          snippet = snippet
            .replace(/obj\s*\|\|\s*\(obj *= *\{}\);/, '')
            .replace(/var __p = '';\s*__p \+=/, 'var __p =');

          // remove comments, including sourceURLs
          snippet = snippet.replace(/\s*\/\/.*(?:\n|$)/g, '');

          // replace `iteratorTemplate` assignment
          snippet = 'var iteratorTemplate = ' + snippet + ';\n';

          return snippet;
        }()));

        // remove `iteratorTemplate` dependency checks from `_.template`
        source = source.replace(matchFunction(source, 'template'), function(match) {
          return match
            .replace(/iteratorTemplate *&& */g, '')
            .replace(/iteratorTemplate\s*\?\s*([^:]+?)\s*:[^,;]+/g, '$1');
        });

        if (isModern || isUnderscore) {
          // inline functions defined with `createIterator`
          _.each(['forIn', 'shimKeys'], function(funcName) {
            if (!(isUnderscore && isLodash(funcName))) {
              var func = lodash['_' + funcName] || lodash[funcName];
              source = source.replace(matchFunction(source, funcName), function(match) {
                var indent = match.match(/^\s*/)[0];
                return match.replace(/=[\s\S]+$/, '= ' + cleanupCompiled(getFunctionSource(func, indent))) + ';\n';
              });
            }
          });
        }
        if (isUnderscore) {
          // remove `thisArg` from unexposed `forEachRight`, `forIn` and `forOwn`
          _.each(['forEachRight', 'forIn', 'forOwn'], function(funcName) {
            if (!isLodash(funcName)) {
              source = source.replace(matchFunction(source, funcName), function(match) {
                return match
                  .replace(/(callback), *thisArg/g, '$1')
                  .replace(/^ *callback *=.+\n/m, '');
              });
            }
          });

          // unexpose Lo-Dash methods for the Underscore build
          source = source.replace(getMethodAssignments(source), function(match) {
            return _.reduce(['assign', 'create', 'createCallback', 'eachRight', 'forEachRight', 'forIn', 'forOwn', 'isPlainObject', 'match', 'noop', 'now', 'property', 'unzip', 'zipObject'], function(result, funcName) {
              return isLodash(funcName)
                ? result
                : result.replace(RegExp('^(?: *//.*\\s*)* *lodash\\.' + funcName + ' *=[\\s\\S]+?;\\n', 'm'), '');
            }, match);
          });
        }
        if (isModularize) {
          source = removeGetIndexOf(source);

          // replace the `lodash.templateSettings` property assignment with a variable assignment
          source = source.replace(/\b(lodash\.)(?=templateSettings *=)/, 'var ');

          // remove the `lodash` namespace from properties
          source = source.replace(/\blodash\.(?!com|prototype)([$\w]+)\b(?!\s*=)/g, '$1');

          // remove all horizontal rule comment separators
          source = source.replace(/^ *\/\*-+\*\/\n/gm, '');

          // remove `lodash` branch in `_.mixin`
          source = source.replace(matchFunction(source, 'mixin'), function(match) {
            return match.replace(/^(?: *\/\/.*\n)*( *)if *\(!source[\s\S]+?\n\1}\n+/m, '');
          });

          // replace `lodash` use in `_.templateSettings.imports`
          source = source.replace(matchProp(source, 'templateSettings'), function(match) {
            return match.replace(/(:\s*)lodash\b/, "$1{ 'escape': escape }");
          });

          source = source.replace(matchFunction(source, 'template'), function(match) {
            if (isUnderscore) {
              // assign `_` via `template.imports`
              return match
                .replace(/(_ *= *)lodash\b/, '$1templateSettings.imports._')
                .replace(/= *_\.templateSettings(?=[,;])/, '$& || templateSettings');
            }
            return match
              // assign `settings` via `template.imports`
              .replace(/= *templateSettings(?=[,;])/, '$&.imports._.templateSettings || templateSettings')
              // remove debug sourceURL use in `_.template`
              .replace(/(?:\s*\/\/.*\n)* *var sourceURL[^;]+;|\+ *sourceURL/g, '');
          });

          // replace `root` with the appropriate global object for the specified `exports` option
          if (isAMD || isNode) {
            source = source.replace(/\bcontext(?=\.)/g, isAMD ? 'window' : 'global');
          }
          if (!isAMD) {
            source = removeVar(source, 'undefined');
          }
          source = removeRunInContext(source);
        }
      }

      /*----------------------------------------------------------------------*/

      // set the AMD module id
      if (isAMD && moduleId != null && !isModularize && !isTemplate) {
        source = source.replace(/^ *define\((?=function)/m, "$&'" + moduleId + "', ");
      }
      // customize Lo-Dash's export bootstrap
      if (!isAMD || isModularize) {
        source = source.replace(/^(?: *\/\/.*\n)*( *)if *\(typeof +define[\s\S]+?else /m, '$1');
      }
      if (!isNode || isModularize) {
        source = source.replace(/^(?: *\/\/.*\n)*( *)if *\(moduleExports[\s\S]+?else *\{([\s\S]+?\n)\1}\n+/m, '$1$2');
      }
      if (!isCommonJS || isModularize) {
        source = source.replace(/^(?: *\/\/.*\n)*(?:(( *)}?) *else *\{)?\s*freeExports\.[$\w]+ *=[\s\S]+?(?:\n\2})?\n+/m, function(match, prelude) {
          return prelude ? prelude + '\n' : '';
        });
      }
      if (!isGlobal || isModularize) {
        source = source.replace(/^(?: *\/\/.*\n)*(?:(( *)}?) *else(?: *if *\(_\))? *\{)?(?:\s*\/\/.*)*\s*(?:root\._|_\.templates) *=[\s\S]+?(?:\n\2})?\n+/gm, function(match, prelude) {
          return prelude ? prelude + '\n' : '';
        });
      }
      // remove `if (freeExports && freeModule) {...}` if it's empty
      if (isAMD && isGlobal && !isModularize) {
        source = source.replace(/^(?: *\/\/.*\n)* *(?:else )?if *\(freeExports.*?\) *\{\s*}\n+/m, '');
      } else {
        source = source.replace(/^(?: *\/\/.*\n)* *(?:else )?if *\(freeExports.*?\) *\{\s*}(?:\s*else *\{([\s\S]+?) *})?\n+/m, '$1\n');
      }

      /*----------------------------------------------------------------------*/

      // exit early to create modules
      if (isModularize) {
        buildModule({
          'buildFuncs': buildFuncs,
          'filePath': filePath,
          'funcDepMap': funcDepMap,
          'includeFuncs': includeFuncs,
          'includeObjs': includeObjs,
          'includeVars': includeVars,
          'isAMD': isAMD,
          'isBackbone': isBackbone,
          'isCommonJS': isCommonJS,
          'isCSP': isCSP,
          'isDebug': true,
          'isES6': isES6,
          'isGlobal': isGlobal,
          'isIIFE': true,
          'isLegacy': isLegacy,
          'isMapped': isMapped,
          'isMobile': isMobile,
          'isModern': isModern,
          'isNode': isNode,
          'isNpm': isNpm,
          'isStdOut': isStdOut,
          'isStrict': isStrict,
          'isUnderscore': isUnderscore,
          'lodash': lodash,
          'minusFuncs': minusFuncs,
          'objDepMap': objDepMap,
          'options': options,
          'outputPath': outputPath,
          'plusFuncs': plusFuncs,
          'source': source,
          'varDepMap': varDepMap
        }, callback);
        return;
      }
    }

    /*------------------------------------------------------------------------*/

    // modify/remove references to removed functions/variables
    if (!isTemplate) {
      if (isExcluded(isModularize ? 'lodash' : 'lodashWrapper')) {
        // remove `lodashWrapper.prototype` assignment
        source = source.replace(/(?:\s*\/\/.*)*\n *lodashWrapper\.prototype *=.+/, '');
      }
      if (isExcluded(isModularize ? 'lodash' : 'mixin')) {
        source = removeMixinCalls(source);
      }
      if (isExcluded(isModularize ? 'lodash' : 'wrapperValueOf')) {
        source = removeChaining(source);
      }
      if (!isModularize) {
        if (isExcluded('clone', 'isElement', 'isEqual', 'isPlainObject')) {
          source = removeSupportNodeClass(source);
        }
        if (isExcluded('createIterator')) {
          source = removeSupportNonEnumShadows(source);
        }
        if (isExcluded('isArguments')) {
          source = replaceSupportProp(source, 'argsClass', 'true');
        }
        if (isExcluded('isArguments', 'isEmpty', 'isPlainObject')) {
          source = removeSupportArgsClass(source);
        }
        if (isExcluded('isElement')) {
          source = removeSupportDom(source);
        }
        if (isExcluded('isPlainObject')) {
          source = removeSupportOwnLast(source);
        }
        if (isExcluded('keys')) {
          source = removeSupportNonEnumArgs(source);
        }
        if (isExcluded('lodashWrapper')) {
          source = removeChaining(source);
        }
        if (!/\.(?:enumErrorProps|nonEnumShadows) *=/.test(source)) {
          source = removeFromCreateIterator(source, 'errorClass');
          source = removeFromCreateIterator(source, 'errorProto');

          // remove 'Error' from the `contextProps` array
          source = source.replace(/^ *var contextProps *=[\s\S]+?;/m, function(match) {
            return match
              .replace(/'Error',? */, '')
              .replace(/,(?=\s*])/, '');
          });
        }
        if (isExcluded('sortBy')) {
          _.each([removeFromGetObject, removeFromReleaseObject], function(func) {
            source = func(source, 'criteria');
            source = func(source, 'index');
            source = func(source, 'value');
          });
        }
      }

      // remove functions from the build
      allFuncs.forEach(function(funcName) {
        if (!_.contains(buildFuncs, funcName) &&
            !(funcName == 'findWhere' && !isUnderscore) &&
            !(funcName == 'lodash' && !isModularize)) {
          source = removeFunction(source, funcName);
          if (!isModularize) {
            source = removeFromCreateIterator(source, funcName);

            // remove method and alias assignments
            source = source.replace(RegExp('^(?: *//.*\\s*)* *lodash(?:\\.prototype)?\\.[$\\w]+ *= *' + funcName + ';\\n', 'gm'), '');
          }
        }
      });

      // remove forks of removed functions
      _.forOwn({
        'baseCreate': removeBaseCreateFork,
        'isArguments': removeIsArgumentsFork,
        'isArray': removeIsArrayFork,
        'isElement': removeIsElementFork,
        'isFunction': removeIsFunctionFork,
        'now': removeNowFork
      },
      function(removeFork, funcName) {
        if (isExcluded(funcName)) {
          source = removeFork(source);
        }
      });

      // remove unneeded property dependencies
      _.each(objDependencies, function(propName) {
        if (!_.contains(includeObjs, propName)) {
          source = removeProp(source, propName);
        }
      });

      // remove code used to resolve unneeded `support` properties
      source = source.replace(matchProp(source, 'support'), function(match) {
        return match.replace(/^ *\(function[\s\S]+?\n(( *)var ctor *=[\s\S]+?(?:\n *for.+)+\n)([\s\S]+?)}\(1\)\);\n/m, function(match, setup, indent, body) {
          var modified = setup;

          if (!/\.spliceObjects *=(?! *(?:false|true))/.test(body)) {
            modified = modified.replace(/^ *object *=.+\n/m, '');
          }
          if (!/\.enumPrototypes *=(?! *(?:false|true))/.test(body) &&
              !/\.nonEnumShadows *=(?! *(?:false|true))/.test(body) &&
              !/\.ownLast *=(?! *(?:false|true))/.test(body)) {
            modified = modified
              .replace(/\bctor *=.+\s+/, '')
              .replace(/^ *ctor\.prototype.+\s+.+\n/m, '')
              .replace(/(?:,\n)? *props *=[^;=]+/, '')
              .replace(/^ *for *\((?=key)/, '$&var ')
          }
          if (!/\.nonEnumArgs *=(?! *(?:false|true))/.test(body)) {
            modified = modified.replace(/^ *for *\(.+? arguments.+\n/m, '');
          }
          // cleanup the empty var statement
          modified = modified.replace(/^ *var;\n/m, '');

          // if no setup then remove IIFE
          return /^\s*$/.test(modified)
            ? body.replace(RegExp('^' + indent, 'gm'), indent.slice(0, -2))
            : match.replace(setup, modified);
        });
      });

      if (isModularize) {
        // remove unneeded variable dependencies
        _.each(varDependencies, function(varName) {
          if (!_.contains(includeFuncs, varName) &&
              !_.contains(includeObjs, varName) &&
              !_.contains(includeVars, varName)) {
            source = removeVar(source, varName);
          }
        });
      }
      // remove unused variables
      (function() {
        var isShallow = isExcluded('runInContext'),
            useMap = createMap(),
            snippet = removeStrings(removeComments(source)),
            varNames = _.difference(getVars(snippet, isShallow), includeFuncs, includeObjs, includeVars);

        while (varNames.length) {
          varNames = _.sortBy(varNames, function(varName) {
            var result = isVarUsed(snippet, varName, isShallow);
            useMap[varName] = result;
            return result;
          });

          if (useMap[varNames[0]]) {
            varNames.shift();
          }
          else {
            while (varNames.length && !useMap[varNames[0]]) {
              snippet = removeVar(snippet, varNames[0]);
              source = removeVar(source, varNames[0]);
              varNames.shift();
            }
          }
        }
      }());

      if (isModularize) {
        if (isExcluded('lodash')) {
          source = removeAssignments(source);
        }
      }
      else if (isUnderscore) {
        // unexpose `lodash.support`
        if (!isLodash('support')) {
          source = source.replace(/\blodash\.support *= */, '');
        }
      }
      if (!matchVar(source, 'root')) {
        source = removeVar(source, 'freeGlobal');
      }
    }

    /*------------------------------------------------------------------------*/

    // customize Lo-Dash's IIFE
    if (isIIFE) {
      source = (function() {
        var token = '%output%',
            header = source.match(/^\/\**[\s\S]+?\*\/\n/) || '',
            index = iife.indexOf(token);

        return header + (index < 0
          ? iife
          : iife.slice(0, index) +
            source.replace(/^[\s\S]+?\(function[^{]+\{\n+|\s*}\.call\(this\)\)[;\s]*$/g, '\n') +
            iife.slice(index + token.length)
        );
      }());
    }

    /*------------------------------------------------------------------------*/

    callback || (callback = defaultBuildCallback);
    debugSource = cleanupSource(source);
    source = debugSource;

    // expand `outputPath` and create directories if needed
    outputPath = (function() {
      if (outputPath) {
        var dirname = path.dirname(outputPath);
        fs.mkdirpSync(dirname);
        return path.join(fs.realpathSync(dirname), path.basename(outputPath));
      }
    }());

    // flag to track if `outputPath` has been used by `callback`
    var outputUsed = false;

    // flag to specify creating a custom build
    var isCustom = !isModularize && (
      isLegacy || isMapped || isModern || isStrict || isTemplate || isUnderscore || outputPath ||
      /\b(?:category|exclude|exports|iife|include|minus|moduleId|plus)=/.test(options) ||
      !_.isEqual(exportsOptions, ['amd', 'commonjs', 'global', 'node'])
    );

    // used as the basename of the output path
    var basename = outputPath
      ? path.basename(outputPath, '.js')
      : 'lodash' + (isTemplate ? '.template' : isCustom ? '.custom' : '');

    // output debug build
    if (!isMinify && (isCustom || isDebug || isTemplate)) {
      if (isCustom) {
        debugSource = addCommandsToHeader(debugSource, options);
      }
      if (isDebug && isStdOut) {
        stdout.write(debugSource);
        callback({
          'source': debugSource
        });
      }
      else if (!isStdOut) {
        filePath = outputPath || path.join(cwd, basename + '.js');
        outputUsed = true;
        callback({
          'source': debugSource,
          'outputPath': filePath
        });
      }
    }
    // begin the minification process
    if (!isDebug) {
      if (outputPath && outputUsed) {
        outputPath = path.join(path.dirname(outputPath), path.basename(outputPath, '.js') + '.min.js');
      } else if (!outputPath) {
        outputPath = path.join(cwd, basename + '.min.js');
      }
      minify(source, {
        'filePath': filePath,
        'isMapped': isMapped,
        'isSilent': isSilent,
        'isTemplate': isTemplate,
        'modes': isIIFE && ['simple', 'hybrid'],
        'outputPath': outputPath,
        'sourceMapURL': sourceMapURL,
        'onComplete': function(data) {
          if (isCustom) {
            data.source = addCommandsToHeader(data.source, options);
          }
          if (isStdOut) {
            delete data.outputPath;
            stdout.write(data.source);
          }
          callback(data);
        }
      });
    }
  }

  /*--------------------------------------------------------------------------*/

  // expose `build`
  if (module != require.main) {
    module.exports = build;
  }
  else {
    // or invoked directly
    build(process.argv);
  }
}());
