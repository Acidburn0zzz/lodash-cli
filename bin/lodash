#!/usr/bin/env node
'use strict';

/** Load Node.js modules */
var vm = require('vm');

/** Load other modules */
var _ = require('lodash/lodash.js'),
    minify = require('../lib/minify.js'),
    util = require('../lib/util.js');

/** Module references */
var fs = util.fs,
    path = util.path;

/** The current working directory */
var cwd = process.cwd();

/** Native method references */
var push = Array.prototype.push;

/** Used to create regexes that may detect multi-line comment blocks */
var multilineComment = '(?: */\\*[^*]*\\*+(?:[^/][^*]*\\*+)*/\\n)?';

/** Used to replace string literals with tokens */
var stringToken = '__lodash@' + _.VERSION + '__token__';

/** Used to determine if a variable search should be deep */
var reDeepVars = /\bfunction runInContext\b/;

/** Used to detect the JSDoc `@type` tag of "Function" */
var reFuncTag = /^ *\* *@type +Function\b/im;

/** Used to detect if a string is a function snippet */
var reFuncSnippet = /\b(?:function(?:\s+[$\w]+)?|create[A-Z][a-z]+)\(/;

/** Used to detect the Node.js executable in command-line arguments */
var reNode = RegExp('(?:^|' + path.sepEscaped + ')node(?:\\.exe)?$', 'i');

/** Used to match string literals */
var reStrings = /(["'])(?:(?!\1)[^\n\\]|\\.)*\1/g;

/** Used to match string tokens */
var reStringTokens = RegExp(stringToken.replace(/\./g, '\\$&'), 'g');

/** Shortcut to the `stdout` object */
var stdout = process.stdout;

/** Used to map aliases with their real names */
var aliasToRealMap = createMap({
  'all': 'every',
  'any': 'some',
  'collect': 'map',
  'detect': 'find',
  'each': 'forEach',
  'eachRight': 'forEachRight',
  'extend': 'assign',
  'foldl': 'reduce',
  'foldr': 'reduceRight',
  'head': 'first',
  'include': 'contains',
  'inject': 'reduce',
  'methods': 'functions',
  'object': 'zipObject',
  'select': 'filter',
  'tail': 'rest',
  'toJSON': 'wrapperValueOf',
  'unique': 'uniq',
  'value': 'wrapperValueOf'
});

/** Used to map real names with their aliases */
var realToAliasMap = createMap({
  'assign': ['extend'],
  'contains': ['include'],
  'every': ['all'],
  'filter': ['select'],
  'find': ['detect'],
  'first': ['head'],
  'forEach': ['each'],
  'forEachRight': ['eachRight'],
  'functions': ['methods'],
  'map': ['collect'],
  'reduce': ['foldl', 'inject'],
  'reduceRight': ['foldr'],
  'rest': ['tail'],
  'some': ['any'],
  'uniq': ['unique'],
  'wrapperValueOf': ['toJSON', 'value'],
  'zipObject': ['object']
});

/** Used to track function dependencies */
var funcDependencyMap = createMap({
  // objects
  'support': ['isNative'],
  'templateSettings': ['escape'],

  // public functions
  'after': ['isFunction'],
  'assign': ['baseAssign', 'createAssigner'],
  'at': ['baseAt', 'baseFlatten', 'toIterable'],
  'attempt': ['isError'],
  'before': ['isFunction'],
  'bind': ['basePartial', 'createWrapper', 'lodash', 'replaceHolders', 'slice'],
  'bindAll': ['baseBindAll', 'baseFlatten', 'functions'],
  'bindKey': ['createWrapper', 'lodash', 'replaceHolders', 'slice'],
  'callback': ['baseCallback'],
  'camelCase': ['createCompounder'],
  'capitalize': [],
  'chain': ['lodash'],
  'chunk': ['slice'],
  'clone': ['baseCallback', 'baseClone'],
  'cloneDeep': ['baseCallback', 'baseClone'],
  'compact': [],
  'compose': ['isFunction'],
  'constant': [],
  'contains': ['getIndexOf', 'isArray', 'isNative', 'isString', 'values'],
  'countBy': ['createAggregator'],
  'create': ['baseAssign', 'baseCreate'],
  'curry': ['baseCurry', 'lodash'],
  'curryRight': ['baseCurry', 'lodash'],
  'debounce': ['isFunction', 'isObject', 'now'],
  'defaults': ['assign', 'assignDefaults', 'slice'],
  'defer': ['isFunction', 'slice'],
  'delay': ['isFunction', 'slice'],
  'difference': ['baseDifference', 'baseFlatten', 'isArguments', 'isArray'],
  'drop': ['slice'],
  'dropRight': ['slice'],
  'dropRightWhile': ['getCallback', 'slice'],
  'dropWhile': ['getCallback', 'slice'],
  'endsWith': [],
  'escape': ['escapeHtmlChar'],
  'escapeRegExp': [],
  'every': ['arrayEvery', 'baseEvery', 'getCallback', 'isArray'],
  'filter': ['arrayFilter', 'baseFilter', 'getCallback', 'isArray'],
  'find': ['baseEach', 'baseFind', 'getCallback', 'findIndex', 'isArray'],
  'findIndex': ['getCallback'],
  'findLastIndex': ['getCallback'],
  'findKey': ['baseFind', 'baseForOwn', 'getCallback'],
  'findLast': ['baseEachRight', 'baseFind', 'getCallback'],
  'findLastKey': ['baseFind', 'baseForOwnRight', 'getCallback'],
  'findWhere': ['find', 'matches'],
  'first': [],
  'flatten': ['baseFlatten'],
  'flattenDeep': ['baseFlatten'],
  'forEach': ['arrayEach', 'baseCallback', 'baseEach', 'isArray'],
  'forEachRight': ['arrayEachRight', 'baseCallback', 'baseEachRight', 'isArray'],
  'forIn': ['baseCallback', 'baseFor', 'keysIn'],
  'forInRight': ['baseCallback', 'baseForRight', 'keysIn'],
  'forOwn': ['baseCallback', 'baseForOwn'],
  'forOwnRight': ['baseCallback', 'baseForRight', 'keys'],
  'functions': ['baseFunctions', 'keysIn'],
  'groupBy': ['createAggregator'],
  'has': [],
  'identity': [],
  'indexBy': ['createAggregator'],
  'indexOf': ['baseIndexOf', 'sortedIndex'],
  'initial': ['slice'],
  'intersection': ['cacheIndexOf', 'createCache', 'getIndexOf', 'isArguments', 'isArray'],
  'invert': ['keys'],
  'invoke': ['baseInvoke', 'slice'],
  'isArguments': [],
  'isArray': ['isNative'],
  'isBoolean': [],
  'isDate': [],
  'isElement': ['isNode', 'isPlainObject'],
  'isEmpty': ['isArguments', 'isArray', 'isFunction', 'isString', 'keys'],
  'isEqual': ['baseCallback', 'baseIsEqual', 'isStrictComparable'],
  'isError': [],
  'isFinite': ['isNative'],
  'isFunction': [],
  'isNaN': ['isNumber'],
  'isNull': [],
  'isNumber': [],
  'isObject': [],
  'isPlainObject': ['isArguments', 'isNative', 'shimIsPlainObject'],
  'isRegExp': ['isObject'],
  'isString': [],
  'isUndefined': [],
  'kebabCase': ['createCompounder'],
  'keys': ['isNative', 'shimKeys', 'toObject'],
  'keysIn': ['arrayEach', 'isArguments', 'isArray', 'isString', 'toObject'],
  'last': [],
  'lastIndexOf': ['sortedLastIndex'],
  'lodash': ['isArray', 'lodashWrapper'],
  'map': ['arrayMap', 'baseMap', 'getCallback', 'isArray'],
  'mapValues': ['baseForOwn', 'getCallback'],
  'matches': ['baseClone', 'baseIsEqual', 'isStrictComparable', 'keys'],
  'max': ['baseEach', 'charAtCallback', 'getCallback', 'isArray', 'isString', 'toIterable'],
  'memoize': ['isFunction'],
  'merge': ['baseMerge', 'createAssigner'],
  'min': ['baseEach', 'charAtCallback', 'getCallback', 'isArray', 'isString', 'toIterable'],
  'mixin': ['baseFunctions', 'isFunction', 'isObject', 'keys', 'lodash'],
  'negate': ['isFunction'],
  'noConflict': [],
  'noop': [],
  'now': ['isNative'],
  'omit': ['baseDifference', 'baseFlatten', 'basePick', 'arrayMap', 'getCallback', 'keysIn', 'negate', 'toObject'],
  'once': ['before', 'partial'],
  'pad': ['createPad'],
  'padLeft': ['createPad'],
  'padRight': ['createPad'],
  'pairs': ['keys'],
  'parseInt': ['trim'],
  'partial': ['basePartial', 'lodash', 'replaceHolders', 'slice'],
  'partialRight': ['basePartial', 'lodash', 'replaceHolders', 'slice'],
  'partition': ['createAggregator'],
  'pick': ['baseFlatten', 'basePick', 'getCallback', 'toObject'],
  'pluck': ['map', 'property'],
  'property': [],
  'pull': [],
  'pullAt': ['baseFlatten', 'basePullAt'],
  'random': ['baseRandom'],
  'range': [],
  'reduce': ['arrayReduce', 'baseEach', 'baseReduce', 'getCallback', 'isArray'],
  'reduceRight': ['arrayReduceRight', 'baseEachRight', 'baseReduce', 'getCallback', 'isArray'],
  'reject': ['getCallback', 'filter', 'negate'],
  'remove': ['getCallback'],
  'repeat': [],
  'rest': ['slice'],
  'result': ['isFunction'],
  'runInContext': ['defaults', 'pick'],
  'sample': ['baseRandom', 'shuffle', 'toIterable'],
  'shuffle': ['baseRandom', 'toIterable'],
  'size': ['keys'],
  'slice': [],
  'snakeCase': ['createCompounder'],
  'some': ['arraySome', 'baseSome', 'getCallback', 'isArray'],
  'sortBy': ['baseEach', 'compareAscending', 'compareMultipleAscending', 'getCallback', 'isArray'],
  'sortedIndex': ['baseSortedIndex', 'getCallback', 'identity'],
  'sortedLastIndex': ['baseSortedIndex', 'getCallback', 'identity'],
  'startsWith': [],
  'take': ['slice'],
  'takeRight': ['slice'],
  'takeRightWhile': ['getCallback', 'slice'],
  'takeWhile': ['getCallback', 'slice'],
  'tap': [],
  'template': ['assign', 'assignOwnDefaults', 'attempt', 'escape', 'escapeStringChar', 'isError', 'keys', 'values'],
  'throttle': ['debounce', 'isFunction', 'isObject'],
  'times': ['baseCallback'],
  'toArray': ['isString', 'slice', 'values'],
  'transform': ['arrayEach', 'baseCreate', 'baseForOwn', 'getCallback', 'isArrayLike', 'isObject'],
  'trim': ['charsLeftIndex', 'charsRightIndex', 'trimmedLeftIndex', 'trimmedRightIndex'],
  'trimLeft': ['charsLeftIndex', 'trimmedLeftIndex'],
  'trimRight': ['charsRightIndex', 'trimmedRightIndex'],
  'trunc': ['isObject', 'isRegExp'],
  'unescape': ['unescapeHtmlChar'],
  'union': ['baseFlatten', 'baseUniq'],
  'uniq': ['baseUniq', 'getCallback', 'getIndexOf', 'sortedUniq'],
  'uniqueId': [],
  'unzip': ['isObject', 'max', 'pluck'],
  'values': ['baseValues', 'keys'],
  'valuesIn': ['baseValues', 'keysIn'],
  'where': ['filter', 'matches'],
  'without': ['baseDifference', 'slice'],
  'wrap': ['basePartial'],
  'wrapperChain': [],
  'wrapperToString': [],
  'wrapperValueOf': [],
  'xor': ['baseDifference', 'baseUniq', 'isArguments', 'isArray'],
  'zip': ['unzip'],
  'zipObject': ['isArray'],

  // private functions
  'arrayEach': [],
  'arrayEachRight': [],
  'arrayEvery': [],
  'arrayFilter': [],
  'arrayMap': [],
  'arrayReduce': [],
  'arrayReduceRight': [],
  'arraySome': [],
  'assignDefaults': [],
  'assignOwnDefaults': [],
  'baseAt': [],
  'baseAssign': ['keys'],
  'baseBindAll': ['createWrapper'],
  'baseCallback': ['identity', 'isNative', 'matches', 'property', 'setData'],
  'baseClone': ['arrayEach', 'baseAssign', 'baseForOwn', 'cloneBuffer', 'isArguments', 'isArray', 'isFunction', 'isObject', 'isNode', 'slice'],
  'baseCompareAscending': [],
  'baseCreate': ['isNative', 'isObject'],
  'baseCreateWrapper': ['composeArgs', 'composeArgsRight', 'createBindWrapper', 'createCtorWrapper', 'createPartialWrapper', 'replaceHolders', 'setData'],
  'baseCurry': ['createWrapper'],
  'baseDifference': ['cacheIndexOf', 'createCache', 'getIndexOf'],
  'baseEach': ['baseForOwn', 'toIterable'],
  'baseEachRight': ['baseForOwnRight', 'toIterable'],
  'baseEvery': ['baseEach'],
  'baseFilter': ['baseEach'],
  'baseFind': [],
  'baseFlatten': ['isArguments', 'isArray'],
  'baseFor': [],
  'baseForIn': ['baseFor', 'keysIn'],
  'baseForOwn': ['baseFor', 'keys'],
  'baseForOwnRight': ['baseForRight', 'keys'],
  'baseForRight': [],
  'baseFunctions': ['isFunction'],
  'baseIndexOf': [],
  'baseInvoke': ['baseEach'],
  'baseIsEqual': ['isArguments', 'isFunction', 'isNode', 'keys'],
  'baseMap': ['baseEach'],
  'baseMerge': ['arrayEach', 'baseForOwn', 'isArray', 'isArrayLike', 'isPlainObject'],
  'basePartial': ['createWrapper'],
  'basePick': ['baseForIn'],
  'basePullAt': ['baseAt', 'baseCompareAscending'],
  'baseRandom': [],
  'baseReduce': [],
  'baseSome': ['baseEach'],
  'baseSortedIndex': ['isFunction'],
  'baseUniq': ['cacheIndexOf', 'createCache', 'getIndexOf'],
  'baseValues': [],
  'cacheIndexOf': [],
  'charAtCallback': [],
  'charsLeftIndex': [],
  'charsRightIndex': [],
  'cloneBuffer': ['identity', 'isNative'],
  'compareAscending': ['baseCompareAscending'],
  'compareMultipleAscending': ['baseCompareAscending'],
  'composeArgs': [],
  'composeArgsRight': [],
  'createAggregator': ['baseEach', 'getCallback', 'isArray'],
  'createAssigner': ['baseCallback'],
  'createBindWrapper': ['createCtorWrapper'],
  'createCtorWrapper': ['baseCreate', 'isObject'],
  'createPartialWrapper': ['createCtorWrapper'],
  'createWrapper': ['baseCreateWrapper', 'composeArgs', 'composeArgsRight', 'isFunction', 'replaceHolders', 'slice'],
  'createCache': ['isNative'],
  'createCompounder': ['deburrLetter'],
  'createPad': ['repeat'],
  'deburrLetter': [],
  'escapeHtmlChar': [],
  'escapeStringChar': [],
  'getCallback': ['baseCallback', 'callback'],
  'getIndexOf': ['baseIndexOf', 'indexOf'],
  'isArrayLike': [],
  'isNative': ['escapeRegExp'],
  'isNode': [],
  'isStrictComparable': ['isObject'],
  'isWhitespace': [],
  'lodashWrapper': [],
  'replaceHolders': [],
  'setData': ['identity', 'isNative'],
  'shimIsPlainObject': ['baseForIn', 'isArguments', 'isFunction', 'isNode'],
  'shimKeys': ['isArguments', 'isArray', 'isString', 'keysIn'],
  'sortedUniq': [],
  'toIterable': ['isString', 'toObject', 'values'],
  'toObject': ['isObject'],
  'trimmedLeftIndex': ['isWhitespace'],
  'trimmedRightIndex': ['isWhitespace'],
  'unescapeHtmlChar': []
});

/** Used to track Lo-Dash object dependencies of identifiers */
var objDependencyMap = createMap({
  'baseCallback': ['support'],
  'baseClone': ['support'],
  'baseIsEqual': ['support'],
  'isArguments': ['support'],
  'isElement': ['support'],
  'isPlainObject': ['support'],
  'keys': ['support'],
  'keysIn': ['support'],
  'shimIsPlainObject': ['support'],
  'shimKeys': ['support'],
  'template': ['templateSettings'],
  'toArray': ['support'],
  'toIterable': ['support']
});

/** Used to track variable dependencies of identifiers */
var varDependencyMap = createMap({
  'after': ['root'],
  'baseClone': ['root'],
  'baseCreate': ['root'],
  'cloneBuffer': ['root'],
  'createCache': ['root'],
  'createPad': ['root'],
  'isFinite': ['root'],
  'pad': ['root'],
  'parseInt': ['root'],
  'repeat': ['root'],
  'support': ['root'],
  'template': ['reInterpolate'],
  'templateSettings': ['reEscape', 'reEvaluate', 'reInterpolate'],
  'times': ['root']
});

/** Used to track the category of identifiers */
var categoryMap = createMap({
  'Array': [
    'chunk',
    'compact',
    'difference',
    'drop',
    'dropRight',
    'dropRightWhile',
    'dropWhile',
    'findIndex',
    'findLastIndex',
    'first',
    'flatten',
    'flattenDeep',
    'indexOf',
    'initial',
    'intersection',
    'last',
    'lastIndexOf',
    'pull',
    'pullAt',
    'remove',
    'rest',
    'slice',
    'sortedIndex',
    'sortedLastIndex',
    'take',
    'takeRight',
    'takeRightWhile',
    'takeWhile',
    'union',
    'uniq',
    'unzip',
    'without',
    'xor',
    'zip',
    'zipObject'
  ],
  'Chain': [
    'chain',
    'lodash',
    'tap',
    'wrapperChain',
    'wrapperToString',
    'wrapperValueOf'
  ],
  'Collection': [
    'at',
    'contains',
    'countBy',
    'every',
    'filter',
    'find',
    'findLast',
    'findWhere',
    'forEach',
    'forEachRight',
    'groupBy',
    'indexBy',
    'invoke',
    'map',
    'max',
    'min',
    'partition',
    'pluck',
    'reduce',
    'reduceRight',
    'reject',
    'sample',
    'shuffle',
    'size',
    'some',
    'sortBy',
    'toArray',
    'where'
  ],
  'Function': [
    'after',
    'before',
    'bind',
    'bindAll',
    'bindKey',
    'compose',
    'curry',
    'curryRight',
    'debounce',
    'defer',
    'delay',
    'memoize',
    'negate',
    'once',
    'partial',
    'partialRight',
    'throttle',
    'wrap'
  ],
  'Object': [
    'assign',
    'clone',
    'cloneDeep',
    'create',
    'defaults',
    'findKey',
    'findLastKey',
    'forIn',
    'forInRight',
    'forOwn',
    'forOwnRight',
    'functions',
    'has',
    'invert',
    'isArguments',
    'isArray',
    'isBoolean',
    'isDate',
    'isElement',
    'isEmpty',
    'isEqual',
    'isError',
    'isFinite',
    'isFunction',
    'isNaN',
    'isNull',
    'isNumber',
    'isObject',
    'isPlainObject',
    'isRegExp',
    'isString',
    'isUndefined',
    'keys',
    'keysIn',
    'mapValues',
    'merge',
    'omit',
    'pairs',
    'pick',
    'transform',
    'values',
    'valuesIn'
  ],
  'String': [
    'camelCase',
    'capitalize',
    'endsWith',
    'escape',
    'escapeRegExp',
    'kebabCase',
    'pad',
    'padLeft',
    'padRight',
    'repeat',
    'snakeCase',
    'startsWith',
    'template',
    'templateSettings',
    'trim',
    'trimLeft',
    'trimRight',
    'trunc',
    'unescape'
  ],
  'Utility': [
    'attempt',
    'callback',
    'constant',
    'identity',
    'matches',
    'mixin',
    'noConflict',
    'noop',
    'now',
    'parseInt',
    'property',
    'random',
    'range',
    'result',
    'runInContext',
    'times',
    'uniqueId'
  ]
});

/* Used to map categories with their plural form */
var categoryToPluralMap = createMap({
  'Array': 'Arrays',
  'Chain': 'Chaining',
  'Collection': 'Collections',
  'Function': 'Functions',
  'Object': 'Objects',
  'String': 'Strings',
  'Utility': 'Utilities'
});

/* Used to enforce dependencies at the top level */
var topLevel = createMap({
  'main': true,
  'support': true
});

/** List of Backbone's Lo-Dash dependencies */
var backboneDependencies = [
  'bind',
  'bindAll',
  'chain',
  'clone',
  'contains',
  'countBy',
  'defaults',
  'difference',
  'escape',
  'every',
  'extend',
  'filter',
  'find',
  'first',
  'forEach',
  'groupBy',
  'has',
  'indexBy',
  'indexOf',
  'initial',
  'invert',
  'invoke',
  'isArray',
  'isEmpty',
  'isEqual',
  'isFunction',
  'isObject',
  'isRegExp',
  'isString',
  'keys',
  'last',
  'lastIndexOf',
  'lodash',
  'map',
  'max',
  'min',
  'mixin',
  'omit',
  'once',
  'pairs',
  'pick',
  'reduce',
  'reduceRight',
  'reject',
  'rest',
  'result',
  'sample',
  'shuffle',
  'size',
  'some',
  'sortBy',
  'sortedIndex',
  'toArray',
  'uniqueId',
  'value',
  'values',
  'without',
  'wrapperChain',
  'wrapperValueOf'
];

/** List of all function categories */
var allCategories = _.keys(categoryMap);

/** List of the default ways to export the `lodash` function */
var defaultExports = [
  'amd',
  'commonjs',
  'global',
  'node'
];

/** List of variables with complex assignments */
var complexVars = [
  'arrayLikeClasses',
  'cloneableClasses',
  'contextProps',
  'ctorByClass',
  'defineProperty',
  'freeGlobal',
  'nonEnumProps',
  'shadowedProps',
  'support',
  'whitespace'
];

/** List of Lo-Dash only functions */
var lodashOnlyFuncs = [
  'at',
  'attempt',
  'before',
  'bindKey',
  'callback',
  'camelCase',
  'capitalize',
  'chunk',
  'cloneDeep',
  'create',
  'curry',
  'curryRight',
  'dropRight',
  'dropRightWhile',
  'dropWhile',
  'endsWith',
  'escapeRegExp',
  'findIndex',
  'findKey',
  'findLast',
  'findLastIndex',
  'findLastKey',
  'flattenDeep',
  'forEachRight',
  'forIn',
  'forInRight',
  'forOwn',
  'forOwnRight',
  'isError',
  'isPlainObject',
  'kebabCase',
  'keysIn',
  'mapValues',
  'merge',
  'negate',
  'noop',
  'pad',
  'padLeft',
  'padRight',
  'parseInt',
  'partialRight',
  'pull',
  'pullAt',
  'remove',
  'repeat',
  'runInContext',
  'slice',
  'snakeCase',
  'sortedLastIndex',
  'startsWith',
  'takeRight',
  'takeRightWhile',
  'takeWhile',
  'transform',
  'trunc',
  'trim',
  'trimLeft',
  'trimRight',
  'unzip',
  'valuesIn',
  'wrapperToString',
  'xor'
];

/** List of private functions */
var privateFuncs = [
  'arrayEach',
  'arrayEachRight',
  'arrayEvery',
  'arrayFilter',
  'arrayMap',
  'arrayReduce',
  'arrayReduceRight',
  'arraySome',
  'assignDefaults',
  'assignOwnDefaults',
  'baseAssign',
  'baseAt',
  'baseBindAll',
  'baseCallback',
  'baseClone',
  'baseCompareAscending',
  'baseCreate',
  'baseCreateWrapper',
  'baseCurry',
  'baseDifference',
  'baseEach',
  'baseEvery',
  'baseFilter',
  'baseFind',
  'baseFlatten',
  'baseFor',
  'baseForIn',
  'baseForOwn',
  'baseForOwnRight',
  'baseForRight',
  'baseFunctions',
  'baseIndexOf',
  'baseInvoke',
  'baseIsEqual',
  'baseMerge',
  'basePartial',
  'basePick',
  'basePullAt',
  'baseRandom',
  'baseReduce',
  'baseSome',
  'baseSortedIndex',
  'baseUniq',
  'baseValues',
  'cacheIndexOf',
  'charAtCallback',
  'charsLeftIndex',
  'charsRightIndex',
  'cloneBuffer',
  'compareAscending',
  'compareMultipleAscending',
  'composeArgs',
  'composeArgsRight',
  'createAggregator',
  'createAssigner',
  'createBindWrapper',
  'createCache',
  'createCompounder',
  'createPad',
  'createPartialWrapper',
  'createWrapper',
  'deburrLetter',
  'escapeHtmlChar',
  'escapeStringChar',
  'getCallback',
  'getIndexOf',
  'isArrayLike',
  'isNative',
  'isNode',
  'isStrictComparable',
  'isWhitespace',
  'lodashWrapper',
  'replaceHolders',
  'setData',
  'shimIsPlainObject',
  'shimKeys',
  'sortedUniq',
  'toIterable',
  'toObject',
  'trimmedLeftIndex',
  'trimmedRightIndex',
  'unescapeHtmlChar'
];

/** List of all property dependencies */
var objDependencies = _.uniq(_.transform(objDependencyMap, _.bind(push.apply, push), []));

/** List of all variable dependencies */
var varDependencies = _.uniq(_.transform(varDependencyMap, _.bind(push.apply, push), []));

/** List of all functions */
var allFuncs = _.filter(_.difference(_.keys(funcDependencyMap), objDependencies, varDependencies), function(key) {
  var type = typeof _[key];
  return type == 'function' || type == 'undefined';
});

/** List of Lo-Dash functions */
var lodashFuncs = _.difference(allFuncs, privateFuncs);

/** List of Underscore functions */
var underscoreFuncs = _.difference(allFuncs, lodashOnlyFuncs, privateFuncs);

/*----------------------------------------------------------------------------*/

/**
 * Adds build `commands` to the copyright/license header of `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @param {Array} [commands=[]] An array of commands.
 * @returns {string} Returns the modified source.
 */
function addCommandsToHeader(source, commands) {
  return source.replace(getHeader(source), function(header) {
    // remove `node path/to/build.js` from `commands`
    if (reNode.test(commands[0])) {
      commands.splice(0, 2);
    }
    // add quotes to commands with spaces or equals signs
    commands = _.map(commands, function(command) {
      var separator = command.match(/[= ]/);
      if (separator) {
        separator = separator[0];
        var pair = command.split(separator);
        command = pair[0] + separator + '"' + pair[1] + '"';
      }
      // escape newlines, carriage returns, multi-line comment end tokens
      command = command
        .replace(/\n/g, '\\n')
        .replace(/\r/g, '\\r')
        .replace(/\*\//g, '*\\/');

      return command;
    });

    // add build commands to copyright/license header
    return header.replace(/(\/\**\n)( \*)( *@license[\s*]+)?( *Lo-Dash [.$\w\-]+)(.*)/, function() {
      return (
        arguments[1] +
        arguments[2] +
        (arguments[3] || '') +
        arguments[4] + ' (Custom Build)' + arguments[5] + '\n' +
        arguments[2] + ' Build: `lodash ' + commands.join(' ') + '`'
      );
    });
  });
}

/**
 * Adds support for Underscore style chaining to `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @param {Object} [funcDepMap] The dependency map to modify.
 * @param {boolean} [isModularize=false] A flag to specify a modularize build
 * @returns {string} Returns the modified source.
 */
function addUnderscoreChaining(source, funcDepMap, isModularize) {
  var deps = _.result(funcDepMap, 'mixin', []);
  _.pull(deps, 'baseFunctions', 'isObject', 'keys').push('functions');

  if (!isModularize) {
    _.pull(deps, 'isFunction');
  }
  // replace `_.mixin`
  source = replaceFunction(source, 'mixin', (isModularize
    ? [
        'function mixin(object, source) {',
        '  if (!source) {',
        '    source = object;',
        '    object = lodash;',
        '  }',
        '  var index = -1,',
        '      isFunc = isFunction(object),',
        '      methodNames = functions(source),',
        '      length = methodNames.length;',
        '',
        '  while (++index < length) {',
        '    var methodName = methodNames[index],',
        '        func = object[methodName] = source[methodName];',
        '',
        '    if (isFunc) {',
        '      object.prototype[methodName] = (function(func) {',
        '        return function() {',
        '          var args = [this.__wrapped__];',
        '          push.apply(args, arguments);',
        '',
        '          var result = func.apply(object, args);',
        '          if (this.__chain__) {',
        '            result = new object(result);',
        '            result.__chain__ = true;',
        '          }',
        '          return result;',
        '        };',
        '      }(func));',
        '    }',
        '  }',
        '}'
      ]
    : [
        'function mixin(source) {',
        '  var index = -1,',
        '      methodNames = functions(source),',
        '      length = methodNames.length;',
        '',
        '  while (++index < length) {',
        '    var methodName = methodNames[index];',
        '    lodash.prototype[methodName] = (function() {',
        '      var func = lodash[methodName] = source[methodName];',
        '      return function() {',
        '        var args = [this.__wrapped__];',
        '        push.apply(args, arguments);',
        '',
        '        var result = func.apply(lodash, args);',
        '        return this.__chain__',
        '          ? new lodashWrapper(result, true)',
        '          : result;',
        '      };',
        '    }());',
        '  }',
        '}'
      ]
  ).join('\n'));

  // move `mixin(...)` before `_.VERSION`
  source = source.replace(getMethodAssignments(source), function(match) {
    match = removeMixinCalls(match);
    return match.replace(/^(?: *\/\*[^*]*\*+(?:[^\/][^*]*\*+)*\/\n)?( *)lodash\.VERSION\b/m, function(match, indent) {
      return indent + [
        '// add functions to `lodash.prototype`',
        'mixin(assign({}, lodash));',
      ].join('\n' + indent) +
      '\n\n' + match
    });
  });

  // replace wrapper `Array` method assignments
  source = source.replace(/^(?:(?: *\/\/.*\n)*( *)(?:if\s*\([^{]+\{\n\1( *))?arrayEach\(\['[\s\S]+?\n\1\2}\);(?:\n\1})?\n+)+/m, function(match, indent) {
    return indent + [
      '// add `Array` mutator functions to the wrapper',
      "arrayEach(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(methodName) {",
      '  var func = arrayProto[methodName];',
      '  lodash.prototype[methodName] = function() {',
      '    var value = this.__wrapped__;',
      '    func.apply(value, arguments);',
      '',
      '    // avoid array-like object bugs with `Array#shift` and `Array#splice`',
      '    // in Firefox < 10 and IE < 9',
      '    if (!support.spliceObjects && value.length === 0) {',
      '      delete value[0];',
      '    }',
      '    return this;',
      '  };',
      '});',
      '',
      '// add `Array` accessor functions to the wrapper',
      "arrayEach(['concat', 'join', 'slice'], function(methodName) {",
      '  var func = arrayProto[methodName];',
      '  lodash.prototype[methodName] = function() {',
      '    var value = this.__wrapped__,',
      '        result = func.apply(value, arguments);',
      '',
      '    if (this.__chain__) {',
      '      result = new lodashWrapper(result);',
      '      result.__chain__ = true;',
      '    }',
      '    return result;',
      '  };',
      '});',
      ''
    ].join('\n' + indent);
  });

  // remove `lodash.prototype` methods assignments for `toJSON`, `toString`, and `valueOf`
  source = source.replace(/^ *lodash\.prototype\.(?:toJSON|toString|valueOf)\s*=.+\n/gm, '');

  // remove `lodash.prototype` batch method assignments
  return source.replace(/^(?: *\/\/.*\n)*( *)baseForOwn\(lodash,[\s\S]+?\n\1}.+\n/gm, '');
}

/**
 * Creates modules based on the provided build state.
 *
 * @private
 * @param {Object} state The build state object.
 * @param {Function} [onComplete] The function called when all module builds
 *  are completed.
 */
function buildModule(state, onComplete) {
  var buildFuncs = state.buildFuncs,
      funcDepMap = state.funcDepMap,
      includeObjs = state.includeObjs,
      includeVars = state.includeVars,
      isAMD = state.isAMD,
      isCommonJS = state.isCommonJS,
      isES6 = state.isES6,
      isNode = state.isNode,
      isNpm = state.isNpm,
      isSilent = state.isSilent,
      isUnderscore = state.isUnderscore,
      objDepMap = state.objDepMap,
      outputPath = state.outputPath,
      varDepMap = state.varDepMap;

  var templatePath = fs.realpathSync(path.join(__dirname, '..', 'template')),
      licenseTemplate = fs.readFileSync(path.join(templatePath, 'license.jst'), 'utf-8'),
      packageTemplate = fs.readFileSync(path.join(templatePath, 'package.jst'), 'utf-8'),
      readmeTemplate = fs.readFileSync(path.join(templatePath, 'readme.jst'), 'utf-8');

  var identifiers = _.without(_.union(buildFuncs, includeObjs, includeVars), 'main'),
      removedDeps = {},
      version = state.lodash.VERSION;

  var buildCallback = function(data) {
    var source = data.source;
    source = addCommandsToHeader(source, state.options);
    data.source = cleanupSource(source);
    defaultBuildCallback(data);
  };

  var getInlinees = function(identifier, result) {
    var privateDeps = _.filter(funcDepMap[identifier], isPrivate);
    result || (result = []);

    _.each(privateDeps, function(funcName) {
      var dependants = getDependants(funcName, funcDepMap, true);

      // only inline functions if they have one dependent or all dependants are inlined
      if (!(_.size(dependants) == 1 || _.isEmpty(_.difference(dependants, result)))) {
        return;
      }
      result.push(funcName);

      // inline object and variable dependencies if all dependants are inlined
      _.each([objDepMap, varDepMap], function(depMap, index) {
        _.each(depMap[funcName], function(depName) {
          var dependants = getDependants(depName, depMap, true);
          if (_.isEmpty(_.difference(dependants, result))) {
            result.push(depName);
          }
        });
      });

      getInlinees(funcName, result);
    });

    return result;
  };

  var getUnusedDeps = function(source, depNames) {
    source = cleanupSource(removeStrings(removeComments(source)));
    return _.reject(depNames, function(depName) {
      return RegExp('\\b' + depName + '\\b').test(source);
    });
  };

  // create map of private identifiers to be inlined
  var inlineMap = _.transform(_.difference(buildFuncs, privateFuncs), function(result, funcName) {
    var inlinees = getInlinees(funcName);
    if (!_.isEmpty(inlinees)) {
      result[funcName] = inlinees;
    }
  }, createMap());

  // exclude `_.noConflict` when exporting for npm
  if (isNpm) {
    identifiers = _.without(identifiers, 'noConflict');
  }
  // create modules for each identifier
  _.each(identifiers, function(identifier) {
    var categories = getCategories(identifier, funcDepMap);
    if (_.isEmpty(categories)) {
      categories.push(null);
    }
    _.each(isNpm ? categories.slice(0, 1) : categories, function(category) {
      var isInternal = isPrivate(identifier),
          moduleName = isNpm ? 'lodash.' + (isInternal ? '_' : '') + identifier.toLowerCase() : identifier,
          modulePath = isNpm ? moduleName : getModulePath(identifier, category, funcDepMap);

      var inlinees = [identifier];
      push.apply(inlinees, inlineMap[identifier]);

      var inlineFuncs = _.intersection(allFuncs, inlinees),
          inlineObjs = _.intersection(includeObjs, inlinees),
          inlineVars = _.intersection(includeVars, inlinees);

      var depNames = _.difference(_.reduce(inlinees, function(result, identifier) {
        return _.union(result,
          getDependencies(identifier, funcDepMap, true),
          objDepMap[identifier],
          varDepMap[identifier]
        );
      }, []), inlinees);

      depNames.sort();

      state.outputPath = path.join(outputPath, modulePath, (isNpm ? 'index' : identifier) + '.js');
      state.buildFuncs = state.includeFuncs = inlineFuncs;
      state.includeObjs = inlineObjs;
      state.includeVars = inlineVars;

      build(state, function(data) {
        var iife = [],
            source = data.source,
            unusedDeps = getUnusedDeps(source, depNames);

        depNames = _.difference(depNames, unusedDeps);
        removedDeps[identifier] = unusedDeps;

        var depPaths = isNpm
          ? _.map(depNames, function(depName) { return 'lodash.' + (isPrivate(depName) ? '_' : '') + depName.toLowerCase(); })
          : getDepPaths(depNames, modulePath, funcDepMap);

        if (isAMD) {
          iife.push(
            'define([' + (_.isEmpty(depPaths) ? '' : "'" + depPaths.join("', '") + "'") + '], function(' + depNames.join(', ') + ') {',
            '%output%',
            '  return ' + identifier + ';',
            '});'
          );
        }
        else if (isES6) {
          iife.push(
            _.reduce(depPaths, function(result, depPath, index) {
              var depName = depNames[index];
              return result + (result ? ';\n' : '') +
                'import ' + depName + " from '" + depPath + "'";
            }, '') + ';',
            '%output%',
            'export default ' + identifier + ';'
          );
        }
        else {
          iife.push(
            _.reduce(depPaths, function(result, depPath, index) {
              var depName = depNames[index];
              return result + (result ? ',\n    ' : 'var ') +
                depName + " = require('" + depPath + "')" +
                (isCommonJS ? '.' + depName : '');
            }, '') + ';',
            '%output%',
            (isCommonJS ? 'exports.' + identifier : 'module.exports') + ' = ' + identifier + ';'
          );
        }
        if (isNpm) {
          var keywords = isInternal
            ? []
            : ['functional', 'lodash', 'lodash-modularized', 'server', 'util'];

          var type = _.contains(objDependencies, identifier)
            ? 'object'
            : (_.contains(varDependencies, identifier) ? 'variable' : 'function');

          var moduleDesc = 'The ' +
            (isInternal ? 'internal ' : '') +
            'Lo-Dash ' + type + ' `' + (isInternal ? '' : '_.') +
            identifier + '` as a Node.js module generated by lodash-cli.';

          var markdownDesc = moduleDesc
            .replace('Lo-Dash', '[Lo-Dash](http://lodash.com/)')
            .replace('Node.js', '[Node.js](http://nodejs.org/)')
            .replace('lodash-cli', '[lodash-cli](https://npmjs.org/package/lodash-cli)')
            .replace(/`_\.([$\w]+)`/, '[$&](http://lodash.com/docs#$1)');

          var templateData = {
            'name': moduleName,
            'version': version,
            'description': moduleDesc,
            'keywords': keywords,
            'dependencies': _.transform(depPaths, function(result, depPath) {
              result[depPath] = '~' + version;
            }, {})
          };

          fs.writeFileSync(path.join(outputPath, modulePath, 'package.json'), _.template(packageTemplate)(templateData), 'utf-8');
          fs.writeFileSync(path.join(outputPath, modulePath, 'LICENSE.txt'), _.template(licenseTemplate)(templateData), 'utf-8');
          fs.writeFileSync(path.join(outputPath, modulePath, 'README.md'), _.template(readmeTemplate)(_.defaults({ 'description': markdownDesc }, templateData)), 'utf-8');
        }
        if (!isAMD) {
          source = trimIndent(source);
        }
        source = removeLicenseTag(source);
        source = replaceIIFE(source, iife.join('\n'));

        data.source = source;
        buildCallback(data);
      });
    });
  });

  // create main module
  (function() {
    if (isNpm || !_.contains(buildFuncs, 'lodash')) {
      return;
    }
    var basename = 'lodash',
        modulePath = getModulePath('main', funcDepMap);

    var categories = _.uniq(_.compact(_.map(identifiers, function(identifier) {
      return _.first(getCategories(identifier, funcDepMap));
    }))).sort();

    var categoryDeps = _.map(categories, function(category) {
      return categoryToPluralMap[category].toLowerCase();
    });

    var categoryDepPaths = _.map(categories, function(category) {
      return './' + category.toLowerCase();
    });

    var deps = getDependencies('main', funcDepMap, true)
      .concat(objDepMap.main || [])
      .concat(varDepMap.main || [])
      .sort();

    if (isAMD) {
      basename = 'main';
    }
    else if (!isES6) {
      basename = 'index';
    }
    state.buildFuncs = state.includeFuncs = ['main'];
    state.includeObjs = state.includeVars = [];
    state.outputPath = path.join(outputPath, modulePath, basename + '.js');

    build(state, function(data) {
      var source = data.source;

      // remove unneeded method and alias assignments
      _.each(_.difference(allFuncs, buildFuncs), function(funcName) {
        source = removeMethodAssignment(source, funcName);
      });

      // wrap `_.mixin`
      source = source.replace(/^(?: *\/\/.*\n)* *lodash\.[$\w]+\s*=[^;]+;\n/m, function(match) {
        var code = [
          '  // wrap `_.mixin` so it works when provided only one argument',
          '  mixin = (function(func) {'
        ];

        if (isUnderscore) {
          code.push(
            '    return function(object, source) {',
            '      if (!source) {',
            '        source = object;',
            '        object = lodash;',
            '      }',
            '      return func(object, source);'
          );
        } else {
          code.push(
            '    return function(object, source, options) {',
            '      if (!source || (!options && !baseFunctions(source, keys).length)) {',
            '        if (options == null) {',
            '          options = source;',
            '        }',
            '        source = object;',
            '        object = this;',
            '      }',
            '      return func(object, source, options);'
          );
        }
        code.push(
          '    };',
          '  }(mixin));',
          '',
          match
        );

        return code.join('\n');
      });

      // add `lodash.support` and `lodash.templateSettings` assignment
      source = source.replace(/^ *lodash\.VERSION\b.+\n/m, function(match) {
        var code = [
          '',
          '  lodash.support = support;'
        ];

        if (_.contains(identifiers, 'templateSettings')) {
          code.push('  (lodash.templateSettings = strings.templateSettings).imports._ = lodash;');
        }
        code.push('');
        return match + code.join('\n');
      });

      // add category namespaces to each lodash function assignment
      source = source.replace(/(lodash(?:\.prototype)?\.[$\w]+\s*=\s*)([$\w]+)/g, function(match, prelude, identifier) {
        if (_.contains(deps, identifier)) {
          return match;
        }
        var category = categoryToPluralMap[_.first(getCategories(identifier, funcDepMap))];
        return prelude + (category ? category.toLowerCase() + '.' : '') + identifier;
      });

      var unusedDeps = getUnusedDeps(source, deps);
      deps = _.difference(deps, unusedDeps);
      removedDeps.main = unusedDeps;

      var iife = [],
          depNames = categoryDeps.concat(deps),
          depArgs = depNames.join(', '),
          depPaths = categoryDepPaths.concat(getDepPaths(deps, modulePath, funcDepMap));

      if (isAMD) {
        iife.push(
          'define([' + (_.isEmpty(depPaths) ? '' : "'" + depPaths.join("', '") + "'") + '], function(' + depArgs + ') {',
          '%output%',
          '  return lodash;',
          '});'
        );
      }
      else if (isES6) {
        iife.push(
          _.reduce(depPaths, function(result, depPath, index) {
            var depName = depNames[index];
            return result + (result ? ';\n' : '') +
              'import ' + depName + " from '" + depPath + "'";
          }, '') + ';',
          '%output%',
          'export default lodash;'
        );
      }
      else {
        iife.push(
          _.reduce(depPaths, function(result, depPath, index) {
            var depName = depNames[index];
            return result + (result ? ',\n    ' : 'var ') +
              depName + " = require('" + depPath + "')" +
              (isCommonJS && !_.contains(categoryDepPaths, depPath) ? '.' + depName : '');
          }, '') + ';',
          '%output%',
          (isCommonJS ? 'exports._' : 'module.exports') + ' = lodash;'
        );
      }
      if (!isAMD) {
        source = trimIndent(source);
      }
      source = replaceIIFE(source, iife.join('\n'));

      data.source = source;
      buildCallback(data);
    });
  }());

  // create category modules
  (function() {
    if (isNpm) {
      return;
    }
    var categories = _.uniq(_.compact(_.flatten(_.map(identifiers, _.partial(getCategories, _, funcDepMap)))));

    _.each(categories, function(category) {
      state.buildFuncs = state.includeFuncs = state.includeObjs = state.includeVars = [];
      state.outputPath = path.join(outputPath, category.toLowerCase() + '.js');

      build(state, function(data) {
        var iife = [],
            source = data.source;

        var depNames = _.intersection(getNamesByCategory(category), identifiers).sort(),
            depPaths = getDepPaths(depNames, null, funcDepMap);

        var exportNames = _.transform(depNames, function(result, depName) {
          result.push(depName);
          push.apply(result, getAliases(depName, funcDepMap));
        })
        .sort();

        if (isAMD) {
          iife.push(
            "define(['" + depPaths.join("', '") + "'], function(" + depNames.join(', ') + ') {',
            '%output%',
            '  return {',
            _.map(exportNames, function(exportName) {
              return "    '" + exportName + "': " + getRealName(exportName, funcDepMap);
            })
            .join(',\n'),
            '  };',
            '});'
          );
        }
        else {
          iife.push('%output%');

          if (isES6) {
            push.apply(iife,
              _.map(depNames, function(depName, index) {
                return 'import ' + depName + " from '" + depPaths[index] + "';";
              })
            );

            iife.push(
              '',
              'export default {',
              _.map(exportNames, function(exportName) {
                return "  '" + exportName + "': " + getRealName(exportName, funcDepMap);
              })
              .join(',\n'),
              '};'
            );
          }
          else if (isCommonJS) {
            push.apply(iife,
              _.map(exportNames, function(exportName) {
                var depName = getRealName(exportName, funcDepMap),
                    depPath = depPaths[_.indexOf(depNames, depName)];

                return 'exports.' + exportName + " = require('" + depPath + "')." + depName + ';';
              })
            );
          }
          else {
            iife.push(
              'module.exports = {',
              _.map(exportNames, function(exportName) {
                var depName = getRealName(exportName, funcDepMap),
                    depPath = depPaths[_.indexOf(depNames, depName)];

                return "  '" + exportName + "': require('" + depPath + "')";
              })
              .join(',\n'),
              '};'
            );
          }
        }
        if (!isAMD) {
          source = trimIndent(source);
        }
        source = removeLicenseTag(source);
        source = replaceIIFE(source, iife.join('\n'));

        data.source = source;
        buildCallback(data);
      });
    });
  }());

  if (!isSilent) {
    // warn of removed dependencies
    _.forOwn(removedDeps, function(depNames, identifier) {
      if (!_.isEmpty(depNames)) {
        var plural = _.size(depNames) > 1;
        console.warn('Warning: Removed ' + (plural ? '' : 'an ') + 'unused dependenc' + (plural ? 'ies' : 'y') + ' from `' + identifier + '`: ' + depNames.join(', '));
      }
    });
  }
  if (onComplete) {
    onComplete({ 'outputPath': fs.realpathSync(outputPath) });
  }
}

/**
 * Compiles template files based on the provided build state extending
 * `_.templates` with precompiled templates named after each file's basename.
 *
 * @private
 * @param {Object} state The build state object.
 * @returns {string} Returns the compiled source.
 */
function buildTemplate(state) {
  var glob = require('glob'),
      moduleId = state.moduleId || 'lodash',
      isStandalone = moduleId == 'none',
      pattern = state.templatePattern,
      settings = state.templateSettings;

  pattern = path.normalize(pattern || path.join(cwd, '*.jst'));

  var hr = '  /*----------------------------------------------------------------------------*/';

  var source = [
    ';(function() {',
    '  var undefined;',
    '',
    '  var objectTypes = {',
    "    'function': true,",
    "    'object': true",
    '  };',
    '',
    '  var root = (objectTypes[typeof window] && window) || this;',
    '',
    '  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;',
    '',
    '  var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;',
    '',
    "  var freeGlobal = freeExports && freeModule && typeof global == 'object' && global;",
    '  if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal)) {',
    '    root = freeGlobal;',
    '  }',
    '',
    '  var moduleExports = freeModule && freeModule.exports === freeExports && freeExports;',
    ''
  ];

  if (isStandalone) {
    build(['exports=none', 'include=escape', 'iife=%output%', '-d', '-s'], function(data) {
      var escapeSource = data.source;
      escapeSource = removeHeader(escapeSource);
      escapeSource = removeFunction(escapeSource, 'lodash');
      escapeSource = removeAssignments(escapeSource);
      escapeSource = cleanupSource(escapeSource);

      source.push(
        '',
        escapeSource,
        '',
        "  var _ = { 'escape': escape };",
        ''
      );
    });
  }
  else {
    source.push(
      '  var _ = root._ || {};',
      ''
    );
  }
  source.push(
    hr,
    ''
  );

  glob(pattern, { 'sync': true }, function(exception, filePaths) {
    if (exception) {
      throw exception;
    }
    var dirname = path.dirname(pattern);
    if (dirname == '.') {
      dirname = '';
    }
    var basePath = (dirname + path.sep).replace(RegExp('(^|' + path.sepEscaped + ')\\*\\*.*$'), '$1'),
        insertAt = source.length,
        templates = createMap();

    _.each(filePaths, function(filePath) {
      var string = fs.readFileSync(filePath, 'utf8'),
          precompiled = cleanupCompiled(getFunctionSource(_.template(string, settings), 2));

      // glob uses *nix path separators even on Windows
      // https://github.com/isaacs/node-glob#windows
      var clipped = filePath.slice(dirname ? basePath.length : 0).replace(/\..*$/, ''),
          props = clipped.split('/');

      // create namespace objects
      _.reduce(props, function(object, key) {
        return object[key] || (object[key] = createMap());
      }, templates);

      // escape namespace property names
      props = _.map(props, function(key) {
        return "['" + key.replace(/['\n\r\t]/g, '\\$&') + "']";
      });

      // add template assignment to `source`
      source.push('  templates' + props.join('') + ' = ' + precompiled + ';', '');
    });

    // add the initial `_.templates` object to `source`
    source.splice(insertAt, 0, '  var templates = ' +
      JSON.stringify(templates, null, 4)
        .replace(/^ *}$/m, '  $&')
        .replace(/'/g, "\\'")
        .replace(/([^\\])"/g, "$1'") +
      ';',
      ''
    );
  });

  source.push(
    hr,
    '',
    "  if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {"
  );

  if (isStandalone) {
    source.push(
      '    define(function() {',
      '      return templates;'
    );
  }
  else {
    source.push(
      "    define(['" + moduleId + "'], function(lodash) {",
      '      _ = lodash;',
      '      lodash.templates = lodash.extend(lodash.templates || {}, templates);'
    );
  }
  source.push(
    '    });',
    '  }',
    '  else if (freeExports && freeModule) {'
  );

  if (!isStandalone) {
    source.push("    _ = require('" + moduleId + "');");
  }
  source.push(
    '    if (moduleExports) {',
    '      (freeModule.exports = templates).templates = templates;',
    '    } else {',
    '      freeExports.templates = templates;',
    '    }'
  );

  if (isStandalone) {
    source.push(
      '  }',
      '  else {',
      '    root.templates = templates;',
      '  }'
    );
  }
  else {
    source.push(
      '  }',
      '  else if (_) {',
      '    _.templates = _.extend(_.templates || {}, templates);',
      '  }'
    );
  }
  source.push('}.call(this));');

  return source.join('\n');
}

/**
 * Removes unnecessary semicolons and whitespace from compiled code.
 *
 * @private
 * @param {string} source The source to process.
 * @returns {string} Returns the modified source.
 */
function cleanupCompiled(source) {
  return stringFree(source, function(source) {
    return source
      .replace(/\b(function)\s*(\()/g, '$1$2')
      .replace(/([{}])\s*;/g, '$1');
  });
}

/**
 * Removes unnecessary comments, and whitespace.
 *
 * @private
 * @param {string} source The source to process.
 * @returns {string} Returns the modified source.
 */
function cleanupSource(source) {
  return stringFree(source, function(source) {
    return source
      // consolidate consecutive horizontal rule comment separators
      .replace(/(?:\s*\/\*-+\*\/\s*){2,}/g, function(separators) {
        var indent = separators.match(/^\s*/)[0];
        return indent + separators.slice(separators.lastIndexOf('/*'));
      })
      // remove unneeded single line comments
      .replace(/(\{\s*)?(\n *\/\/.*)(\s*\})/g, function(match, prelude, comment, postlude) {
        return (!prelude && postlude) ? postlude : match;
      })
      // remove unneeded horizontal rule comment separators
      .replace(/(\{\s*\n) *\/\*-+\*\/\n|^ *\/\*-+\*\/\n(\s*\})/gm, '$1$2')
      // remove trailing horizontal rule comment separators
      .replace(/\s*\/\*-+\*\/\s*$/, '')
      // remove lines with just spaces and semicolons
      .replace(/^ *;\n/gm, '')
      // remove trailing spaces from lines
      .replace(/ *$/gm, '')
      // consolidate multiple newlines
      .replace(/\n{3,}/g, '\n\n')
      // remove leading empty lines
      .replace(/^ *\n+/, '')
      // add trailing newline
      .trimRight() + '\n';
  });
}

/**
 * Creates a map object. If a `properties` object is provided its own
 * enumerable properties are assigned to the created object.
 *
 * @private
 * @param {Object} [properties] The properties to assign to the object.
 * @returns {Object} Returns the new object.
 */
function createMap(properties) {
  return _.assign(Object.create(null), properties);
}

/**
 * The default callback used for `build` invocations.
 *
 * @private
 * @param {Object} data The data for the given build.
 *  gzip - The gzipped output of the built source
 *  outputPath - The path where the built source is to be written
 *  source - The built source output
 *  sourceMap - The source map output
 */
function defaultBuildCallback(data) {
  var outputPath = data.outputPath,
      sourceMap = data.sourceMap;

  if (outputPath) {
    fs.writeFileSync(outputPath, data.source, 'utf8');
    if (sourceMap) {
      fs.writeFileSync(path.join(path.dirname(outputPath), path.basename(outputPath, '.js') + '.map'), sourceMap, 'utf8');
    }
  }
}

/**
 * Writes the help message to standard output.
 *
 * @private
 */
function displayHelp() {
  console.log([
    'Usage:',
    '  lodash [commands] [options]',
    '',
    'Commands:',
    '',
    '  backbone     Build with only functions required by Backbone',
    '  compat       Build with support for old & new environments (default)',
    '  modern       Build tailored for newer environments with ES5 support',
    '  strict       Build with ES5 strict mode enabled',
    '  underscore   Build tailored for projects already using Underscore',
    '  modularize   Splits Lo-Dash into modules',
    '',
    '  include=..   Comma separated function/category names to include in the build',
    '',
    '  minus=..     Comma separated function/category names to remove from the build',
    '',
    '  plus=..      Comma separated function/category names to add to the build',
    '',
    '  category=..  Comma separated categories of functions to include in the build',
    '               (i.e. “array”, “chain”, “collection”, “function”, “object”,',
    '               “string”, & “utility”)',
    '',
    '  exports=..   Comma separated names of ways to export the `lodash` function.',
    '               (i.e. “amd”, “commonjs”, “es6”, “global”, “node”, “npm”, & “none”)',
    '',
    '  iife=..      Code to replace the IIFE that wraps Lo-Dash',
    '               (e.g. `lodash iife="!function(){%output%}()"`)',
    '',
    '  template=..  File path pattern used to match template files to precompile',
    '               (e.g. `lodash template=./*.jst`)',
    '',
    '  settings=..  Template settings used when precompiling templates',
    '               (e.g. `lodash settings="{interpolate:/{{([\\s\\S]+?)}}/g}"`)',
    '',
    '  moduleId=..  The AMD module ID used to export Lo-Dash in Lo-Dash builds or',
    '               the module ID used to include Lo-Dash in compiled templates.',
    '',
    '               Use “none” as the module ID to create compiled templates without',
    '               a dependency on Lo-Dash.',
    '',
    '  All commands except `backbone`, `modern`, & `underscore` may be combined.',
    '',
    '  The `exports` values “es6” & “npm” may only be used in conjunction with',
    '  the `modularize` command.',
    '',
    '  Unless specified by `-o` or `--output` all files created are saved to the',
    '  current working directory.',
    '',
    'Options:',
    '',
    '  -c, --stdout       Write output to standard output',
    '  -d, --development  Write only the non-minified development output',
    '  -h, --help         Display help information',
    '  -m, --source-map   Generate a source map using an optional source map URL',
    '  -o, --output       Write output to a given path/filename',
    '  -p, --production   Write only the minified production output',
    '  -s, --silent       Skip status updates normally logged to the console',
    '  -V, --version      Output current version of Lo-Dash',
    ''
  ].join('\n'));
}

/**
 * Gets the aliases associated with a given function name.
 *
 * @private
 * @param {string} funcName The name of the function to get aliases for.
 * @param {Object} [funcDepMap] The dependency map used to validate aliases.
 * @returns {Array} Returns an array of aliases.
 */
function getAliases(funcName, funcDepMap) {
  var aliases = _.has(realToAliasMap, funcName) && realToAliasMap[funcName];
  return _.reject(aliases, _.partial(_.has, funcDepMap || funcDependencyMap));
}

/**
 * Gets the categories of the given identifier.
 *
 * @private
 * @param {string} identifier The identifier to query.
 * @param {Object} [funcDepMap] The dependency map used to resolve the identifier.
 * @returns {Array} Returns the array of categories.
 */
function getCategories(identifier, funcDepMap) {
  var result = [];
  identifier = getRealName(identifier, funcDepMap);

  _.forOwn(categoryMap, function(identifiers, category) {
    if (_.contains(identifiers, identifier)) {
      result.push(category);
    }
  });
  return result;
}

/**
 * Gets the `baseCreate` fork from `source`.
 *
 * @private
 * @param {string} source The source to inspect.
 * @returns {string} Returns the fork.
 */
function getBaseCreateFork(source) {
  return _.result(source.match(/^(?: *\/\/.*\n)*( *)if\s*\(!nativeCreate\b[\s\S]+?\n\1  baseCreate\s*=[\s\S]+?\n\1}\n/m), 0, '');
}

/**
 * Gets the `cloneBuffer` fork from `source`.
 *
 * @private
 * @param {string} source The source to inspect.
 * @returns {string} Returns the fork.
 */
function getCloneBufferFork(source) {
  return _.result(source.match(/^(?: *\/\/.*\n)*( *)if\s*\(!bufferSlice\b[\s\S]+?\n\1  cloneBuffer\s*=[\s\S]+?\n\1}\n/m), 0, '');
}

/**
 * Resolves the path of the given module dependency. If `fromPath` is
 * provided the resolved path will be relative to `fromPath`.
 *
 * @private
 * @param {string} depName The name of the dependency.
 * @param {string} [fromPath=''] The path to resolve the dependency relative to.
 * @param {Object} [funcDepMap] The dependency map used to resolve identifiers.
 * @returns {string} Returns the dependency path.
 */
function getDepPath(depName, fromPath, funcDepMap) {
  var sep = '/',
      toPath = getModulePath(depName, funcDepMap),
      relative = path.relative(fromPath || '', toPath).replace(RegExp(path.sepEscaped, 'g'), sep);

  if (relative.charAt(0) != '.') {
    relative = '.' + (relative ? sep + relative : '');
  }
  return relative + sep + depName;
}

/**
 * Resolves the paths of the given module dependencies. If `fromPath` is
 * provided the resolved path will be relative to `fromPath`.
 *
 * @private
 * @param {Array} depNames The array dependency names.
 * @param {string} [fromPath=''] The path to resolve dependencies relative to.
 * @param {Object} [funcDepMap] The dependency map used to resolve identifiers.
 * @returns {string[]} Returns the dependency paths.
 */
function getDepPaths(depNames, fromPath, funcDepMap) {
  return _.map(depNames, _.partial(getDepPath, _, fromPath, funcDepMap));
}

/**
 * Gets an array of depenants for the given function name(s).
 *
 * @private
 * @param {string} funcName A function name or array of function names.
 * @param {Object} [funcDepMap] The dependency map used to look up dependants.
 * @param {boolean} [isShallow=false] A flag to specify getting only the immediate dependants.
 * @param- {Array} [stackA=[]] Internally used track queried function names.
 * @returns {Array} Returns an array of function dependants.
 */
function getDependants(funcName, funcDepMap, isShallow, stack) {
  var funcNames = _.isArray(funcName) ? funcName : [funcName];
  funcDepMap || (funcDepMap = funcDependencyMap);
  stack || (stack = []);

  // iterate over the dependency map, adding names of functions that have `funcName` as a dependency
  return _.uniq(_.transform(funcDepMap, function(result, depNames, otherName) {
    if (!_.contains(stack, otherName) &&
        _.some(funcNames, _.partial(_.contains, depNames, _, 0))) {
      result.push(otherName);
      if (!isShallow) {
        stack.push(otherName);
        push.apply(result, getDependants(otherName, funcDepMap, isShallow, stack));
      }
    }
  }, []));
}

/**
 * Gets an array of dependencies for a given function name. If an array of
 * dependencies is provided, it will return an array containing the given
 * dependencies plus any additional detected sub-dependencies.
 *
 * @private
 * @param {string|string[]} funcName A function name or array of dependencies to query.
 * @param {Object} [funcDepMap] The dependency map used to look up dependants.
 * @param {boolean} [isShallow=false] A flag to specify getting only the immediate dependencies.
 * @param- {Array} [stackA=[]] Internally used track queried function names.
 * @returns {Array} Returns an array of function dependencies.
 */
function getDependencies(funcName, funcDepMap, isShallow, stack) {
  var depNames = _.isArray(funcName) ? funcName : funcDepMap[funcName];
  funcDepMap || (funcDepMap = funcDependencyMap);

  if (!_.size(depNames)) {
    return [];
  }
  if (isShallow) {
    return depNames.slice();
  }
  stack || (stack = []);

  // recursively accumulate the dependencies of the `funcName` function, and
  // the dependencies of its dependencies, and so on
  return _.uniq(_.transform(depNames, function(result, otherName) {
    if (!_.contains(stack, otherName)) {
      stack.push(otherName);
      result.push(otherName);
      push.apply(result, getDependencies(otherName, funcDepMap, isShallow, stack));
    }
  }));
}

/**
 * Gets the formatted source of the given function.
 *
 * @private
 * @param {Function} func The function to process.
 * @param {number|string} [indent=0] The level to indent.
 * @returns {string} Returns the formatted source.
 */
function getFunctionSource(func, indent) {
  var source = func.source || (func + ''),
      srcIndent = getIndent(source),
      forceIndent = _.size(source.match(RegExp('^' + srcIndent + '}', 'gm'))) > 1;

  indent || (indent = '');
  if (typeof indent == 'number') {
    indent = _.repeat(' ', indent);
  }
  // remove any existing indent
  if (srcIndent) {
    source = source.replace(RegExp('^' + srcIndent, 'gm'), '');
  }
  // set indent of source
  return indent + source.replace(/\n(?:.*)/g, function(match, index) {
    var prelude = '\n' + indent;
    match = match.slice(1);
    if (forceIndent) {
      prelude += (match == '}' && !_.contains(source, '}', index + 2) ? '' : '  ');
    }
    return prelude + match;
  });
}

/**
 * Gets the copyright/license header of `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @returns {string} Returns the copyright/license header.
 */
function getHeader(source) {
  return _.result(/^(?:\s*\/\*[^*]*\*+(?:[^\/][^*]*\*+)*\/|\s*\/\/.*)*\n/.exec(source), 0, '');
}

/**
 * Gets the indent of the given function.
 *
 * @private
 * @param {Function} func The function to process.
 * @returns {string} Returns the indent.
 */
function getIndent(func) {
  return /^ *(?=\S)/m.exec(func.source || func)[0];
}

/**
 * Gets the `_.isArguments` fork from `source`.
 *
 * @private
 * @param {string} source The source to inspect.
 * @returns {string} Returns the fork.
 */
function getIsArgumentsFork(source) {
  return _.result(source.match(/^(?: *\/\/.*\n)*( *)if\s*\((?:!support\.argsClass|!isArguments)\b[\s\S]+?\n\1  isArguments\s*=[\s\S]+?\n\1}\n/m), 0, '');
}

/**
 * Gets the `_.isArray` fork from `source`.
 *
 * @private
 * @param {string} source The source to inspect.
 * @returns {string} Returns the fork.
 */
function getIsArrayFork(source) {
  return matchFunction(source, 'isArray')
    .replace(/^[\s\S]+?(?=\|\|)/, '')
    .replace(/[;\s]+$/, '');
}

/**
 * Gets the `_.isElement` fork from `source`.
 *
 * @private
 * @param {string} source The source to inspect.
 * @returns {string} Returns the fork.
 */
function getIsElementFork(source) {
  return _.result(source.match(/^(?: *\/\/.*\n)*( *)if\s*\(!support\.dom\b[\s\S]+?\n\1  isElement\s*=[\s\S]+?\n\1}\n/m), 0, '');
}

/**
 * Gets the `_.isFunction` fork from `source`.
 *
 * @private
 * @param {string} source The source to inspect.
 * @returns {string} Returns the fork.
 */
function getIsFunctionFork(source) {
  return _.result(source.match(/^(?: *\/\/.*\n)*( *)if\s*\(isFunction\(\/x\/[\s\S]+?\n\1  isFunction\s*=[\s\S]+?\n\1}\n/m), 0, '');
}

/**
 * Gets the Lo-Dash method assignments snippet from `source`.
 *
 * @private
 * @param {string} source The source to inspect.
 * @returns {string} Returns the method assignments snippet.
 */
function getMethodAssignments(source) {
  return _.result(source.match(/\n\n(?: *\/\/.*\n)* *lodash\.[$\w]+\s*=[\s\S]+lodash\.[$\w]+\s=.+/), 0, '');
}

/**
 * Resolves the module path of the given identifier.
 *
 * @private
 * @param {string} identifier The module identifier.
 * @param {string} [category] The category of the identifier.
 * @param {Object} [funcDepMap] The dependency map used to resolve identifiers.
 * @returns {string} Returns the module path.
 */
function getModulePath(identifier, category, funcDepMap) {
  if (topLevel[identifier]) {
    return '';
  }
  if (_.isObject(category)) {
    funcDepMap = category;
    category = null;
  }
  if (!category) {
    category = _.first(getCategories(identifier, funcDepMap));
  }
  return (category || 'internal').toLowerCase();
}

/**
 * Gets the names of identifiers in `source` that belong to the given category.
 *
 * @private
 * @param {string} category The category to filter by.
 * @returns {Array} Returns a new array of names.
 */
function getNamesByCategory(category) {
  return categoryMap[category];
}

/**
 * Gets the `_.isArray` fork from `source`.
 *
 * @private
 * @param {string} source The source to inspect.
 * @returns {string} Returns the fork.
 */
function getNowFork(source) {
  return matchFunction(source, 'now')
    .replace(/^[\s\S]+?(?=\|\|)/, '')
    .replace(/[;\s]+$/, '');
}

/**
 * Gets the value of a given name from the `options` array. If no value is
 * available the `defaultValue` is returned.
 *
 * @private
 * @param {Array} options The options array to inspect.
 * @param {string} name The name of the option.
 * @param {*} defaultValue The default option value.
 * @returns {*} Returns the option value.
 */
function getOption(options, name, defaultValue) {
  var isArr = _.isArray(defaultValue);
  return _.reduce(options, function(result, value) {
    if (isArr) {
      value = optionToArray(name, value);
      return _.isEmpty(value) ? result : value;
    }
    value = optionToValue(name, value);
    return value == null ? result : value;
  }, defaultValue);
}

/**
 * Gets the `_.parseInt` fork from `source`.
 *
 * @private
 * @param {string} source The source to inspect.
 * @returns {string} Returns the fork.
 */
function getParseIntFork(source) {
  return _.result(source.match(/^(?: *\/\/.*\n)*( *)if\s*\(nativeParseInt\(whitespace\b[\s\S]+?\n\1  parseInt\s*=[\s\S]+?\n\1}\n/m), 0, '');
}

/**
 * Gets the real name, not alias, of a given function name.
 *
 * @private
 * @param {string} funcName The name of the function to resolve.
 * @param {Object} [funcDepMap] The dependency map used to validate the real name.
 * @returns {string} Returns the real function name.
 */
function getRealName(funcName, funcDepMap) {
  return (
    !_.has(funcDepMap || funcDependencyMap, funcName) &&
    _.has(aliasToRealMap, funcName) &&
    aliasToRealMap[funcName]
  ) || funcName;
}

/**
 * Gets the `setData` fork from `source`.
 *
 * @private
 * @param {string} source The source to inspect.
 * @returns {string} Returns the fork.
 */
function getSetDataFork(source) {
  return _.result(matchFunction(source, 'setData').match(/!defineProperty[^:]+:\s*/), 0, '');
}

/**
 * Creates an array variables names from all variables defined outside of
 * Lo-Dash functions.
 *
 * @private
 * @param {string} source The source to process.
 * @returns {Array} Returns a new array of variable names.
 */
function getVars(source) {
  source = removeStrings(removeComments(source));

  // remove all functions except `runInContext`
  source = source
    .replace(/^( *)function\s+(?!runInContext)[\s\S]+?\{\n[\s\S]+?\n\1}\n/gm, '')
    .replace(/^( *)(?:var\s+)?[$\w]+\s*=.*?create[A-Z][a-z]+\((?:.+|[\s\S]+?\n\1(?:\S.*?)?)\);\n/gm, '')
    .replace(/^( *)(?:var\s+)?[$\w]+\s*=\s*function\b[\s\S]+?\{\n[\s\S]+?\n\1};\n/gm, '');

  var isDeep = reDeepVars.test(source),
      indentA = isDeep ? ' {2,4}' : ' {2}',
      indentB = isDeep ? ' {6,8}' : ' {6}';

  var result = _.reduce([
    // match a varaible at the start of a declaration list
    indentA + 'var\\s+([$\\w]+)\\s*=.+?,\\n(?=\\s*[$\\w]+\\s*=)',
    // match a variable declaration in a declaration list
    indentB + '([$\\w]+)\\s*=[\\s\\S]+?[,;]\\n',
    // match a variable that is not part of a declaration list
    '(' + indentA + ')var\\s+([$\\w]+)\\s*(?:|=\\s*(?:.+?(?:&&\\n[\\s\\S]+?)?|(?:[($\\w]+\\(|[{[(]\\n)[\\s\\S]+?\\n\\1\\S+?));\\n'
  ], function(result, reSource) {
    source = source.replace(RegExp('^' + reSource, 'gm'), function(match, indent, varName) {
      result.push(typeof varName == 'number' ? indent : varName);
      return '';
    });
    return result;
  }, []);

  return _.uniq(result);
}

/**
 * Checks if `source` is a function snippet.
 *
 * @private
 * @param {string} source The source to inspect.
 * @returns {boolean} Returns `true` for a function snippet, else `false`.
 */
function isFunctionSnippet(source) {
  var header = getHeader(source);
  if (header && reFuncTag.test(header)) {
    return true;
  }
  return reFuncSnippet.test(source.replace(header, ''));
}

/**
 * Checks if `funcName` is a private function.
 *
 * @private
 * @param {string} funcName The name of the function.
 * @returns {boolean} Returns `true` if the function is private, else `false`.
 */
function isPrivate(funcName) {
  return _.contains(privateFuncs, funcName);
}

/**
 * Checks if the variable `varName` is used in `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @param {string} varName The name of the variable.
 * @returns {boolean} Returns `true` if the variable is used, else `false`.
 */
function isVarUsed(source, varName) {
  var snippet = matchVar(source, varName);
  if (!snippet) {
    return false;
  }
  // remove the variable assignment from the source
  source = source.replace(snippet, '');
  return RegExp('[^.$"\'\\w]' + varName + '\\b(?!\\s*=)').test(source);
}

/**
 * Searches `source` for a `funcName` function declaration, expression, or
 * assignment and returns the matched snippet.
 *
 * @private
 * @param {string} source The source to inspect.
 * @param {string} funcName The name of the function to match.
 * @param {boolean} [leadingComments] A flag to specify including leading comments.
 * @returns {string} Returns the matched function snippet.
 */
function matchFunction(source, funcName, leadingComments) {
  var result = _.reduce([
    // match a function declaration
    '( *)function\\s+' + funcName + '\\b[\\s\\S]+?\\n\\3}\\n',
    // match variable declarations using `createAggregator`, or `createCompounder`
    '( *)var\\s+' + funcName + '\\s*=.*?create[A-Z][a-z]+\\((?:.+|[\\s\\S]+?\\n\\3(?:\\S.*?)?)\\);\\n',
    // match a variable declaration with function expression
    '( *)var\\s+' + funcName + '\\s*=.*?function\\b[\\s\\S]+?\{\\n[\\s\\S]+?\\n\\3}(?:\\(\\)\\))?;\\n',
    // match a simple variable declaration
    ' *var\\s+' + funcName + '\\s*=.+?;\\n'
  ], function(result, reSource) {
    if (result) {
      return result;
    }
    return source.match(RegExp(
      '^(' + multilineComment + ')' +
      '('  + reSource + ')'
    , 'm'));
  }, '');

  if (result && isFunctionSnippet(result[0])) {
    return (leadingComments ? result[1] : '') + result[2];
  }
  return '';
}

/**
 * Searches `source` for a Lo-Dash property, of the given property name, and
 * returns the matched snippet.
 *
 * @private
 * @param {string} source The source to inspect.
 * @param {string} propName The name of the property to match.
 * @param {boolean} [leadingComments] A flag to specify including leading comments.
 * @returns {string} Returns the matched property snippet.
 */
function matchProp(source, propName, leadingComments) {
  return _.result(source.match(RegExp(
    '^' + (leadingComments ? multilineComment : '') +
    '(?: {2,4}var\\s+' + propName + '\\b.+|(?:\\s*|.*?=\\s*)lodash\\._?' + propName + '\\s*)=[\\s\\S]+?' +
    '(?:\\(function\\b[\\s\\S]+?\\}\\([^)]*\\)\\);\\n(?=\\n)|' +
    '[;}]\\n(?=\\n(?!\\s*\\(func)))'
  , 'm')), 0, '');
}

/**
 * Searches `source` for a `varName` variable assignment and returns
 * the matched snippet.
 *
 * @private
 * @param {string} source The source to inspect.
 * @param {string} varName The name of the variable to match.
 * @param {boolean} [leadingComments] A flag to specify including leading comments.
 * @returns {string} Returns the matched variable snippet.
 */
function matchVar(source, varName, leadingComments) {
  var isDeep = reDeepVars.test(source),
      indentA = isDeep ? ' {2,4}' : ' {2}',
      indentB = isDeep ? ' {6,8}' : ' {6}';

  var reSources = [
    // match a varaible at the start of a declaration list
    indentA + 'var ' + varName + '\\s*=.+?,\\n(?=\\s*[$\\w]+\\s*=)',
    // match a variable declaration in a declaration list
    indentB + varName + '\\s*=[\\s\\S]+?[,;]\\n',
    // match a variable that is not part of a declaration list
    '(' + indentA + ')var\\s+' + varName + '\\s*(?:|=\\s*(?:.+?(?:&&\\n[\\s\\S]+?)?|(?:[($\\w]+\\(|[{[(]\\n)[\\s\\S]+?\\n\\1\\S+?));\\n'
  ];

  // match complex variable assignments
  if (_.contains(complexVars, varName)) {
    reSources = [
      '(' + indentA + ')var\\s+' + varName + '\\s*=[\\s\\S]+?[};]\\n(?=\\s*\\n(?:\\S|\\1(?:function\\b|if\\b|lodash\\b|var\\s|/[/*])))'
    ];
  }
  return _.reduce(reSources, function(result, reSource) {
    if (result) {
      return result;
    }
    return _.result(source.match(RegExp(
      '^' + (leadingComments ? multilineComment : '') +
      reSource
    , 'm')), 0, '');
  }, '');
}

/**
 * Converts a comma separated option value into an array.
 *
 * @private
 * @param {string} name The name of the option to inspect.
 * @param {string} string The options string.
 * @returns {Array} Returns the new converted array.
 */
function optionToArray(name, string) {
  return _.compact(_.invoke((optionToValue(name, string) || '').split(/, */), 'trim'));
}

/**
 * Extracts the option value from an option string.
 *
 * @private
 * @param {string} name The name of the option to inspect.
 * @param {string} string The options string.
 * @returns {string|undefined} Returns the option value, else `undefined`.
 */
function optionToValue(name, string) {
  var result = string.match(RegExp('^' + name + '(?:=([\\s\\S]+))?$'));
  if (result) {
    result = _.result(result, 1);
    result = result ? _.trim(result) : true;
  }
  if (result === 'false') {
    return false;
  }
  return result || undefined;
}

/**
 * Removes all Lo-Dash assignments from `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @returns {string} Returns the modified source.
 */
function removeAssignments(source) {
  // remove method and intermediate assignments
  source = removeMethodAssignments(source);
  return source.replace(/(=\s*)lodash\.[$\w]+\s*=\s*/g, '$1');
}

/**
 * Removes the `baseCreate` fork from `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @returns {string} Returns the modified source.
 */
function removeBaseCreateFork(source) {
  return source.replace(getBaseCreateFork(source), '');
}

/**
 * Removes support for Lo-Dash wrapper chaining in `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @returns {string} Returns the modified source.
 */
function removeChaining(source) {
  source = removeMixinCalls(source);
  source = removeSpliceObjectsFix(source);

  // remove all `lodash.prototype` additions
  return source
    .replace(/^(?: *\/\/.*\n)*( *)baseForOwn\(lodash,[\s\S]+?\n\1}.+\n/gm, '')
    .replace(/^(?: *\/\/.*\n)*( *)arrayEach\(\['[\s\S]+?\n\1}.+\n/gm, '')
    .replace(/^(?: *\/\/.*\n)* *lodash\.prototype\.[\s\S]+?;\n/gm, '');
}

/**
 * Removes the `cloneBuffer` fork from `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @returns {string} Returns the modified source.
 */
function removeCloneBufferFork(source) {
  return source.replace(getCloneBufferFork(source), '');
}

/**
 * Removes all comments from `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @returns {string} Returns the modified source.
 */
function removeComments(source) {
  return source.replace(/^ *(?:\/\*[^*]*\*+(?:[^\/][^*]*\*+)*\/|\/\/.+)\n/gm, '');
}

/**
 * Removes ES5 specific optimizations from `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @param {Object} [funcDepMap] The function dependency map to modify.
 * @param {Object} [objDepMap] The object dependency map to modify.
 * @param {Object} [varDepMap] The variable dependency map to modify.
 * @returns {string} Returns the modified source.
 */
function removeEsOptimization(source, funcDepMap, objDepMap, varDepMap) {
  var deps = _.result(funcDepMap, 'createWrapper', []);
  _.pull(deps, 'composeArgs', 'composeArgsRight', 'replaceHolders', 'slice');

  deps = _.result(objDepMap, 'baseCallback', []);
  _.pull(deps, 'support');

  deps = _.result(varDepMap, 'support', []);
  _.pull(deps, 'root');

  _.each(['baseCallback', 'support'], function(identifier) {
    var deps = _.result(funcDepMap, identifier, []);
    _.pull(deps, 'isNative');
  });

  _.each(['baseCallback', 'baseCreateWrapper'], function(funcName) {
    var deps = _.result(funcDepMap, funcName, []);
    _.pull(deps, 'setData');
  });

  source = removeSupportProp(source, 'funcDecomp');
  source = removeSupportProp(source, 'funcNames');

  // remove metadata code and `setData` function calls
  _.each(['baseCallback', 'baseCreateWrapper', 'createWrapper'], function(funcName) {
    source = source.replace(matchFunction(source, funcName), function(match) {
      return match
        .replace(/^(?: *\/\/.*\n)*( *)var\s+(?:data|funcData)\s*=[\s\S]+?\n\1}\n/m, '')
        .replace(/^(?: *\/\/.*\n)*( *)if\s*\((?:data|funcData)\b[\s\S]+?\n\1}\n/m, '')
        .replace(/^(?: *\/\/.*\n)* *setData.+\n/m, '')
        .replace(/^( *return\s+)setData\(([^,]+),[^)]+\)/gm, '$1$2')
    });
  });

  return source;
}

/**
 * Removes the `funcName` function declaration, expression, or assignment and
 * associated code from `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @param {string} funcName The name of the function to remove.
 * @returns {string} Returns the modified source.
 */
function removeFunction(source, funcName) {
  // defer to specialized removal functions
  if (funcName == 'runInContext') {
    return removeRunInContext(source, funcName);
  }
  // remove function
  var snippet = matchFunction(source, funcName, true);
  if (snippet) {
    source = source.replace(snippet, '');
  }
  return source;
}

/**
 * Removes all references to `getCallback` from `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @param {Object} [funcDepMap] The dependency map to modify.
 * @returns {string} Returns the modified source.
 */
function removeGetCallback(source, funcDepMap) {
  source = removeFunction(source, 'getCallback');

  _.each([
    'dropRightWhile', 'dropWhile', 'every', 'filter', 'find', 'findIndex',
    'findLastIndex', 'findKey', 'findLast', 'findLastKey', 'map', 'mapValues',
    'max', 'min', 'omit', 'pick', 'reduce', 'reduceRight', 'reject', 'remove',
    'some', 'sortBy', 'sortedIndex', 'sortedLastIndex', 'takeRightWhile',
    'takeWhile', 'transform', 'uniq', 'createAggregator'
  ], function(funcName) {
    source = source.replace(matchFunction(source, funcName), function(match) {
      // replace all `getCallback` calls with `baseCallback`
      return match.replace(/\bgetCallback(?:\(\))?/g, function() {
        var deps = _.result(funcDepMap, funcName, []);
        _.pull(deps, 'getCallback').push('baseCallback');
        return 'baseCallback';
      });
    });
  });

  return source;
}

/**
 * Removes all references to `getIndexOf` from `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @param {Object} [funcDepMap] The dependency map to modify.
 * @returns {string} Returns the modified source.
 */
function removeGetIndexOf(source, funcDepMap) {
  source = removeFunction(source, 'getIndexOf');

  _.each(['baseDifference', 'baseUniq', 'contains', 'intersection', 'uniq'], function(funcName) {
    source = source.replace(matchFunction(source, funcName), function(match) {
      // remove "indexOf" comparisons
      match = match.replace(/\s*&&\s*indexOf(?:\(\))?\s*==\s*baseIndexOf\b/g, '');

      // replace all `getIndexOf` calls with `baseIndexOf`
      return match.replace(/\bgetIndexOf(?:\(\))?/g, function() {
        var deps = _.result(funcDepMap, funcName, []);
        _.pull(deps, 'getIndexOf').push('baseIndexOf');
        return 'baseIndexOf';
      });
    });
  });

  return source;
}

/**
 * Removes the copyright/license header from `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @returns {string} Returns the modified source.
 */
function removeHeader(source) {
  return source.replace(getHeader(source), '');
}

/**
 * Removes the `_.isArguments` fork from `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @returns {string} Returns the modified source.
 */
function removeIsArgumentsFork(source) {
  return source.replace(getIsArgumentsFork(source), '');
}

/**
 * Removes the `_.isArray` fork from `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @returns {string} Returns the modified source.
 */
function removeIsArrayFork(source) {
  return source.replace(getIsArrayFork(source), '');
}

/**
 * Removes the `_.isElement` fork from `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @returns {string} Returns the modified source.
 */
function removeIsElementFork(source) {
  return source.replace(getIsElementFork(source), '');
}

/**
 * Removes the `_.isFunction` fork from `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @returns {string} Returns the modified source.
 */
function removeIsFunctionFork(source) {
  return source.replace(getIsFunctionFork(source), '');
}

/**
 * Removes the `@license` tag from the copyright header so minifiers and
 * build optimizers may strip them.
 *
 * @private
 * @param {string} source The source to inspect.
 * @returns {string} Returns the modified source.
 */
function removeLicenseTag(source) {
  return source.replace(/^ \* *@license\n/m, '');
}

/**
 * Removes a method assignment by name from `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @param {string} [methodName] The name of the method assignment to remove.
 * @returns {string} Returns the modified source.
 */
function removeMethodAssignment(source, methodName) {
  return source.replace(getMethodAssignments(source), function(match) {
    var reAssignment = RegExp(
      '^( *//.*\\n)* *' +
      'lodash(?:\\.prototype)?\\.' +
      '(?:[$\\w]+\\s*=\\s*' + methodName + '|' + methodName + '\\s*=\\s*[$\\w]+);' +
      '\\n(\\n)?'
    , 'gm');

    return match.replace(reAssignment, function(match, comment, newline) {
      return (!newline && comment) || newline || '';
    });
  });
}

/**
 * Removes the Lo-Dash method assignments snippet from `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @returns {string} Returns the modified source.
 */
function removeMethodAssignments(source) {
  return source.replace(getMethodAssignments(source), '');
}

/**
 * Removes all `_.mixin` calls from `source`.
 *
 * @private
 * @param {string} source The source to inspect.
 * @returns {string} Returns the modified source.
 */
function removeMixinCalls(source) {
  return source.replace(/^(?: *\/\/.*\n)*( *)mixin\((?:.+?|[\s\S]+?\1(?:}.+?)?)\);\n/gm, '');
}

/**
 * Removes the `_.now` fork from `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @returns {string} Returns the modified source.
 */
function removeNowFork(source) {
  return source.replace(getNowFork(source), '');
}

/**
 * Removes the `_.parseInt` fork from `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @returns {string} Returns the modified source.
 */
function removeParseIntFork(source) {
  return source.replace(getParseIntFork(source), '');
}

/**
 * Removes a Lo-Dash property, of the given property name, from `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @param {string} propName The name of the property to remove.
 * @returns {string} Returns the modified source.
 */
function removeProp(source, propName) {
  return source.replace(matchProp(source, propName, true), '');
}

/**
 * Removes all `runInContext` references from `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @returns {string} Returns the modified source.
 */
function removeRunInContext(source) {
  // remove local timer variables
  source = removeVar(source, 'clearTimeout');
  source = removeVar(source, 'setTimeout');

  // replace `reThis` reference in `support.funcDecomp` assignment
  source = source.replace(/\btest\(runInContext\)/, 'test(function() { return this; })');

  // remove `runInContext` assignment
  source = source.replace(/^(?: *\/\/.*\n)* *lodash\.runInContext\\s*=[\s\S]+?;\n/m, '');

  // remove function scaffolding, leaving most of its content
  source = source.replace(matchFunction(source, 'runInContext', true), function(match) {
    match = replaceIndent(match, 2, 1);
    return match.replace(/^[\s\S]+?function\s+runInContext\b[\s\S]+?context\s*=\s*context.+?\n+| *return\s+lodash\b[\s\S]+$/g, '');
  });

  // cleanup adjusted source
  return source
    .replace(/\bcontext\b/g, 'root')
    .replace(/^(?: *\/\*[^*]*\*+(?:[^\/][^*]*\*+)*\/\n)? *var\s+Array\s*=[\s\S]+?;\n/m, '')
    .replace(/(\breturn\s+|=\s*)_([;)])/g, '$1lodash$2')
    .replace(/^(?: *\/\/.*\n)* *var\s+_\s*=\s*runInContext\b.+\n+/m, '');
}

/**
 * Removes the `support.spliceObjects` fix from the `Array` function mixins
 * snippet of `source`.
 *
 * @private
 * @param {string} source The source to inspect.
 * @returns {string} Returns the modified source.
 */
function removeSpliceObjectsFix(source) {
  return source.replace(/^(?: *\/\/.*\n)*( *)if\s*\(!support\.spliceObjects\b[\s\S]+?(?:\{\s*}|\n\1})\n/m, '');
}

/**
 * Removes all strings from `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @returns {string} Returns the modified source.
 */
function removeStrings(source) {
  return source.replace(reStrings, '');
}

/**
 * Removes all `support.argsClass` references from `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @param {Object} [funcDepMap] The function dependency map to modify.
 * @param {Object} [objDepMap] The object dependency map to modify.
 * @returns {string} Returns the modified source.
 */
function removeSupportArgsClass(source, funcDepMap, objDepMap) {
  source = removeSupportProp(source, 'argsClass');

  _.each(['isArguments', 'isPlainObject'], function(funcName) {
    var deps = _.result(objDepMap, funcName, []);
    _.pull(deps, 'support');
  });

  _.each(['baseClone', 'baseIsEqual', 'isPlainObject', 'shimIsPlainObject'], function(funcName) {
    var deps = _.result(funcDepMap, funcName, []);
    _.pull(deps, 'isArguments');
  });

  // replace `support.argsClass` in the `_.isArguments` fork
  source = source.replace(getIsArgumentsFork(source), function(match) {
    return match.replace(/!support\.argsClass/g, '!isArguments(arguments)');
  });

  // remove `support.argsClass` from `baseIsEqual`
  source = source.replace(matchFunction(source, 'baseIsEqual'), function(match) {
    return match.replace(/^(?: *\/\/.*\n)*( *)if\s*\(!support\.argsClass\b[\s\S]+?\n\1}\n/m, '');
  });

  // remove `support.argsClass` from `baseClone` and `_.isPlainObject`
  _.each(['baseClone', 'shimIsPlainObject', 'isPlainObject'], function(funcName) {
    source = source.replace(matchFunction(source, funcName), function(match) {
      return match.replace(/\s*\|\|\s*\(!support\.argsClass\b[\s\S]+?\)\)/, '');
    });
  });

  return source;
}

/**
 * Removes all `support.dom` references from `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @param {Object} [objDepMap] The dependency map to modify.
 * @returns {string} Returns the modified source.
 */
function removeSupportDom(source, objDepMap) {
  var deps = _.result(objDepMap, 'isElement', []);
  _.pull(deps, 'support');

  source = removeSupportProp(source, 'dom');
  return removeIsElementFork(source);
}

/**
 * Removes all `support.enumErrorProps` references from `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @returns {string} Returns the modified source.
 */
function removeSupportEnumErrorProps(source) {
  return removeSupportProp(source, 'enumErrorProps');
}

/**
 * Removes all `support.enumPrototypes` references from `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @param {Object} [objDepMap] The dependency map to modify.
 * @returns {string} Returns the modified source.
 */
function removeSupportEnumPrototypes(source, objDepMap) {
  source = removeSupportProp(source, 'enumPrototypes');

  var deps = _.result(objDepMap, 'keys', []);
  _.pull(deps, 'support');

  // remove `support.enumPrototypes` from `_.keys`
  return source.replace(matchFunction(source, 'keys'), function(match) {
    return match.replace(/\s*\|\|\s*\(support\.enumPrototypes\b[\s\S]+?\)/, '');
  });
}

/**
 * Removes all `support.nodeClass` references from `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @param {Object} [funcDepMap] The dependency map to modify.
 * @returns {string} Returns the modified source.
 */
function removeSupportNodeClass(source, funcDepMap) {
  source = removeSupportProp(source, 'nodeClass');

  _.each(['baseClone', 'baseIsEqual', 'isElement', 'shimIsPlainObject'], function(funcName) {
    var deps = _.result(funcDepMap, funcName, []);
    _.pull(deps, 'isNode');
  });

  // remove `support.nodeClass` from `baseClone` and `shimIsPlainObject`
  _.each(['baseClone', 'shimIsPlainObject'], function(funcName) {
    source = source.replace(matchFunction(source, funcName), function(match) {
      return match.replace(/\s*\|\|\s*\(!support\.nodeClass\b[\s\S]+?\)\)/, '');
    });
  });

  // remove `support.nodeClass` from `baseIsEqual`
  source = source.replace(matchFunction(source, 'baseIsEqual'), function(match) {
    return match.replace(/\s*&&\s*\(support\.nodeClass\b[\s\S]+?\)\)\)/, '');
  });

  // remove `support.nodeClass` from `_.isElement`
  return source.replace(matchFunction(source, 'isElement'), function(match) {
    return match.replace(/\(support\.nodeClass\s*\?\s*([^:]+?)\s*:[\s\S]+?\)\)/, '$1');
  });
}

/**
 * Removes all `support.nonEnumArgs` references from `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @returns {string} Returns the modified source.
 */
function removeSupportNonEnumArgs(source) {
  return removeSupportProp(source, 'nonEnumArgs');
}

/**
 * Removes all `support.nonEnumShadows` references from `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @returns {string} Returns the modified source.
 */
function removeSupportNonEnumShadows(source) {
  return removeSupportProp(source, 'nonEnumShadows');
}

/**
 * Removes all `support.nonEnumStrings` references from `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @param {Object} [funcDepMap] The function dependency map to modify.
 * @returns {string} Returns the modified source.
 */
function removeSupportNonEnumStrings(source, funcDepMap) {
  source = removeSupportProp(source, 'nonEnumStrings');

  var deps = _.result(funcDepMap, 'shimKeys', []);
  _.pull(deps, 'isString');

  // remove `support.nonEnumStrings` from `shimKeys`
  return source.replace(matchFunction(source, 'shimKeys'), function(match) {
    return match.replace(/\s*\|\|\s*\(support\.nonEnumStrings\b[\s\S]+?\)\)/, '');
  });
}

/**
 * Removes all `support.ownLast` references from `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @returns {string} Returns the modified source.
 */
function removeSupportOwnLast(source) {
  source = removeSupportProp(source, 'ownLast');

  // remove `support.ownLast` from `shimIsPlainObject`
  return source.replace(matchFunction(source, 'shimIsPlainObject'), function(match) {
    return match.replace(/^(?: *\/\/.*\n)*( *)if\s*\(support\.ownLast\b[\s\S]+?\n\1}\n/m, '');
  });
}

/**
 * Removes all `support.spliceObjects` references from `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @returns {string} Returns the modified source.
 */
function removeSupportSpliceObjects(source) {
  source = removeSupportProp(source, 'spliceObjects');
  return removeSpliceObjectsFix(source);
}

/**
 * Removes all `support.unindexedChars` references from `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @param {Object} [funcDepMap] The function dependency map to modify.
 * @param {Object} [objDepMap] The object dependency map to modify.
 * @returns {string} Returns the modified source.
 */
function removeSupportUnindexedChars(source, funcDepMap, objDepMap) {
  source = removeSupportProp(source, 'unindexedChars');

  _.each(['toIterable', 'toArray'], function(funcName) {
    var deps = _.result(funcDepMap, funcName, []);
    _.pull(deps, 'isString');

    deps =  _.result(objDepMap, funcName, []);
    _.pull(deps, 'support');
  });

  // remove `support.unindexedChars` from `toIterable`
  source = source.replace(matchFunction(source, 'toIterable'), function(match) {
    return match.replace(/^(?: *\/\/.*\n)*( *)if\s*\(support\.unindexedChars\b[\s\S]+?\n\1}\n/m, '');
  });

  // remove `support.unindexedChars` from `_.toArray`
  source = source.replace(matchFunction(source, 'toArray'), function(match) {
    return match.replace(/\(support\.unindexedChars\b[\s\S]+?:\s*/, '');
  });

  return source;
}

/**
 * Removes a given property from the `support` object in `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @param {string} varName The name of the `support` property to remove.
 * @returns {string} Returns the modified source.
 */
function removeSupportProp(source, propName) {
  return source.replace(matchProp(source, 'support'), function(match) {
    return match.replace(RegExp(
      '\\n+' + multilineComment +
      // match a `try` block
      '(?:( *)try\\b.+\\n)?' +
      // match the `support` property assignment
      ' *support\\.' + propName + '\\s*=[\\s\\S]+?;' +
      // match `catch` block
      '(?:\\n\\1}\\s*catch\\b[\\s\\S]+?\\n\\1})?'
    , 'm'), '');
  });
}

/**
 * Removes a variable of the given variable name from `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @param {string} varName The name of the variable to remove.
 * @returns {string} Returns the modified source.
 */
function removeVar(source, varName) {
  _.some([
    function(source) {
      return _.contains(complexVars, varName)
        ? source.replace(matchVar(source, varName, true), '')
        : source;
    },
    function(source) {
      return removeFunction(source, varName);
    },
    function(source) {
      // remove a varaible at the start of a declaration list
      return source.replace(RegExp('(var\\s+)' + varName + '\\s*=.+?,\\n *'), '$1');
    },
    function(source) {
      // remove a variable declaration in a declaration list
      return source.replace(RegExp(
        '^( *(?:var\\s+)?[$\\w]+\\s*=.+?),\\n *' + varName + '\\s*=[\\s\\S]+?([,;])(?=\\n)'
      , 'm'), '$1$2');
    },
    function(source) {
      // remove a variable that is not part of a declaration list
      return source.replace(RegExp(
        '^' + multilineComment +
        '( *)var\\s+' + varName + '\\s*(?:|=\\s*(?:.+?(?:&&\\n[\\s\\S]+?)?|(?:[($\\w]+\\(|[{[(]\\n)[\\s\\S]+?\\n\\1\\S+?));\\n'
      , 'm'), '');
    }
  ], function(func) {
    var result = func(source);
    if (result !== source) {
      source = result;
      return true;
    }
  });

  return source;
}

/**
 * Replaces the `funcName` function body in `source` with `funcValue`.
 *
 * @private
 * @param {string} source The source to process.
 * @param {string} funcName The name of the function to replace.
 * @param {string} funcValue The replacement value.
 * @returns {string} Returns the modified source.
 */
function replaceFunction(source, funcName, funcValue) {
  var checkFuncTag = /^\s*var\s+/.test(funcValue),
      snippet = matchFunction(source, funcName, checkFuncTag);

  if (!snippet) {
    return source;
  }
  return source.replace(snippet, function(match) {
    var header = checkFuncTag ? getHeader(match) : '';
    if (header && !isFunctionSnippet(snippet)) {
      header = header.replace(/^( *)\* *(?:@(?:category|param|returns)\b|\/)/m, function(match, indent) {
        return indent + '* @type Function\n' + match;
      });
    }
    return header + funcValue
      .replace(RegExp('^' + getIndent(funcValue), 'gm'), getIndent(snippet))
      .trimRight() + '\n';
  });
}

/**
 * Replaces the IIFE that wraps `source` with `iife`. If the `%output%` token
 * is present in `iife` it will be replaced with the unwrapped `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @param {string} iife The replacement IIFE.
 * @returns {string} Returns the modified source.
 */
function replaceIIFE(source, iife) {
  var token = '%output%',
      header = getHeader(source),
      index = iife.indexOf(token);

  if (index < 0) {
    return header + iife;
  }
  return header +
    iife.slice(0, index) +
    source.replace(/^[\s\S]+?\(function[^{]+\{\n+|\s*}\.call\(this\)\)[;\s]*$/g, '\n') +
    iife.slice(index + token.length);
}

/**
 * Replaces the indent at level `from` of the given source with the level `to`.
 *
 * @private
 * @param {string} source The source to process.
 * @param {number} from The indent level to be replaced.
 * @param {number} to The indent level to replace with.
 * @returns {string} Returns the modified source.
 */
function replaceIndent(source, from, to) {
  return source.replace(RegExp('^(?:  ){' + (from || 1) + '}', 'gm'), _.repeat('  ', to));
}

/**
 * Replaces the `support` object `propName` property value in `source` with `propValue`.
 *
 * @private
 * @param {string} source The source to process.
 * @param {string} varName The name of the `support` property to replace.
 * @returns {string} Returns the modified source.
 */
function replaceSupportProp(source, propName, propValue) {
  return source.replace(RegExp(
    // match a `try` block
    '^(?: *try\\b.+\\n)?' +
    // match the `support` property assignment
    '( *support\\.' + propName + '\\s*=).+\\n' +
    // match `catch` block
    '(?:( *).+?catch\\b[\\s\\S]+?\\n\\2}\\n)?'
  , 'm'), function(match, left) {
    return left + ' ' + propValue + ';\n';
  });
}

/**
 * Replaces the `varName` variable declaration value in `source` with `varValue`.
 *
 * @private
 * @param {string} source The source to inspect.
 * @param {string} varName The name of the variable to replace.
 * @param {string} varValue The replacement value.
 * @returns {string} Returns the modified source.
 */
function replaceVar(source, varName, varValue) {
  // replace a variable that's not part of a declaration list
  var result = source.replace(RegExp(
    '(( *)var\\s+' + varName + '\\s*=)' +
    '(?:.+?;|(?:Function\\(.+?|.*?[^,])\\n[\\s\\S]+?\\n\\2.+?;)\\n'
  ), function(match, left) {
    return left + ' ' + varValue + ';\n';
  });

  if (source == result) {
    // replace a varaible at the start or middle of a declaration list
    result = source.replace(RegExp('((?:var|\\n)\\s+' + varName + '\\s*=).+?(?=,\\n)'), function(match, left) {
      return left + ' ' + varValue;
    });
  }
  if (source == result) {
    // replace a variable at the end of a variable declaration list
    result = source.replace(RegExp('(,\\s*' + varName + '\\s*=).+?(?=;\\n)'), function(match, left) {
      return left + ' ' + varValue;
    });
  }
  return result;
}

/**
 * Add or remove the "use strict" directive from `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @param {boolean} value The value to set.
 * @returns {string} Returns the modified source.
 */
function setUseStrictOption(source, value) {
  return source.replace(/^([\s\S]*?function[^{]+\{)(?:\s*'use strict';)?/, '$1' + (value ? "\n  'use strict';" : ''));
}

/**
 * This function allows `callback` to modify `source` with string literals
 * removed and returns the modified source with string literals restored.
 *
 * @private
 * @param {string} source The source to modify.
 * @param {Function} [callback] The function to modify the string free source.
 * @returns {string} Returns the modified source.
 */
function stringFree(source, callback) {
  var strings = [];

  source = callback(source.replace(reStrings, function(match) {
    strings.push(match);
    return stringToken;
  })) || '';

  return source.replace(reStringTokens, function() {
    return strings.shift();
  });
}

/**
 * Trims the indent of the specified level from `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @param {number} level The level of indent to trim.
 * @returns {string} Returns the modified source.
 */
function trimIndent(source, level) {
  return replaceIndent(source, level || 1);
}

/*----------------------------------------------------------------------------*/

/**
 * Creates a debug and/or minified build, executing the callback for each. The
 * `callback` is invoked with one argument; (data).
 *
 * Note: For a list of commands see `displayHelp()` or run `lodash --help`.
 *
 * @param {Array|Object} [options=[]] An array of build commands or the state object.
 * @param {Function} [callback=defaultBuildCallback] The function called per build.
 */
function build(options, callback) {
  options || (options = []);

  // used to specify the output path for builds
  var outputPath;

  // used to specify the source map URL
  var sourceMapURL;

  // use to pre-populate the build state
  var state = _.isPlainObject(options) && options;

  var isExcluded = function() {
    return _.every(arguments, _.negate(_.partial(_.contains, buildFuncs, _, 0)));
  };

  var isLodash = function(funcName) {
    funcName = getRealName(funcName);

    var funcNames = (isUnderscore && ((/^(?:assign|zipObject)$/.test(funcName) || _.contains(lodashOnlyFuncs, funcName))))
      ? _.difference(_.union(includeFuncs, plusFuncs), minusFuncs)
      : _.difference(plusFuncs, minusFuncs);

    var result = _.contains(funcNames, funcName);
    return isUnderscore ? result : !result;
  };

  if (state) {
    var buildFuncs = state.buildFuncs,
        filePath = state.filePath,
        funcDepMap = state.funcDepMap,
        includeFuncs = state.includeFuncs,
        includeObjs = state.includeObjs,
        includeVars = state.includeVars,
        isDevelopment = true,
        isModularize = true,
        isStdOut = state.isStdOut,
        isStrict = state.isStrict,
        minusFuncs = [],
        objDepMap = state.objDepMap,
        outputPath = state.outputPath,
        plusFuncs = [],
        source = state.source,
        varDepMap = state.varDepMap;
  }
  else {
    // clone dependencies to modify
    var funcDepMap = createMap(_.cloneDeep(funcDependencyMap)),
        objDepMap = createMap(_.cloneDeep(objDependencyMap)),
        varDepMap = createMap(_.cloneDeep(varDependencyMap));

    // the path to the source file
    var filePath = require.resolve('lodash/lodash.js');

    // used to specify a custom IIFE to wrap Lo-Dash
    var iife = getOption(options, 'iife');

    // used to match external template files to precompile
    var templatePattern = getOption(options, 'template', '');

    // used as the template settings for precompiled templates
    var templateSettings = (function() {
      var result = getOption(options, 'settings');
      return result
        ? Function('return {' + result.replace(/^\{|}$/g, '') + '}')()
        : _.clone(_.templateSettings);
    }());

    // flag to specify a Backbone build
    var isBackbone = getOption(options, 'backbone');

    // flag to specify only creating the development build
    var isDevelopment = getOption(options, '-d') || getOption(options, '--development');

    // flag to indicate that a custom IIFE was specified
    var isIIFE = typeof iife == 'string';

    // flag to specify creating a source map for the minified source
    var isMapped = getOption(options, '-m') || getOption(options, '--source-map');

    // flag to specify a modern build
    var isModern = getOption(options, 'modern');

    // flag to specify a modularize build
    var isModularize = getOption(options, 'modularize');

    // flag to specify only creating the minified build
    var isProduction = getOption(options, '-p') || getOption(options, '--production');

    // flag to specify writing output to standard output
    var isStdOut = getOption(options, '-c') || getOption(options, '--stdout');

    // flag to specify skipping status updates normally logged to the console
    var isSilent = isStdOut || getOption(options, '-s') || getOption(options, '--silent');

    // flag to specify `_.assign`, `_.bindAll`, and `_.defaults`
    // are constructed using the "use strict" directive
    var isStrict = getOption(options, 'strict');

    // flag to specify a template build
    var isTemplate = !!templatePattern;

    // flag to specify an Underscore build
    var isUnderscore = isBackbone || getOption(options, 'underscore');

    // used to specify the ways to export the `lodash` function
    var exportsOptions = (function() {
      var result = getOption(options, 'exports', isModularize ? ['amd'] : defaultExports);
      return isModularize ? _.take(result, 1) : result;
    }());

    // used to specify the AMD module ID of Lo-Dash used by precompiled templates
    var moduleId = getOption(options, 'moduleId', isUnderscore ? 'underscore' : null);

    // used as the output path for the build
    var outputPath = _.reduce(options, function(result, value, index) {
      return /^(?:-o|--output)$/.test(value)
        ? path.normalize(options[index + 1])
        : result;
    }, isModularize ? '.' + path.sep + 'modularize' : '');

    // flag to specify creating a custom build
    var isCustom = !isModularize && (
      isMapped || isModern || isStrict || isTemplate || isUnderscore || outputPath ||
      getOption(options, 'compat') ||
      /\b(?:category|exports|iife|include|minus|moduleId|plus)=/.test(options) ||
      !_.isEqual(exportsOptions, defaultExports)
    );

    // flags to specify export options
    var isAMD = _.contains(exportsOptions, 'amd'),
        isCommonJS = _.contains(exportsOptions, 'commonjs'),
        isES6 = _.contains(exportsOptions, 'es6'),
        isGlobal = _.contains(exportsOptions, 'global'),
        isNpm = _.contains(exportsOptions, 'npm'),
        isNode = isNpm || _.contains(exportsOptions, 'node');

    // the lodash.js source
    var source = fs.readFileSync(filePath, 'utf8');

    /*------------------------------------------------------------------------*/

    // categories of functions to include in the build
    var categoryOptions = _.map(getOption(options, 'category', []), _.compose(_.capitalize, _.partial(_.result, _, 'toLowerCase')));

    // functions to include in the build
    var includeFuncs = categoryOptions.concat(_.map(getOption(options, 'include', []), _.partial(getRealName, _, funcDepMap)));

    // properties to include in the build
    var includeObjs = _.intersection(includeFuncs, objDependencies);

    // variables to include in the build
    var includeVars = _.intersection(includeFuncs, varDependencies);

    // functions to remove from the build
    var minusFuncs = _.map(getOption(options, 'minus', []), _.partial(getRealName, _, funcDepMap));

    // functions to add to the build
    var plusFuncs = _.map(getOption(options, 'plus', []), _.partial(getRealName, _, funcDepMap));

    // expand categories to function names
    _.each([includeFuncs, minusFuncs, plusFuncs], function(funcNames) {
      var categories = _.intersection(funcNames, allCategories);

      _.each(categories, function(category) {
        var otherFuncs = _.filter(getNamesByCategory(category), function(key) {
          var type = typeof _[key];
          return type == 'function' || type == 'undefined';
        });

        // limit function names to those available for specific builds
        if (isBackbone) {
          otherFuncs = _.intersection(otherFuncs, backboneDependencies);
        } else if (isUnderscore) {
          otherFuncs = _.intersection(otherFuncs, underscoreFuncs);
        }
        push.apply(funcNames, otherFuncs);
      });
    });

    // remove categories from function names
    includeFuncs = _.difference(includeFuncs, allCategories, includeObjs, includeVars);
    minusFuncs = _.difference(minusFuncs, allCategories);
    plusFuncs = _.difference(plusFuncs, allCategories);

    /*------------------------------------------------------------------------*/

    // used to capture warnings for invalid command-line arguments
    var warnings = [];

    // used to detect invalid command-line arguments
    var invalidArgs = _.reject(options.slice(reNode.test(options[0]) ? 2 : 0), function(value, index, options) {
      if (/^(?:-o|--output)$/.test(options[index - 1]) ||
          /^(?:category|exports|iife|include|moduleId|minus|plus|settings|template)=[\s\S]*$/.test(value)) {
        return true;
      }
      var result = _.contains([
        'backbone',
        'compat',
        'modern',
        'modularize',
        'strict',
        'underscore',
        '-c', '--stdout',
        '-d', '--development',
        '-h', '--help',
        '-m', '--source-map',
        '-o', '--output',
        '-p', '--production',
        '-s', '--silent',
        '-V', '--version'
      ], value);

      if (!result && /^(?:-m|--source-map)$/.test(options[index - 1])) {
        sourceMapURL = value;
        return true;
      }
      return result;
    });

    // report invalid command and option arguments
    if (!_.isEmpty(invalidArgs)) {
      warnings.push('Invalid argument' + (_.size(invalidArgs) > 1 ? 's' : '') + ' passed: ' + invalidArgs.join(', '));
    }
    // report invalid command combinations
    invalidArgs = _.intersection(options, ['backbone', 'compat', 'modern', 'underscore']);

    if (isTemplate) {
      invalidArgs.push('template');
    }
    if (_.size(invalidArgs) > 1) {
      warnings.push('The `' + invalidArgs.slice(0, -1).join('`, `') + '`' + (_.size(invalidArgs) > 2 ? ',' : '') + ' and `' + invalidArgs.slice(-1) + '` commands may not be combined.');
    }
    // report invalid command entries
    _.forOwn({
      'category': {
        'entries': categoryOptions,
        'validEntries': allCategories
      },
      'exports': {
        'entries': exportsOptions,
        'validEntries': isModularize ? ['amd', 'commonjs', 'es6', 'node', 'npm'] : defaultExports
      },
      'include': {
        'entries': includeFuncs,
        'validEntries': allFuncs
      },
      'minus': {
        'entries': minusFuncs,
        'validEntries': allFuncs
      },
      'plus': {
        'entries': plusFuncs,
        'validEntries': allFuncs
      }
    }, function(data, commandName) {
      invalidArgs = _.difference(data.entries, data.validEntries, ['none']);
      if (!_.isEmpty(invalidArgs)) {
        warnings.push('Invalid `' + commandName + '` entr' + (_.size(invalidArgs) > 1 ? 'ies' : 'y') + ' passed: ' + invalidArgs.join(', '));
      }
    });

    if (!_.isEmpty(warnings)) {
      console.warn([''].concat(
        warnings,
        'For more information type: lodash --help'
      ).join('\n'));
      return;
    }
    // display help message
    if (getOption(options, '-h') || getOption(options, '--help')) {
      displayHelp();
      return;
    }
    // display `lodash.VERSION`
    if (getOption(options, '-V') || getOption(options, '--version')) {
      console.log(_.VERSION);
      return;
    }

    /*------------------------------------------------------------------------*/

    // names of functions to include in the build
    var buildFuncs = !isTemplate && (function() {
      var isUnderscoreChaining = _.contains(plusFuncs, 'chain') == !isUnderscore;

      source = setUseStrictOption(source, isStrict);

      if (isModularize) {
        if (isNode) {
          _.forOwn(varDepMap, function(depNames) {
            _.pull(depNames, 'root');
          });
          delete varDepMap.root;
        }
        funcDepMap.main = ['arrayEach', 'lodash', 'lodashWrapper', 'mixin'];
        objDepMap.main = ['support'];

        if (isUnderscoreChaining) {
          funcDepMap.main.push('assign');
        } else {
          funcDepMap.main.push('baseAssign', 'baseForOwn', 'baseFunctions', 'keys');
        }
        _.pull(funcDepMap.mixin, 'lodash');

        // replace `lodash` placeholders
        source = source.replace(/\b(placeholder\s*=\s*)lodash\b/, '$1{}');

        _.each(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function(funcName) {
          _.pull(funcDepMap[funcName], 'lodash');
        });
      }
      else {
        funcDepMap.chain.push('wrapperChain');
        funcDepMap.wrapperValueOf.push('arrayEach','chain', 'mixin');
        objDepMap.wrapperValueOf = ['support'];

        _.each(['chain', 'tap', 'wrapperChain'], function(funcName) {
          funcDepMap[funcName].push('wrapperValueOf');
        });

        if (isUnderscoreChaining) {
          funcDepMap.wrapperValueOf.push('assign');
        } else {
          funcDepMap.wrapperToString.push('wrapperValueOf');
          funcDepMap.wrapperValueOf.push('baseAssign', 'baseForOwn', 'wrapperToString');
        }
      }
      if (isModern) {
        source = removeIsFunctionFork(source);
        source = removeIsArgumentsFork(source);
        source = removeSupportSpliceObjects(source);

        // simplify `baseClone`
        _.pull(varDepMap.baseClone, 'root');

        source = source.replace(matchFunction(source, 'baseClone'), function(match) {
          return match.replace(/^(?: *\/\/.*\n)*( *)if\s*\(Ctor\s+instanceof\s+Ctor[\s\S]+?\n\1}\n/m, '');
        });

        // replace `_.isRegExp`
        if (isLodash('isRegExp')) {
          _.pull(funcDepMap.isRegExp, 'isObject');

          source = replaceFunction(source, 'isRegExp', [
            'function isRegExp(value) {',
            "  return (value && typeof value == 'object' && toString.call(value) == regexpClass) || false;",
            '}'
          ].join('\n'));
        }
      }
      if (isUnderscoreChaining) {
        source = addUnderscoreChaining(source, funcDepMap, isModularize);
      }
      if (isModern || (isUnderscore && _.isEmpty(plusFuncs))) {
        source = removeSupportEnumErrorProps(source);
        source = removeSupportEnumPrototypes(source, objDepMap);
        source = removeSupportNonEnumShadows(source);
        source = removeSupportNonEnumStrings(source, funcDepMap);
        source = removeSupportUnindexedChars(source, funcDepMap, objDepMap);

        source = removeSupportArgsClass(source, funcDepMap, objDepMap);
        source = removeSupportNodeClass(source, funcDepMap);
        source = removeSupportOwnLast(source);

        _.each(['baseClone', 'baseIsEqual', 'shimIsPlainObject'], function(funcName) {
          _.pull(objDepMap[funcName], 'support');
        });
      }
      if (isModern || isUnderscore) {
        // replace `_.keysIn`
        if (isLodash('keysIn') == !isUnderscore) {
          _.pull(funcDepMap.keysIn, 'arrayEach', 'isString');

          source = replaceFunction(source, 'keysIn', [
            'function keysIn(object) {',
            '  if (object == null) {',
            '    return [];',
            '  }',
            '  object = toObject(object);',
            '',
            '  var length = object.length;',
            "  length = (typeof length == 'number' && length > 0 &&",
            '    (isArray(object) || (support.nonEnumArgs && isArguments(object))) && length) >>> 0;',
            '',
            '  var keyIndex,',
            '      Ctor = object.constructor,',
            '      index = -1,',
            '      isProto = Ctor && object === Ctor.prototype,',
            '      maxIndex = length - 1,',
            '      result = Array(length),',
            '      skipIndexes = length > 0;',
            '',
            '  while (++index < length) {',
            '    result[index] = String(index);',
            '  }',
            '  for (var key in object) {',
            "    if (!(isProto && key == 'constructor') &&",
            '        !(skipIndexes && (keyIndex = +key, keyIndex > -1 && keyIndex <= maxIndex && keyIndex % 1 == 0))) {',
            '      result.push(key);',
            '    }',
            '  }',
            '  return result;',
            '}'
          ].join('\n'));
        }
      }
      if (isUnderscore) {
        // replace `lodash`
        if (!isLodash('lodash')) {
          _.pull(funcDepMap.lodash, 'isArray');

          source = replaceFunction(source, 'lodash', [
            'function lodash(value) {',
            '  return (value instanceof lodash)',
            '    ? value',
            '    : new lodashWrapper(value);',
            '}'
          ].join('\n'));
        }
        // replace `_.assign`
        if (!isLodash('assign')) {
          _.pull(funcDepMap.assign, 'baseAssign', 'createAssigner');

          source = replaceFunction(source, 'assign', [
            'function assign(object) {',
            '  if (object == null) {',
            '    return object;',
            '  }',
            '  var args = arguments,',
            '      index = 0,',
            '      length = args.length,',
            '      type = typeof args[2];',
            '',
            "  if ((type == 'number' || type == 'string') && args[3] && args[3][args[2]] === args[1]) {",
            '    length = 2;',
            '  }',
            '  while (++index < length) {',
            '    var source = args[index];',
            '    for (var key in source) {',
            '      object[key] = source[key];',
            '    }',
            '  }',
            '  return object;',
            '}'
          ].join('\n'));
        }
        // replace `_.bind`
        if (!isLodash('bind')) {
          _.pull(funcDepMap.bind, 'replaceHolders');

          source = replaceFunction(source, 'bind', [
            'function bind(func, thisArg) {',
            '  return arguments.length < 3',
            '    ? createWrapper([func, BIND_FLAG, null, thisArg])',
            '    : basePartial(func, BIND_FLAG | PARTIAL_FLAG, slice(arguments, 2), [], thisArg);',
            '}'
          ].join('\n'));
        }
        // replace `_.clone`
        if (!isLodash('baseClone') && !isLodash('clone') && !isLodash('cloneDeep')) {
          _.pull(funcDepMap.clone, 'baseClone', 'baseCallback').push('assign', 'isArray', 'isObject', 'slice');

          source = replaceFunction(source, 'clone', [
            'function clone(value) {',
            '  return isObject(value)',
            '    ? (isArray(value) ? slice(value) : assign({}, value))',
            '    : value;',
            '}'
          ].join('\n'));
        }
        // replace `_.contains`
        if (!isLodash('contains')) {
          _.pull(funcDepMap.contains, 'isArray', 'isNative', 'isString');

          source = replaceFunction(source, 'contains', [
            'function contains(collection, target) {',
            '  var length = collection ? collection.length : 0;',
            '',
            "  if (!(typeof length == 'number' && length > -1 && length <= MAX_SAFE_INTEGER)) {",
            '    collection = values(collection);',
            '  }',
            '  return getIndexOf(collection, target) > -1;',
            '}'
          ].join('\n'));
        }
        // replace `_.defaults`
        if (!isLodash('defaults')) {
          _.pull(funcDepMap.defaults, 'assign', 'assignDefaults', 'slice');

          source = replaceFunction(source, 'defaults', [
            'function defaults(object) {',
            '  if (object == null) {',
            '    return object;',
            '  }',
            '  var args = arguments,',
            '      index = 0,',
            '      length = args.length,',
            '      type = typeof args[2];',
            '',
            "  if ((type == 'number' || type == 'string') && args[3] && args[3][args[2]] === args[1]) {",
            '    length = 2;',
            '  }',
            '  while (++index < length) {',
            '    var source = args[index];',
            '    for (var key in source) {',
            "      if (typeof object[key] == 'undefined') {",
            '        object[key] = source[key];',
            '      }',
            '    }',
            '  }',
            '  return object;',
            '}'
          ].join('\n'));
        }
        // replace `baseDifference`
        if (!isLodash('baseDifference') && !isLodash('difference')) {
          _.pull(funcDepMap.baseDifference, 'cacheIndexOf', 'createCache');

          source = replaceFunction(source, 'baseDifference', [
            'function baseDifference(array, values) {',
            '  var length = array ? array.length : 0;',
            '  if (!length) {',
            '    return [];',
            '  }',
            '  var index = -1,',
            '      indexOf = getIndexOf(),',
            '      result = [];',
            '',
            '  while (++index < length) {',
            '    var value = array[index];',
            '    if (indexOf(values, value) < 0) {',
            '      result.push(value);',
            '    }',
            '  }',
            '  return result;',
            '}'
          ].join('\n'));
        }
        // replace `_.drop`
        if (!isLodash('drop')) {
          funcDepMap.drop = ['rest'];
          source = replaceFunction(source, 'drop', 'var drop = rest;');
        }
        // replace `_.first`
        if (!isLodash('first')) {
          funcDepMap.first.push('slice');

          source = replaceFunction(source, 'first', [
            'function first(array, n, guard) {',
            '  if (n == null || guard) {',
            '    return array ? array[0] : undefined;',
            '  }',
            '  return slice(array, 0, n < 0 ? 0 : n);',
            '}'
          ].join('\n'));
        }
        // replace `_.initial`
        if (!isLodash('initial')) {
          source = replaceFunction(source, 'initial', [
            'function initial(array, n, guard) {',
            '  var length = array ? array.length : 0;',
            '  if (n == null || guard) {',
            '    n = 1;',
            '  }',
            '  n = length - (n || 0);',
            '  return slice(array, 0, n < 0 ? 0 : n);',
            '}'
          ].join('\n'));
        }
        // replace `_.intersection`
        if (!isLodash('intersection')) {
          _.pull(funcDepMap.intersection, 'cacheIndexOf', 'createCache');

          source = replaceFunction(source, 'intersection', [
            'function intersection() {',
            '  var args = [],',
            '      argsIndex = -1,',
            '      argsLength = arguments.length;',
            '',
            '  while (++argsIndex < argsLength) {',
            '    var value = arguments[argsIndex];',
            '     if (isArray(value) || isArguments(value)) {',
            '       args.push(value);',
            '     }',
            '  }',
            '  argsLength = args.length;',
            '  var array = args[0],',
            '      index = -1,',
            '      indexOf = getIndexOf(),',
            '      length = array ? array.length : 0,',
            '      result = [];',
            '',
            '  outer:',
            '  while (++index < length) {',
            '    value = array[index];',
            '    if (indexOf(result, value) < 0) {',
            '      var argsIndex = argsLength;',
            '      while (--argsIndex) {',
            '        if (indexOf(args[argsIndex], value) < 0) {',
            '          continue outer;',
            '        }',
            '      }',
            '      result.push(value);',
            '    }',
            '  }',
            '  return result;',
            '}'
          ].join('\n'));
        }
        // replace `_.invert`
        if (!isLodash('invert')) {
          source = replaceFunction(source, 'invert', [
            'function invert(object) {',
            '  var index = -1,',
            '      props = keys(object),',
            '      length = props.length,',
            '      result = {};',
            '',
            '  while (++index < length) {',
            '    var key = props[index];',
            '    result[object[key]] = key;',
            '  }',
            '  return result;',
            '}'
          ].join('\n'));
        }
        // replace `_.isElement`
        if (!isLodash('isElement')) {
          source = removeSupportDom(source, objDepMap);
          funcDepMap.isElement = [];

          source = replaceFunction(source, 'isElement', [
            'function isElement(value) {',
            '  return (value && value.nodeType === 1) || false;',
            '}'
          ].join('\n'));
        }
        // replace `_.isEqual`
        if (!isLodash('baseIsEqual') && !isLodash('isEqual')) {
          _.pull(funcDepMap.isEqual, 'baseCallback', 'isStrictComparable');
          _.pull(funcDepMap.baseIsEqual, 'isArguments', 'isNode');
          _.pull(objDepMap.baseIsEqual, 'support');

          source = replaceFunction(source, 'isEqual', [
            'function isEqual(value, other) {',
            '  return baseIsEqual(value, other);',
            '}'
          ].join('\n'));

          source = replaceFunction(source, 'baseIsEqual', [
            'function baseIsEqual(value, other, stackA, stackB) {',
            '  if (value === other) {',
            '    return value !== 0 || (1 / value == 1 / other);',
            '  }',
            '  var valType = typeof value,',
            '      othType = typeof other;',
            '',
            '  if (value === value && (value == null || other == null ||',
            "      (valType != 'function' && valType != 'object' && othType != 'function' && othType != 'object'))) {",
            '    return false;',
            '  }',
            '  var valClass = toString.call(value),',
            '      othClass = toString.call(other);',
            '',
            '  if (valClass != othClass) {',
            '    return false;',
            '  }',
            '  switch (valClass) {',
            '    case boolClass:',
            '    case dateClass:',
            '      return +value == +other;',
            '',
            '    case numberClass:',
            '      return value != +value',
            '        ? other != +other',
            '        : (value == 0 ? (1 / value == 1 / other) : value == +other);',
            '',
            '    case regexpClass:',
            '    case stringClass:',
            '      return value == String(other);',
            '  }',
            '  var isArr = arrayLikeClasses[valClass];',
            '  if (!isArr) {',
            '    if (valClass != objectClass) {',
            '      return false;',
            '    }',
            "    var valWrapped = hasOwnProperty.call(value, '__wrapped__'),",
            "        othWrapped = hasOwnProperty.call(other, '__wrapped__');",
            '',
            '    if (valWrapped || othWrapped) {',
            '      return baseIsEqual(valWrapped ? value.__wrapped__ : value, othWrapped ? other.__wrapped__ : other, stackA, stackB);',
            '    }',
            "    var hasValCtor = hasOwnProperty.call(value, 'constructor'),",
            "        hasOthCtor = hasOwnProperty.call(other, 'constructor');",
            '',
            '    if (hasValCtor != hasOthCtor) {',
            '      return false;',
            '    }',
            '    if (!hasValCtor) {',
            '      var valCtor = value.constructor,',
            '          othCtor = other.constructor;',
            '',
            '      if (valCtor != othCtor &&',
            '            !(isFunction(valCtor) && valCtor instanceof valCtor && isFunction(othCtor) && othCtor instanceof othCtor) &&',
            "            ('constructor' in value && 'constructor' in other)",
            '          ) {',
            '        return false;',
            '      }',
            '    }',
            '  }',
            '  stackA || (stackA = []);',
            '  stackB || (stackB = []);',
            '',
            '  var length = stackA.length;',
            '  while (length--) {',
            '    if (stackA[length] == value) {',
            '      return stackB[length] == other;',
            '    }',
            '  }',
            '  stackA.push(value);',
            '  stackB.push(other);',
            '',
            '  if (isArr) {',
            '    length = value.length;',
            '    var result = length == other.length;',
            '',
            '    if (result) {',
            '      while (length--) {',
            '        result = baseIsEqual(value[length], other[length], stackA, stackB);',
            '        if (!result) {',
            '          break;',
            '        }',
            '      }',
            '    }',
            '  }',
            '  else {',
            '    var props = keys(value);',
            '    length = props.length;',
            '    result = length == keys(other).length;',
            '',
            '    if (result) {',
            '      while (length--) {',
            '        var key = props[length];',
            '        result = hasOwnProperty.call(other, key) && baseIsEqual(value[key], other[key], stackA, stackB);',
            '        if (!result) {',
            '          break;',
            '        }',
            '      }',
            '    }',
            '  }',
            '  stackA.pop();',
            '  stackB.pop();',
            '',
            '  return result;',
            '}'
          ].join('\n'));

           // replace complex lodash wrapper checks with simpler ones
          if (!isModularize) {
            source = source.replace(matchFunction(source, 'baseIsEqual'), function(match) {
              return match.replace(/hasOwnProperty\.call\(([$\w]+),\s*'__wrapped__'\)/g, '$1 instanceof lodash')
            });
          }
        }
        // replace `_.isFinite`
        if (!isLodash('isFinite')) {
          _.pull(funcDepMap.isFinite, 'isNative');

          source = replaceFunction(source, 'isFinite', [
            'function isFinite(value) {',
            '  value = parseFloat(nativeIsFinite(value) && value);',
            '  return value == value;',
            '}'
          ].join('\n'));
        }
        // replace `_.keys`, `_.keysIn`, and `shimKeys`
        if (!isLodash('keys') && !isLodash('keysIn')) {
          source = removeSupportNonEnumArgs(source);

          _.pull(funcDepMap.keys, 'toObject').push('isObject');
          _.pull(funcDepMap.keysIn, 'isArguments', 'isArray', 'isString', 'toObject').push('isObject');
          _.pull(funcDepMap.shimKeys, 'isArguments', 'isArray', 'isString');

          _.each(['keys', 'keysIn', 'shimKeys'], function(funcName) {
            _.pull(objDepMap[funcName], 'support');
          });

          source = replaceFunction(source, 'keys', [
            'var keys = !nativeKeys ? shimKeys : function(object) {',
            '  return isObject(object) ? nativeKeys(object) : [];',
            '};'
          ].join('\n'));

          source = replaceFunction(source, 'keysIn', [
            'function keysIn(object) {',
            '  var result = [];',
            '  if (!isObject(object)) {',
            '    return result;',
            '  }',
            '  for (var key in object) {',
            '    result.push(key);',
            '  }',
            '  return result;',
            '}'
          ].join('\n'));

          source = replaceFunction(source, 'shimKeys', [
            'function shimKeys(object) {',
            '  var index = -1,',
            '      props = keysIn(object),',
            '      length = props.length,',
            '      result = [];',
            '',
            '  while (++index < length) {',
            '    var key = props[index];',
            '    if (hasOwnProperty.call(object, key)) {',
            '      result.push(key);',
            '    }',
            '  }',
            '  return result;',
            '}'
          ].join('\n'));
        }
        // replace `_.last`
        if (!isLodash('last')) {
          funcDepMap.last.push('slice');

          source = replaceFunction(source, 'last', [
            'function last(array, n, guard) {',
            '  var length = array ? array.length : 0;',
            '  if (n == null || guard) {',
            '    return array ? array[length - 1] : undefined;',
            '  }',
            '  n = length - (n || 0);',
            '  return slice(array, n < 0 ? 0 : n);',
            '}'
            ].join('\n'));
        }
        // replace `_.matches`
        if (!isLodash('matches')) {
          _.pull(funcDepMap.matches, 'baseClone', 'baseIsEqual', 'isStrictComparable', 'keys').push('pairs');

          source = replaceFunction(source, 'matches', [
            'function matches(source) {',
            '  var keyVals = pairs(source),',
            '      length = keyVals.length;',
            '',
            '  return function(object) {',
            '    var index = length;',
            '    if (object == null) {',
            '      return !index;',
            '    }',
            '    while (index--) {',
            '      var keyVal = keyVals[index];',
            '      if (object[keyVal[0]] !== keyVal[1]) {',
            '        return false',
            '      }',
            '    }',
            '    index = length;',
            '    while (index--) {',
            '      if (!hasOwnProperty.call(object, keyVals[index][0])) {',
            '        return false',
            '      }',
            '    }',
            '    return true;',
            '  };',
            '}'
          ].join('\n'));
        }
        // replace `_.memoize`
        if (!isLodash('memoize')) {
           source = replaceFunction(source, 'memoize', [
              'function memoize(func, resolver) {',
              '  if (!isFunction(func) || (resolver && !isFunction(resolver))) {',
              '    throw new TypeError(funcErrorText);',
              '  }',
              '  var cache = {};',
              '  return function() {',
              "    var key = resolver ? resolver.apply(this, arguments) : arguments[0];",
              "    if (key == '__proto__') {",
              '      return func.apply(this, arguments);',
              '    }',
              '    return hasOwnProperty.call(cache, key)',
              '      ? cache[key]',
              '      : (cache[key] = func.apply(this, arguments));',
              '  };',
              '}'
          ].join('\n'));
        }
        // replace `_.omit`
        if (!isLodash('omit')) {
          _.pull(funcDepMap.omit, 'getCallback', 'negate');

          source = replaceFunction(source, 'omit', [
            'function omit(object) {',
            '  if (object == null) {',
            '    return {};',
            '  }',
            '  var omitProps = baseFlatten(arguments, false, false, 1);',
            '  return basePick(toObject(object), baseDifference(keysIn(object), arrayMap(omitProps, String)));',
            '}'
          ].join('\n'));
        }
        // replace `_.pick`
        if (!isLodash('pick')) {
          _.pull(funcDepMap.pick, 'getCallback');

          source = replaceFunction(source, 'pick', [
            'function pick(object) {',
            '  return object == null',
            '    ? {}',
            '    : basePick(toObject(object), baseFlatten(arguments, false, false, 1));',
            '}'
          ].join('\n'));
        }
        // replace `_.random`
        if (!isLodash('random')) {
          _.pull(funcDepMap.random, 'baseRandom');

          source = replaceFunction(source, 'random', [
            'function random(min, max) {',
            '  if (min == null && max == null) {',
            '    max = 1;',
            '  }',
            '  min = +min || 0;',
            '  if (max == null) {',
            '    max = min;',
            '    min = 0;',
            '  } else {',
            '    max = +max || 0;',
            '  }',
            '  return min + floor(nativeRandom() * (max - min + 1));',
            '}'
          ].join('\n'));
        }
        // replace `_.rest`
        if (!isLodash('rest')) {
          source = replaceFunction(source, 'rest', [
            'function rest(array, n, guard) {',
            '  if (n == null || guard) {',
            '    n = 1;',
            '  } else {',
            '    n = n < 0 ? 0 : n;',
            '  }',
            '  return slice(array, n);',
            '}'
            ].join('\n'));
        }
        // replace `_.result`
        if (!isLodash('result')) {
          source = replaceFunction(source, 'result', [
            'function result(object, key) {',
            '  if (object != null) {',
            '    var value = object[key];',
            '    return isFunction(value) ? object[key]() : value;',
            '  }',
            '}'
          ].join('\n'));
        }
        // replace `_.sortBy`
        if (!isLodash('sortBy')) {
          _.pull(funcDepMap.sortBy, 'compareMultipleAscending', 'isArray');

          source = replaceFunction(source, 'sortBy', [
            'function sortBy(collection, iterator, thisArg) {',
            '  var index = -1,',
            '      length = collection && collection.length,',
            '      result = Array(length < 0 ? 0 : length >>> 0);',
            '',
            '  iterator = getCallback(iterator, thisArg, 3);',
            '  baseEach(collection, function(value, key, collection) {',
            '    result[++index] = {',
            "      'criteria': iterator(value, key, collection),",
            "      'index': index,",
            "      'value': value",
            '    };',
            '  });',
            '',
            '  length = result.length;',
            '  result.sort(compareAscending);',
            '  while (length--) {',
            '    result[length] = result[length].value;',
            '  }',
            '  return result;',
            '}'
          ].join('\n'));
        }
        // replace `_.take`
        if (!isLodash('take')) {
          funcDepMap.take = ['first'];
          source = replaceFunction(source, 'take', 'var take = first;');
        }
        // replace `_.tap`
        if (!isLodash('tap')) {
          source = replaceFunction(source, 'tap', [
            'function tap(value, interceptor) {',
            '  interceptor(value);',
            '  return value;',
            '}'
          ].join('\n'));
        }
        // replace `_.template`
        if (!isLodash('template')) {
          _.pull(funcDepMap.template, 'assign', 'assignOwnDefaults', 'keys', 'values').push('defaults');
          _.pull(varDepMap.template, 'reInterpolate');

          source = replaceFunction(source, 'template', [
            'function template(string, data, options) {',
            '  var _ = lodash,',
            '      settings = _.templateSettings;',
            '',
            "  string = String(string == null ? '' : string);",
            '  options = defaults({}, options, settings);',
            '',
            '  var index = 0,',
            '      source = "__p += \'",',
            '      variable = options.variable;',
            '',
            '  var reDelimiters = RegExp(',
            "    (options.escape || reNoMatch).source + '|' +",
            "    (options.interpolate || reNoMatch).source + '|' +",
            "    (options.evaluate || reNoMatch).source + '|$'",
            "  , 'g');",
            '',
            '  string.replace(reDelimiters, function(match, escapeValue, interpolateValue, evaluateValue, offset) {',
            '    source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);',
            '    if (escapeValue) {',
            '      source += "\' +\\n_.escape(" + escapeValue + ") +\\n\'";',
            '    }',
            '    if (evaluateValue) {',
            '      source += "\';\\n" + evaluateValue + ";\\n__p += \'";',
            '    }',
            '    if (interpolateValue) {',
            '      source += "\' +\\n((__t = (" + interpolateValue + ")) == null ? \'\' : __t) +\\n\'";',
            '    }',
            '    index = offset + match.length;',
            '    return match;',
            '  });',
            '',
            '  source += "\';\\n";',
            '  if (!variable) {',
            "    source = 'with (obj || {}) {\\n' + source + '\\n}\\n';",
            '  }',
            "  source = 'function(' + (variable || 'obj') + ') {\\n' +",
            '    "var __t, __p = \'\', __j = Array.prototype.join;\\n" +',
            '    "function print() { __p += __j.call(arguments, \'\') }\\n" +',
            '    source +',
            "    'return __p\\n}';",
            '',
            '  var result = attempt(function() {',
            "    return Function('_', 'return ' + source)(_);",
            '  });',
            '',
            '  result.source = source;',
            '  if (isError(result)) {',
            '    throw result;',
            '  }',
            '  return data ? result(data) : result;',
            '}'
          ].join('\n'));
        }
        // replace `_.throttle`
        if (!isLodash('throttle')) {
          source = replaceFunction(source, 'throttle', [
            'function throttle(func, wait, options) {',
            '  var leading = true,',
            '      trailing = true;',
            '',
            '  if (!isFunction(func)) {',
            '    throw new TypeError(funcErrorText);',
            '  }',
            '  if (options === false) {',
            '    leading = false;',
            '  } else if (isObject(options)) {',
            "    leading = 'leading' in options ? options.leading : leading;",
            "    trailing = 'trailing' in options ? options.trailing : trailing;",
            '  }',
            '  return debounce(func, wait, {',
            "    'leading': leading,",
            "    'maxWait': wait,",
            "    'trailing': trailing",
            '  });',
            '}'
          ].join('\n'));
        }
        // replace `baseUniq`
        if (!isLodash('baseUniq') && !isLodash('uniq')) {
          _.pull(funcDepMap.baseUniq, 'cacheIndexOf', 'createCache');

          source = replaceFunction(source, 'baseUniq', [
            'function baseUniq(array, iterator) {',
            '  var index = -1,',
            '      indexOf = getIndexOf(),',
            '      length = array.length,',
            '      result = [],',
            '      seen = iterator ? [] : result;',
            '',
            '  while (++index < length) {',
            '    var value = array[index],',
            '        computed = iterator ? iterator(value, index, array) : value;',
            '',
            '    if (indexOf(seen, computed) < 0) {',
            '      if (iterator) {',
            '        seen.push(computed);',
            '      }',
            '      result.push(value);',
            '    }',
            '  }',
            '  return result;',
            '}'
          ].join('\n'));
        }
        // replace `_.uniqueId`
        if (!isLodash('uniqueId')) {
          source = replaceFunction(source, 'uniqueId', [
            'function uniqueId(prefix) {',
            "  var id = ++idCounter + '';",
            '  return prefix ? prefix + id : id;',
            '}'
          ].join('\n'));
        }
        // replace decimal NCRs with hexadecimal NCRs in `htmlEscapes`
        if (!isLodash('escape')) {
          _.each(['htmlEscapes', 'htmlUnescapes', 'reEscapedHtml'], function(varName) {
            source = source.replace(matchVar(source, varName), function(match) {
              return match.replace(/#39/g, '#x27');
            });
          });
        }
        // replace `isDeep` with `!isDeep` in `_.flatten`
        if (!isLodash('flatten')) {
          source = source.replace(matchFunction(source, 'flatten'), function(match) {
            return match.replace(/\b(baseFlatten\([^)]+?)isDeep\b/, '$1!isDeep');
          });
        }
        // remove `_.prototype.toString`
        if (!isModularize && !isLodash('chain')) {
          _.pull(funcDepMap.wrapperValueOf, 'wrapperToString');
        }
        // remove `_.bindKey` support from `baseCreateWrapper` and `createWrapper`
        if (!isLodash('bindKey')) {
          source = source.replace(matchFunction(source, 'baseCreateWrapper'), function(match) {
            return match.replace(/^( *)if\s*\(isBindKey\b[\s\S]+?\n\1}\n/m, '');
          });

          source = source.replace(matchFunction(source, 'createWrapper'), function(match) {
            return match
              .replace(/!isBindKey *&& */, '')
              .replace(/^( *)if\s*\(arity\b(?:[\s\S]+?\n\1}){2}\n/m, '');
          });
        }
        // remove `_.curry` support from `baseCreateWrapper`
        if (!isLodash('curry')) {
          _.pull(funcDepMap.baseCreateWrapper, 'replaceHolders');

          source = source.replace(matchFunction(source, 'baseCreateWrapper'), function(match) {
            return match.replace(/^( *)if\s*\(isCurry\b[\s\S]+?\n\1}\n/gm, '');
          });
        }
        // remove extended array-like object support from `_.isEmpty`
        if (!isLodash('isEmpty')) {
          _.pull(funcDepMap.isEmpty, 'isFunction');

          source = source.replace(matchFunction(source, 'isEmpty'), function(match) {
            return match.replace(/\s*\|\|\s*\(typeof value\b[\s\S]+?\)\)/, '');
          });
        }
        // remove `_.sortedLastIndex` support from `_.lastIndexOf`
        if (!isLodash('lastIndexOf')) {
          _.pull(funcDepMap.lastIndexOf, 'sortedLastIndex');

          source = source.replace(matchFunction(source, 'lastIndexOf'), function(match) {
            return match.replace(/\s*else\s+if\s*\(fromIndex\b[^}]+}/, '');
          });
        }
        // remove `_.partialRight` support from `baseCreateWrapper`
        if (!isLodash('partialRight')) {
          _.pull(funcDepMap.baseCreateWrapper, 'composeArgsRight');

          _.each(['baseCreateWrapper', 'createWrapper'], function(funcName) {
            source = source.replace(matchFunction(source, funcName), function(match) {
              return match
                .replace(/,\s*partialRightHolders(?:\s*=[\s\S]+?(?=[,;]\n))?/g, '')
                .replace(/^( *)if\s*\((?:isPartialRight|partialRightArgs)\b[\s\S]+?\n\1}\n/gm, '');
            });
          });
        }
        // remove support for a `step` of `0` in `_.range`
        if (!isLodash('range')) {
          source = source.replace(matchFunction(source, 'range'), function(match) {
            return match.replace(/\bstep\s*==\s*null\b[^;]+/, '+step || 1');
          });
        }
        source = removeEsOptimization(source, funcDepMap, objDepMap, varDepMap);

        // remove conditional `charCodeCallback` use from `_.max` and `_.min`
        _.each(['max', 'min'], function(funcName) {
          if (!isLodash(funcName)) {
            _.pull(funcDepMap[funcName], 'charAtCallback', 'isArray', 'isString');

            source = source.replace(matchFunction(source, funcName), function(match) {
              match = removeVar(match, 'noIterator');
              match = removeVar(match, 'isArr');
              match = removeVar(match, 'isStr');

              return match
                .replace(/\s*&&\s*\!isStr\b/, '')
                .replace(/=.+?isStr[^:]+:\s*/g, '= ')
                .replace(/\bnoIterator\b/, 'iterator == null');
            });
          }
        });

        // unexpose "exit early" feature from functions
        if (!isLodash('forEach') && !isLodash('forEachRight') &&
            !isLodash('forIn') && !isLodash('forInRight') &&
            !isLodash('forOwn') && !isLodash('forOwnRight')) {

          source = source.replace(matchVar(source, 'EXPANDO'), function(match) {
            return match + [
              '',
              '  /** Used by methods to exit iteration */',
              "  var breakIndicator = EXPANDO + 'breaker__';",
              ''
            ].join('\n');
          });

          source = source.replace(matchFunction(source, 'baseEvery'), function(match) {
            return match.replace(/^( *)result\s*=[\s\S]+?;\n\1return\s+result\b/gm, '$& || breakIndicator');
          });

          source = source.replace(matchFunction(source, 'baseSome'), function(match) {
            return match.replace(/^(( *)result\s*=[\s\S]+?;\n\2return\s*)!result\b/m, '$1result && breakIndicator');
          });

          source = source.replace(matchFunction(source, 'transform'), function(match) {
            return match.replace(/\breturn\s+iterator[^)]+\)/, '$& === false && breakIndicator');
          });

          _.each(['arrayEach', 'arrayEachRight', 'baseEach', 'baseEachRight', 'baseFor', 'baseForRight'], function(funcName) {
            source = source.replace(matchFunction(source, funcName), function(match) {
              return match.replace(/===\s*false\b/g, '=== breakIndicator');
            });
          });

          _.each(['baseFind', 'shimIsPlainObject'], function(funcName) {
            source = source.replace(matchFunction(source, funcName), function(match) {
              return match.replace(/\breturn\s+false\b/, 'return breakIndicator');
            });
          });
        }
      }
      if (isModularize || !isLodash('callback')) {
        source = removeGetCallback(source, funcDepMap);
      }
      if (isModularize) {
        source = removeGetIndexOf(source, funcDepMap);
      }
      // remove "_.pluck" or "_.where" style callback support from `baseCallback`
      _.each(['pluck', 'where'], function(funcName) {
        if (_.contains(minusFuncs, funcName)) {
          _.pull(funcDepMap.baseCallback, funcName);
          funcDepMap.baseCallback.push('identity');

          source = source.replace(matchFunction(source, 'baseCallback'), function(match) {
            var otherName = funcName == 'where' ? 'matches' : 'property';
            _.pull(funcDepMap.baseCallback, otherName);
            return match.replace(RegExp('\\b' + otherName + '\\([^)]+\\)', 'm'), 'identity');
          });
        }
      });

      // add function names explicitly
      if (!_.isEmpty(includeFuncs)) {
        var result = includeFuncs;
      }
      // add default function names
      if (_.isEmpty(includeObjs) && _.isEmpty(includeVars)) {
        if (isBackbone && !result) {
          result = backboneDependencies;
        }
        else if (isUnderscore && !result) {
          result = underscoreFuncs;
        }
        if (!result) {
          result = lodashFuncs.slice();
        }
      }
      // remove special "none" entry
      if (result == 'none') {
        result = [];
      } else {
        _.pull(result, 'none');
      }
      // add and subtract function names
      if (!_.isEmpty(plusFuncs)) {
        result = _.union(result, plusFuncs);
      }
      if (!_.isEmpty(minusFuncs)) {
        result = _.difference(result, minusFuncs.concat(getDependants(minusFuncs, funcDepMap)));
      }
      if (isModularize) {
        _.pull(result, 'runInContext');
      }
      return getDependencies(result, funcDepMap);
    }());

    // expand properties, variables, and their function dependencies to include in the build
    (function() {
      function expand(includes, allDeps, depMap, funcNames, stack) {
        stack || (stack = []);
        _.each(funcNames || buildFuncs, function(funcName) {
          if (_.contains(stack, funcName)) {
            return;
          }
          stack.push(funcName);
          _.each([varDepMap, objDepMap], function(otherDepMap) {
            var depNames = otherDepMap[funcName];
            if (depNames) {
              var validDeps = _.transform(depNames, function(result, depName) {
                var depNames = depMap[depName];
                push.apply(result, depNames || []);
              });

              push.apply(validDeps, _.filter(depNames, _.partial(_.contains, allDeps, _, 0)));

              var otherNames = _.transform(validDeps, function(result, depName) {
                push.apply(result, getDependencies(funcDepMap[depName], funcDepMap));
              });

              push.apply(includes, validDeps);
              push.apply(buildFuncs, otherNames);
              expand(includes, allDeps, depMap, otherNames, stack);
            }
          });
        });
      }
      if (_.contains(buildFuncs, 'lodash')) {
        push.apply(buildFuncs, getDependencies(funcDepMap.main, funcDepMap));
        push.apply(includeObjs, objDepMap.main);
        push.apply(includeVars, varDepMap.main);
      }
      expand(includeObjs, objDependencies, objDepMap);
      expand(includeVars, varDependencies, varDepMap);

      buildFuncs = _.uniq(buildFuncs);
      includeObjs = _.union(includeObjs, _.intersection(objDependencies, includeVars));
      includeVars = _.union(includeVars, _.intersection(varDependencies, includeObjs));
    }());

    /*------------------------------------------------------------------------*/

    // load customized Lo-Dash module
    var lodash = !isTemplate && (function() {
      var context = vm.createContext({
        'clearTimeout': clearTimeout,
        'console': console,
        'setTimeout': setTimeout
      });

      vm.runInContext(source, context);
      return context._;
    }());

    /*------------------------------------------------------------------------*/

    if (isTemplate) {
      source = buildTemplate({
        'moduleId': moduleId,
        'source': source,
        'templatePattern': templatePattern,
        'templateSettings': templateSettings
      });
    }
    else {
      if (isUnderscore) {
        // unexpose Lo-Dash methods for the Underscore build
        source = source.replace(getMethodAssignments(source), function(match) {
          var unexpose = lodashOnlyFuncs.concat('assign', 'zipObject');

          return _.reduce(unexpose, function(result, funcName) {
            if (isLodash(funcName)) {
              return result;
            }
            return result.replace(RegExp('^( *//.*\\n)* *lodash\\.' + funcName + '\\s*=[\\s\\S]+?;\\n(\\n)?', 'gm'), function(match, comment, newline) {
              return (!newline && comment) || newline || '';
            });
          }, match);
        });

        if (!isModularize) {
          // remove `_.templateSettings.imports assignment
          source = source.replace(/,[^']*'imports':[^}]+}/, '');

          // unexpose `lodash.support`
          if (!isLodash('support')) {
            source = source.replace(/\blodash\.support\s*=\s*/, '');
          }
        }
      }
      if (isModularize) {
        // replace the `lodash.templateSettings` property assignment with a variable assignment
        source = source.replace(/\b(lodash\.)(?=templateSettings\s*=)/, 'var ');

        // remove the `lodash` namespace from properties
        source = source.replace(/\blodash\.(?!com|prototype)([$\w]+)\b(?!\s*=)/g, '$1');

        // remove all horizontal rule comment separators
        source = source.replace(/^ *\/\*-+\*\/\n/gm, '');

        // remove `lodash` branch in `_.mixin`
        source = source.replace(matchFunction(source, 'mixin'), function(match) {
          return match.replace(/^(?: *\/\/.*\n)*( *)if\s*\(!source\b[\s\S]+?\n\1}\n+/m, '');
        });

        // replace `lodash` use in `_.templateSettings.imports`
        source = source.replace(matchProp(source, 'templateSettings'), function(match) {
          return match.replace(/(:\s*)lodash\b/, "$1{ 'escape': escape }");
        });

        source = source.replace(matchFunction(source, 'template'), function(match) {
          if (isUnderscore) {
            // assign `_` using `template.imports`
            return match
              .replace(/(_\s*=\s*)lodash\b/, '$1templateSettings.imports._')
              .replace(/=\s*_\.templateSettings(?=[,;])/, '$& || templateSettings');
          }
          // assign `settings` using `template.imports`
          match = match.replace(/=\s*templateSettings(?=[,;])/, '$&.imports._.templateSettings || templateSettings');

          // remove `sourceURL` from `_.template`
          match = removeVar(match, 'sourceURL');
          match = match.replace(/^(?: *\/\/.*\n)* *sourceURL\s*=[^;]+;\n+/m, '');
          return match.replace(/\s*\+\s*sourceURL(?=\))/, '');
        });

        if (isNode) {
          source = source.replace(/\bcontext(?=\.)/g, 'global');
        }
        if (!isAMD) {
          source = removeVar(source, 'undefined');
        }
        source = removeRunInContext(source);
      }
    }

    /*------------------------------------------------------------------------*/

    // set the AMD module id
    if (isAMD && !isModularize && !isTemplate && moduleId != null && moduleId != 'none') {
      source = source.replace(/^ *define\((?=function)/m, "$&'" + moduleId + "', ");
    }
    // customize Lo-Dash's export bootstrap
    if (!isAMD || isModularize) {
      source = source.replace(/^(?: *\/\/.*\n)*( *)if\s*\(typeof\s+define\b[\s\S]+?else\s+/m, '$1');
    }
    if (!isNode || isModularize) {
      source = source.replace(/^(?: *\/\/.*\n)*( *)if\s*\(moduleExports\b[\s\S]+?else\s*\{([\s\S]+?\n)\1}\n+/m, '$1$2');
    }
    if (!isCommonJS || isModularize) {
      source = source.replace(/^(?: *\/\/.*\n)*(?:(( *)}?)\s*else\s*\{)?\s*freeExports\.[$\w]+\s*=[\s\S]+?(?:\n\2})?\n+/m, function(match, prelude) {
        return prelude ? prelude + '\n' : '';
      });
    }
    if (!isGlobal || isModularize) {
      source = source.replace(/^(?: *\/\/.*\n)*(?:(( *)}?)\s*else(?:\s*if\s*\(_\))?\s*\{)?(?:\s*\/\/.*)*\s*(?:root\._|_\.templates)\s*=[\s\S]+?(?:\n\2})?\n+/gm, function(match, prelude) {
        return prelude ? prelude + '\n' : '';
      });
    }
    // remove `if (freeExports && freeModule) {...}` if it's empty
    if (isAMD && isGlobal && !isModularize) {
      source = source.replace(/^(?: *\/\/.*\n)* *(?:else\s+)?if\s*\(freeExports.*?\)\s*\{\s*}\n+/m, '');
    } else {
      source = source.replace(/^(?: *\/\/.*\n)* *(?:else\s+)?if\s*\(freeExports.*?\)\s*\{\s*}(?:\s*else\s*\{([\s\S]+?)\s*})?\n+/m, '$1\n');
    }

    /*------------------------------------------------------------------------*/

    // exit early to create modules
    if (isModularize) {
      buildModule({
        'buildFuncs': buildFuncs,
        'filePath': filePath,
        'funcDepMap': funcDepMap,
        'includeFuncs': includeFuncs,
        'includeObjs': includeObjs,
        'includeVars': includeVars,
        'isAMD': isAMD,
        'isCommonJS': isCommonJS,
        'isES6': isES6,
        'isModern': isModern,
        'isNode': isNode,
        'isNpm': isNpm,
        'isSilent': isSilent,
        'isStdOut': isStdOut,
        'isStrict': isStrict,
        'isUnderscore': isUnderscore,
        'lodash': lodash,
        'objDepMap': objDepMap,
        'options': options,
        'outputPath': outputPath,
        'source': source,
        'varDepMap': varDepMap
      }, callback);
      return;
    }
  }

  /*--------------------------------------------------------------------------*/

  // modify/remove references to removed functions/variables
  if (!isTemplate) {
    if (isExcluded('lodash')) {
      // remove `lodashWrapper.prototype` assignment
      source = source.replace(/^(?: *\/\/.*\n)* *lodashWrapper\.prototype\s*=.+\n/m, '');
    }
    if (isExcluded(isModularize ? 'main' : 'mixin')) {
      source = removeMixinCalls(source);
    }
    if (isExcluded(isModularize ? 'main' : 'wrapperValueOf')) {
      source = removeChaining(source);
    }
    if (isModularize) {
      if (isExcluded('main')) {
        source = removeAssignments(source);
      }
    }
    else {
      if (isExcluded('clone', 'isElement', 'isEqual', 'isPlainObject')) {
        source = removeSupportNodeClass(source);
      }
      if (isExcluded('isArguments')) {
        source = replaceSupportProp(source, 'argsClass', 'true');
      }
      if (isExcluded('baseClone', 'baseIsEqual', 'isArguments', 'isPlainObject')) {
        source = removeSupportArgsClass(source);
      }
      if (isExcluded('isElement')) {
        source = removeSupportDom(source);
      }
      if (isExcluded('isPlainObject')) {
        source = removeSupportOwnLast(source);
      }
      if (isExcluded('keysIn')) {
        source = removeSupportNonEnumShadows(source);
      }
      if (isExcluded('keysIn', 'shimKeys')) {
        source = removeSupportNonEnumArgs(source);
        source = removeSupportNonEnumStrings(source);
      }
      if (isExcluded('wrapperValueOf')) {
        source = removeChaining(source);
      }
    }
    // remove functions from the build
    _.each(allFuncs, function(funcName) {
      if (!_.contains(buildFuncs, funcName) &&
          !(funcName == 'lodash' && !isModularize)) {
        source = removeFunction(source, funcName);
        if (!isModularize) {
          source = removeMethodAssignment(source, funcName);
        }
      }
    });

    // remove forks of removed functions
    _.forOwn({
      'baseCreate': removeBaseCreateFork,
      'cloneBuffer': removeCloneBufferFork,
      'isArguments': removeIsArgumentsFork,
      'isArray': removeIsArrayFork,
      'isElement': removeIsElementFork,
      'isFunction': removeIsFunctionFork,
      'now': removeNowFork,
      'parseInt': removeParseIntFork,
    },
    function(removeFork, funcName) {
      if (isExcluded(funcName)) {
        source = removeFork(source);
      }
    });

    // remove placeholder assignments of removed functions
    source = source.replace(/^(?: *\/\/.*\n)* *(?:[$\w]+\.placeholder\s*=\s*){2,}[\s\S]+?;\n/m, function(match) {
      _.each(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function(funcName) {
        if (isExcluded(funcName)) {
          match = match.replace(RegExp('\\b' + funcName + '\\.placeholder\\s*=\\s*'), '');
        }
      });
      return _.contains(removeComments(match), 'placeholder') ? match : '';
    });

    // remove unneeded property dependencies
    _.each(objDependencies, function(propName) {
      if (!_.contains(includeObjs, propName)) {
        source = removeProp(source, propName);
      }
    });

    // remove code used to resolve unneeded `support` properties
    source = source.replace(matchProp(source, 'support'), function(match) {
      return match.replace(/^ *\(function\(x\)[^{]+\{\n(( *)var\s+Ctor\s*=[\s\S]+?(?:\n *for.+)+\n)([\s\S]+?)}\(0,\s*0\)\);\n/m, function(match, setup, indent, body) {
        var modified = setup;

        if (!/\.spliceObjects\s*=\s*(?!false|true)/.test(body)) {
          modified = modified.replace(/^ *object\s*=.+\n/m, '');
        }
        if (!/\.enumPrototypes\s*=\s*(?!false|true)/.test(body) &&
            !/\.nonEnumShadows\s*=\s*(?!false|true)/.test(body) &&
            !/\.ownLast\s*=\s*(?!false|true)/.test(body)) {
          modified = modified
            .replace(/\bCtor\s*=.+\s+/, '')
            .replace(/^ *Ctor\.prototype.+\s+.+\n/m, '')
            .replace(/(?:,\n)? *props\s*=[^;=]+/, '')
        }
        if (!/\.nonEnumArgs\s*=\s*(?!false|true)/.test(body)) {
          modified = modified.replace(/\s*for\s*\(var\s+argsKey\b[^}]+}/, '');
        }
        if (!/\.nonEnumStrings\s*=\s*(?!false|true)/.test(body)) {
          modified = modified.replace(/\s*for\s*\(var\s+strKey\b[^}]+}/, '');
        }
        // cleanup the empty var statement
        modified = modified.replace(/^ *var;\n/m, '');

        // if no setup then remove IIFE
        return modified == false
          ? body.replace(RegExp('^' + indent, 'gm'), indent.slice(0, -2))
          : match.replace(setup, modified);
      });
    });

    // remove unneeded variable dependencies
    if (!_.contains(includeVars, 'root')) {
      source = removeVar(source, 'freeGlobal');
    }
    if (isModularize) {
      _.each(varDependencies, function(varName) {
        if (!_.contains(includeFuncs, varName) &&
            !_.contains(includeObjs, varName) &&
            !_.contains(includeVars, varName)) {
          source = removeVar(source, varName);
        }
      });
    }
    (function() {
      var useMap = createMap(),
          snippet = cleanupSource(removeStrings(removeComments(source))),
          varNames = _.without(_.difference(getVars(snippet), includeFuncs, includeObjs, includeVars), 'freeGlobal');

      // remove unused variables
      while (varNames.length) {
        varNames = _.sortBy(varNames, function(varName) {
          var result = isVarUsed(snippet, varName);
          useMap[varName] = result;
          return result;
        });

        if (useMap[varNames[0]]) {
          varNames.shift();
        }
        else {
          while (varNames.length && !useMap[varNames[0]]) {
            snippet = removeVar(snippet, varNames[0]);
            source = removeVar(source, varNames[0]);
            varNames.shift();
          }
        }
      }
    }());
  }

  // customize Lo-Dash's IIFE
  if (isIIFE) {
    source = replaceIIFE(source, iife);
  }

  /*--------------------------------------------------------------------------*/

  callback || (callback = defaultBuildCallback);
  source = cleanupSource(source);

  // flag to track if `outputPath` has been used by `callback`
  var outputUsed = false;

  // expand `outputPath` and create directories if needed
  if (outputPath) {
    outputPath = (function() {
      var dirname = path.dirname(outputPath);
      fs.mkdirpSync(dirname);
      return path.join(fs.realpathSync(dirname), path.basename(outputPath));
    }());
  }
  // used as the basename of the output path
  var basename = 'lodash';
  if (outputPath) {
    basename = outputPath;
  } else if (isTemplate) {
    basename += '.templates';
  } else if (isCustom) {
    basename += '.custom';
  }
  // output development build
  if (!isProduction && (isCustom || isDevelopment || isTemplate)) {
    var devSource = source;
    if (isCustom) {
      devSource = addCommandsToHeader(devSource, options);
    }
    if (isDevelopment && isStdOut) {
      stdout.write(devSource);
      callback({
        'source': devSource
      });
    }
    else if (!isStdOut) {
      filePath = outputPath || path.join(cwd, basename + '.js');
      outputUsed = true;
      callback({
        'source': devSource,
        'outputPath': filePath
      });
    }
  }
  // begin the minification process
  if (!isDevelopment) {
    if (outputPath && outputUsed) {
      outputPath = path.join(path.dirname(outputPath), path.basename(outputPath, '.js') + '.min.js');
    } else if (!outputPath) {
      outputPath = path.join(cwd, basename + '.min.js');
    }
    minify(source, {
      'filePath': filePath,
      'isMapped': isMapped,
      'isSilent': isSilent,
      'isTemplate': isTemplate,
      'modes': isIIFE ? ['simple', 'hybrid'] : ['simple', 'advanced', 'hybrid'],
      'outputPath': outputPath,
      'sourceMapURL': sourceMapURL,
      'onComplete': function(data) {
        if (isCustom) {
          data.source = addCommandsToHeader(data.source, options);
        }
        if (isStdOut) {
          delete data.outputPath;
          stdout.write(data.source);
        }
        callback(data);
      }
    });
  }
}

/*----------------------------------------------------------------------------*/

// export `build`
if (module != require.main) {
  module.exports = build;
}
// or invoked directly
else {
  build(process.argv);
}
